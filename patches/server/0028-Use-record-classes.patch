From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: camdenorrb <me@12oclock.dev>
Date: Sat, 22 Oct 2022 03:58:29 -0500
Subject: [PATCH] Use record classes


diff --git a/src/main/java/ca/spottedleaf/dataconverter/minecraft/versions/V2970.java b/src/main/java/ca/spottedleaf/dataconverter/minecraft/versions/V2970.java
index 09940a62240a98f4126be4375ad51daed4332eb6..3f50ca1a8a3f3ac925cbacb295233f29a9bf3f5c 100644
--- a/src/main/java/ca/spottedleaf/dataconverter/minecraft/versions/V2970.java
+++ b/src/main/java/ca/spottedleaf/dataconverter/minecraft/versions/V2970.java
@@ -160,36 +160,28 @@ public final class V2970 {
         });
     }
 
-    private static final class BiomeRemap {
-
-        public final Map<String, String> biomeToNewStructure;
-        public final String dfl;
-
-        private BiomeRemap(final Map<String, String> biomeToNewStructure, final String dfl) {
-            this.biomeToNewStructure = biomeToNewStructure;
-            this.dfl = dfl;
-        }
-
-        public static @NotNull BiomeRemap create(final String newId) {
-            return new BiomeRemap(null, newId);
-        }
-
-        public static @NotNull BiomeRemap create(final @NotNull Map<List<String>, String> biomeMap, final String newId) {
-            final Map<String, String> biomeToNewStructure = new HashMap<>();
-
-            for (final Map.Entry<List<String>, String> entry : biomeMap.entrySet()) {
-                final List<String> biomes = entry.getKey();
-                final String newBiomeStructure = entry.getValue();
-
-                for (int i = 0, len = biomes.size(); i < len; ++i) {
-                    final String biome = biomes.get(i);
-                    if (biomeToNewStructure.putIfAbsent(biome, newBiomeStructure) != null) {
-                        throw new IllegalStateException("Duplicate biome remap: " + biome + " -> " + newBiomeStructure + ", but already mapped to " + biomeToNewStructure.get(biome));
-                    }
-                }
-            }
-
-            return new BiomeRemap(biomeToNewStructure, newId);
-        }
-    }
+	private record BiomeRemap(Map<String, String> biomeToNewStructure, String dfl) {
+
+		public static @NotNull BiomeRemap create(final String newId) {
+			return new BiomeRemap(null, newId);
+		}
+
+		public static @NotNull BiomeRemap create(final @NotNull Map<List<String>, String> biomeMap, final String newId) {
+			final Map<String, String> biomeToNewStructure = new HashMap<>();
+
+			for (final Map.Entry<List<String>, String> entry : biomeMap.entrySet()) {
+				final List<String> biomes = entry.getKey();
+				final String newBiomeStructure = entry.getValue();
+
+				for (int i = 0, len = biomes.size(); i < len; ++i) {
+					final String biome = biomes.get(i);
+					if (biomeToNewStructure.putIfAbsent(biome, newBiomeStructure) != null) {
+						throw new IllegalStateException("Duplicate biome remap: " + biome + " -> " + newBiomeStructure + ", but already mapped to " + biomeToNewStructure.get(biome));
+					}
+				}
+			}
+
+			return new BiomeRemap(biomeToNewStructure, newId);
+		}
+	}
 }
diff --git a/src/main/java/com/destroystokyo/paper/PaperSkinParts.java b/src/main/java/com/destroystokyo/paper/PaperSkinParts.java
index d9a6cbc6aa334c1f6ed3baf817743d3d097a8724..5e71d2553b36046fdbb7eb7b9a0e2935657ec2ca 100644
--- a/src/main/java/com/destroystokyo/paper/PaperSkinParts.java
+++ b/src/main/java/com/destroystokyo/paper/PaperSkinParts.java
@@ -5,71 +5,61 @@ import org.jetbrains.annotations.Nullable;
 
 import java.util.StringJoiner;
 
-public class PaperSkinParts implements SkinParts {
 
-    private final int raw;
-
-    public PaperSkinParts(int raw) {
-        this.raw = raw;
-    }
-
-    public boolean hasCapeEnabled() {
-        return (raw & 1) == 1;
-    }
-
-    public boolean hasJacketEnabled() {
-        return (raw >> 1 & 1) == 1;
-    }
-
-    public boolean hasLeftSleeveEnabled() {
-        return (raw >> 2 & 1) == 1;
-    }
-
-    public boolean hasRightSleeveEnabled() {
-        return (raw >> 3 & 1) == 1;
-    }
-
-    public boolean hasLeftPantsEnabled() {
-        return (raw >> 4 & 1) == 1;
-    }
-
-    public boolean hasRightPantsEnabled() {
-        return (raw >> 5 & 1) == 1;
-    }
-
-    public boolean hasHatsEnabled() {
-        return (raw >> 6 & 1) == 1;
-    }
-
-    @Override
-    public int getRaw() {
-        return raw;
-    }
-
-    @Override
-    public boolean equals(@Nullable Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-        PaperSkinParts that = (PaperSkinParts) o;
-        return raw == that.raw;
-    }
-
-    @Override
-    public int hashCode() {
-        return Objects.hashCode(Integer.valueOf(raw));
-    }
-
-    @Override
-    public String toString() {
-        return new StringJoiner(", ", PaperSkinParts.class.getSimpleName() + "[", "]")
-            .add("raw=" + raw)
-            .add("cape=" + hasCapeEnabled())
-            .add("jacket=" + hasJacketEnabled())
-            .add("leftSleeve=" + hasLeftSleeveEnabled())
-            .add("rightSleeve=" + hasRightSleeveEnabled())
-            .add("leftPants=" + hasLeftPantsEnabled())
-            .add("rightPants=" + hasRightPantsEnabled())
-            .add("hats=" + hasHatsEnabled())
-            .toString();
-    }
+public record PaperSkinParts(int raw) implements SkinParts {
+
+	public boolean hasCapeEnabled() {
+		return (raw & 1) == 1;
+	}
+
+	public boolean hasJacketEnabled() {
+		return (raw >> 1 & 1) == 1;
+	}
+
+	public boolean hasLeftSleeveEnabled() {
+		return (raw >> 2 & 1) == 1;
+	}
+
+	public boolean hasRightSleeveEnabled() {
+		return (raw >> 3 & 1) == 1;
+	}
+
+	public boolean hasLeftPantsEnabled() {
+		return (raw >> 4 & 1) == 1;
+	}
+
+	public boolean hasRightPantsEnabled() {
+		return (raw >> 5 & 1) == 1;
+	}
+
+	public boolean hasHatsEnabled() {
+		return (raw >> 6 & 1) == 1;
+	}
+
+	@Override
+	public boolean equals(@Nullable Object o) {
+		if (this == o) return true;
+		if (o == null || getClass() != o.getClass()) return false;
+		PaperSkinParts that = (PaperSkinParts) o;
+		return raw == that.raw;
+	}
+
+	@Override
+	public int hashCode() {
+		return Objects.hashCode(Integer.valueOf(raw));
+	}
+
+	@Override
+	public String toString() {
+		return new StringJoiner(", ", PaperSkinParts.class.getSimpleName() + "[", "]")
+			.add("raw=" + raw)
+			.add("cape=" + hasCapeEnabled())
+			.add("jacket=" + hasJacketEnabled())
+			.add("leftSleeve=" + hasLeftSleeveEnabled())
+			.add("rightSleeve=" + hasRightSleeveEnabled())
+			.add("leftPants=" + hasLeftPantsEnabled())
+			.add("rightPants=" + hasRightPantsEnabled())
+			.add("hats=" + hasHatsEnabled())
+			.toString();
+	}
 }
diff --git a/src/main/java/com/destroystokyo/paper/ServerSchedulerReportingWrapper.java b/src/main/java/com/destroystokyo/paper/ServerSchedulerReportingWrapper.java
index 542ad0292293ac9d2edd03fbc58edc2d0c99ec23..bb81235c748475499fff4c8e1703010b63be0938 100644
--- a/src/main/java/com/destroystokyo/paper/ServerSchedulerReportingWrapper.java
+++ b/src/main/java/com/destroystokyo/paper/ServerSchedulerReportingWrapper.java
@@ -10,31 +10,30 @@ import org.jetbrains.annotations.NotNull;
 /**
  * Reporting wrapper to catch exceptions not natively
  */
-public class ServerSchedulerReportingWrapper implements Runnable {
+public record ServerSchedulerReportingWrapper(@NotNull CraftTask internalTask) implements Runnable {
 
-    private final @NotNull CraftTask internalTask;
+	public ServerSchedulerReportingWrapper(CraftTask internalTask) {
+		this.internalTask = Preconditions.checkNotNull(internalTask, "internalTask");
+	}
 
-    public ServerSchedulerReportingWrapper(CraftTask internalTask) {
-        this.internalTask = Preconditions.checkNotNull(internalTask, "internalTask");
-    }
+	@Override
+	public void run() {
+		try {
+			internalTask.run();
+		} catch (RuntimeException e) {
+			internalTask.getOwner().getServer().getPluginManager().callEvent(
+				new ServerExceptionEvent(new ServerSchedulerException(e, internalTask))
+			);
+			throw e;
+		} catch (Throwable t) {
+			internalTask.getOwner().getServer().getPluginManager().callEvent(
+				new ServerExceptionEvent(new ServerSchedulerException(t, internalTask))
+			); //Do not rethrow, since it is not permitted with Runnable#run
+		}
+	}
 
-    @Override
-    public void run() {
-        try {
-            internalTask.run();
-        } catch (RuntimeException e) {
-            internalTask.getOwner().getServer().getPluginManager().callEvent(
-                    new ServerExceptionEvent(new ServerSchedulerException(e, internalTask))
-            );
-            throw e;
-        } catch (Throwable t) {
-            internalTask.getOwner().getServer().getPluginManager().callEvent(
-                    new ServerExceptionEvent(new ServerSchedulerException(t, internalTask))
-            ); //Do not rethrow, since it is not permitted with Runnable#run
-        }
-    }
-
-    public CraftTask getInternalTask() {
-        return internalTask;
-    }
+	@Override
+	public CraftTask internalTask() {
+		return internalTask;
+	}
 }
diff --git a/src/main/java/com/destroystokyo/paper/profile/PaperGameProfileRepository.java b/src/main/java/com/destroystokyo/paper/profile/PaperGameProfileRepository.java
index c7b4d0263fbebe90377263870c8b9f05b486fb9e..fc00a7ab0a7c959f3ee3c2b39a7a3a3e9be3a3bb 100644
--- a/src/main/java/com/destroystokyo/paper/profile/PaperGameProfileRepository.java
+++ b/src/main/java/com/destroystokyo/paper/profile/PaperGameProfileRepository.java
@@ -46,23 +46,18 @@ public class PaperGameProfileRepository extends YggdrasilGameProfileRepository {
         }
     }
 
-    private static class PreProfileLookupCallback implements ProfileLookupCallback {
-        private final ProfileLookupCallback callback;
-
-        PreProfileLookupCallback(ProfileLookupCallback callback) {
-            this.callback = callback;
-        }
-
-        @Override
-        public void onProfileLookupSucceeded(GameProfile gameProfile) {
-            PlayerProfile from = CraftPlayerProfile.asBukkitMirror(gameProfile);
-            new LookupProfileEvent(from).callEvent();
-            callback.onProfileLookupSucceeded(gameProfile);
-        }
-
-        @Override
-        public void onProfileLookupFailed(GameProfile gameProfile, Exception e) {
-            callback.onProfileLookupFailed(gameProfile, e);
-        }
-    }
+	private record PreProfileLookupCallback(ProfileLookupCallback callback) implements ProfileLookupCallback {
+
+		@Override
+		public void onProfileLookupSucceeded(GameProfile gameProfile) {
+			PlayerProfile from = CraftPlayerProfile.asBukkitMirror(gameProfile);
+			new LookupProfileEvent(from).callEvent();
+			callback.onProfileLookupSucceeded(gameProfile);
+		}
+
+		@Override
+		public void onProfileLookupFailed(GameProfile gameProfile, Exception e) {
+			callback.onProfileLookupFailed(gameProfile, e);
+		}
+	}
 }
diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index 42afe116a9f0ab2d03d64edfc5b52e8871d996b7..64e03f7cfbfcaed848997479a5cef7f0b2a60877 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -746,19 +746,8 @@ public final class PlayerChunkLoader {
         this.tryLoadChunks();
     }
 
-    static final class ChunkPriorityHolder {
-        public final int chunkX;
-        public final int chunkZ;
-        public final int manhattanDistanceToPlayer;
-        public final double priority;
-
-        public ChunkPriorityHolder(final int chunkX, final int chunkZ, final int manhattanDistanceToPlayer, final double priority) {
-            this.chunkX = chunkX;
-            this.chunkZ = chunkZ;
-            this.manhattanDistanceToPlayer = manhattanDistanceToPlayer;
-            this.priority = priority;
-        }
-    }
+	record ChunkPriorityHolder(int chunkX, int chunkZ, int manhattanDistanceToPlayer, double priority) {
+	}
 
     public static final class PlayerLoaderData {
 
diff --git a/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java b/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
index 6e23466db7b1b1ef1325ac4d0b88a7e14c4da93f..2187e69bd4914bd58afbf410504a43bfe6e15d3b 100644
--- a/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
+++ b/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
@@ -1049,53 +1049,47 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
         }
     }
 
-    /**
-     * Class exists to replace {@link Long} usages as keys inside non-fastutil hashtables. The hash for some Long {@code x}
-     * is defined as {@code (x >>> 32) ^ x}. Chunk keys as long values are defined as {@code ((chunkX & 0xFFFFFFFFL) | (chunkZ << 32))},
-     * which means the hashcode as a Long value will be {@code chunkX ^ chunkZ}. Given that most chunks are created within a radius arounds players,
-     * this will lead to many hash collisions. So, this class uses a better hashing algorithm so that usage of
-     * non-fastutil collections is not degraded.
-     */
-    public static final class ChunkCoordinate implements Comparable<ChunkCoordinate> {
-
-        public final long key;
-
-        public ChunkCoordinate(final long key) {
-            this.key = key;
-        }
-
-        @Override
-        public int hashCode() {
-            return (int)HashCommon.mix(this.key);
-        }
-
-        @Override
-        public boolean equals(final Object obj) {
-            if (this == obj) {
-                return true;
-            }
-
-            if (!(obj instanceof ChunkCoordinate)) {
-                return false;
-            }
-
-            final ChunkCoordinate other = (ChunkCoordinate)obj;
-
-            return this.key == other.key;
-        }
-
-        // This class is intended for HashMap/ConcurrentHashMap usage, which do treeify bin nodes if the chain
-        // is too large. So we should implement compareTo to help.
-        @Override
-        public int compareTo(final RegionFileIOThread.@NotNull ChunkCoordinate other) {
-            return Long.compare(this.key, other.key);
-        }
-
-        @Override
-        public @NotNull String toString() {
-            return new ChunkPos(this.key).toString();
-        }
-    }
+	/**
+	 * Class exists to replace {@link Long} usages as keys inside non-fastutil hashtables. The hash for some Long {@code x}
+	 * is defined as {@code (x >>> 32) ^ x}. Chunk keys as long values are defined as {@code ((chunkX & 0xFFFFFFFFL) | (chunkZ << 32))},
+	 * which means the hashcode as a Long value will be {@code chunkX ^ chunkZ}. Given that most chunks are created within a radius arounds players,
+	 * this will lead to many hash collisions. So, this class uses a better hashing algorithm so that usage of
+	 * non-fastutil collections is not degraded.
+	 */
+	public record ChunkCoordinate(long key) implements Comparable<ChunkCoordinate> {
+
+		@Override
+		public int hashCode() {
+			return (int) HashCommon.mix(this.key);
+		}
+
+		@Override
+		public boolean equals(final Object obj) {
+			if (this == obj) {
+				return true;
+			}
+
+			if (!(obj instanceof ChunkCoordinate)) {
+				return false;
+			}
+
+			final ChunkCoordinate other = (ChunkCoordinate) obj;
+
+			return this.key == other.key;
+		}
+
+		// This class is intended for HashMap/ConcurrentHashMap usage, which do treeify bin nodes if the chain
+		// is too large. So we should implement compareTo to help.
+		@Override
+		public int compareTo(final RegionFileIOThread.@NotNull ChunkCoordinate other) {
+			return Long.compare(this.key, other.key);
+		}
+
+		@Override
+		public @NotNull String toString() {
+			return new ChunkPos(this.key).toString();
+		}
+	}
 
     public static abstract class ChunkDataController {
 
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLightTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLightTask.java
index f1e568e3e5c753796d39bdbb77bcbe30cc98f3d6..2a62cc67480a4a47114338c94fd51b904b360e40 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLightTask.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLightTask.java
@@ -128,56 +128,48 @@ public final class ChunkLightTask extends ChunkProgressionTask {
         }
     }
 
-    private static final class LightTask implements BooleanSupplier {
-
-        protected final StarLightInterface lightEngine;
-        protected final ChunkLightTask task;
-
-        public LightTask(final StarLightInterface lightEngine, final ChunkLightTask task) {
-            this.lightEngine = lightEngine;
-            this.task = task;
-        }
-
-        @Override
-        public boolean getAsBoolean() {
-            final ChunkLightTask task = this.task;
-            // executed on light thread
-            if (!task.priorityHolder.markExecuting()) {
-                // cancelled
-                return false;
-            }
-
-            try {
-                final Boolean[] emptySections = StarLightEngine.getEmptySectionsForChunk(task.fromChunk);
-
-                if (task.fromChunk.isLightCorrect() && task.fromChunk.getStatus().isOrAfter(ChunkStatus.LIGHT)) {
-                    this.lightEngine.forceLoadInChunk(task.fromChunk, emptySections);
-                    this.lightEngine.checkChunkEdges(task.chunkX, task.chunkZ);
-                } else {
-                    task.fromChunk.setLightCorrect(false);
-                    this.lightEngine.lightChunk(task.fromChunk, emptySections);
-                    task.fromChunk.setLightCorrect(true);
-                }
-                // we need to advance status
-                if (task.fromChunk instanceof ProtoChunk chunk && chunk.getStatus() == ChunkStatus.LIGHT.getParent()) {
-                    chunk.setStatus(ChunkStatus.LIGHT);
-                }
-            } catch (final Throwable thr) {
-                if (!(thr instanceof ThreadDeath)) {
-                    LOGGER.fatal("Failed to light chunk " + task.fromChunk.getPos() + " in world '" + this.lightEngine.getWorld().getWorld().getName() + "'", thr);
-                }
-
-                task.complete(null, thr);
-
-                if (thr instanceof ThreadDeath) {
-                    throw (ThreadDeath)thr;
-                }
-
-                return true;
-            }
-
-            task.complete(task.fromChunk, null);
-            return true;
-        }
-    }
+	private record LightTask(StarLightInterface lightEngine, ChunkLightTask task) implements BooleanSupplier {
+
+		@Override
+		public boolean getAsBoolean() {
+			final ChunkLightTask task = this.task;
+			// executed on light thread
+			if (!task.priorityHolder.markExecuting()) {
+				// cancelled
+				return false;
+			}
+
+			try {
+				final Boolean[] emptySections = StarLightEngine.getEmptySectionsForChunk(task.fromChunk);
+
+				if (task.fromChunk.isLightCorrect() && task.fromChunk.getStatus().isOrAfter(ChunkStatus.LIGHT)) {
+					this.lightEngine.forceLoadInChunk(task.fromChunk, emptySections);
+					this.lightEngine.checkChunkEdges(task.chunkX, task.chunkZ);
+				} else {
+					task.fromChunk.setLightCorrect(false);
+					this.lightEngine.lightChunk(task.fromChunk, emptySections);
+					task.fromChunk.setLightCorrect(true);
+				}
+				// we need to advance status
+				if (task.fromChunk instanceof ProtoChunk chunk && chunk.getStatus() == ChunkStatus.LIGHT.getParent()) {
+					chunk.setStatus(ChunkStatus.LIGHT);
+				}
+			} catch (final Throwable thr) {
+				if (!(thr instanceof ThreadDeath)) {
+					LOGGER.fatal("Failed to light chunk " + task.fromChunk.getPos() + " in world '" + this.lightEngine.getWorld().getWorld().getName() + "'", thr);
+				}
+
+				task.complete(null, thr);
+
+				if (thr instanceof ThreadDeath) {
+					throw (ThreadDeath) thr;
+				}
+
+				return true;
+			}
+
+			task.complete(task.fromChunk, null);
+			return true;
+		}
+	}
 }
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
index b8849248a7398f25894ef215aa250a2c7f714950..30217a040626ef91f5657fbcddf0d5ca414ff62e 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
@@ -721,23 +721,13 @@ public final class ChunkTaskScheduler {
 
     public static final ArrayDeque<ChunkInfo> WAITING_CHUNKS = new ArrayDeque<>(); // stack
 
-    public static final class ChunkInfo {
+	public record ChunkInfo(int chunkX, int chunkZ, ServerLevel world) {
 
-        public final int chunkX;
-        public final int chunkZ;
-        public final ServerLevel world;
-
-        public ChunkInfo(final int chunkX, final int chunkZ, final ServerLevel world) {
-            this.chunkX = chunkX;
-            this.chunkZ = chunkZ;
-            this.world = world;
-        }
-
-        @Override
-        public @NotNull String toString() {
-            return "[( " + this.chunkX + "," + this.chunkZ + ") in '" + this.world.getWorld().getName() + "']";
-        }
-    }
+		@Override
+		public @NotNull String toString() {
+			return "[( " + this.chunkX + "," + this.chunkZ + ") in '" + this.world.getWorld().getName() + "']";
+		}
+	}
 
     public static void pushChunkWait(final ServerLevel world, final int chunkX, final int chunkZ) {
         synchronized (WAITING_CHUNKS) {
diff --git a/src/main/java/io/papermc/paper/world/ThreadedWorldUpgrader.java b/src/main/java/io/papermc/paper/world/ThreadedWorldUpgrader.java
index 3599ac8b2e8c026f681760efbb8dd32fffc0020b..46154ebe594fb581e22af93dc0d7d078a7cdb198 100644
--- a/src/main/java/io/papermc/paper/world/ThreadedWorldUpgrader.java
+++ b/src/main/java/io/papermc/paper/world/ThreadedWorldUpgrader.java
@@ -144,65 +144,55 @@ public class ThreadedWorldUpgrader {
         }
     }
 
-    private static final class ConvertTask implements Runnable {
-
-        private final WorldInfo worldInfo;
-        private final int regionX;
-        private final int regionZ;
-
-        public ConvertTask(final WorldInfo worldInfo, final int regionX, final int regionZ) {
-            this.worldInfo = worldInfo;
-            this.regionX = regionX;
-            this.regionZ = regionZ;
-        }
+    private record ConvertTask(WorldInfo worldInfo, int regionX, int regionZ) implements Runnable {
 
         @Override
-        public void run() {
-            final int regionCX = this.regionX << 5;
-            final int regionCZ = this.regionZ << 5;
-
-            final Supplier<DimensionDataStorage> persistentDataSupplier = this.worldInfo.persistentDataSupplier;
-            final ChunkStorage loader = this.worldInfo.loader;
-            final boolean removeCaches = this.worldInfo.removeCaches;
-            final ResourceKey<LevelStem> worldKey = this.worldInfo.worldKey;
-
-            for (int cz = regionCZ; cz < (regionCZ + 32); ++cz) {
-                for (int cx = regionCX; cx < (regionCX + 32); ++cx) {
-                    final ChunkPos chunkPos = new ChunkPos(cx, cz);
-                    try {
-                        // no need to check the coordinate of the chunk, the regionfilecache does that for us
-
-                        CompoundTag chunkNBT = (loader.read(chunkPos).join()).orElse(null);
-
-                        if (chunkNBT == null) {
-                            continue;
+            public void run() {
+                final int regionCX = this.regionX << 5;
+                final int regionCZ = this.regionZ << 5;
+
+                final Supplier<DimensionDataStorage> persistentDataSupplier = this.worldInfo.persistentDataSupplier;
+                final ChunkStorage loader = this.worldInfo.loader;
+                final boolean removeCaches = this.worldInfo.removeCaches;
+                final ResourceKey<LevelStem> worldKey = this.worldInfo.worldKey;
+
+                for (int cz = regionCZ; cz < (regionCZ + 32); ++cz) {
+                    for (int cx = regionCX; cx < (regionCX + 32); ++cx) {
+                        final ChunkPos chunkPos = new ChunkPos(cx, cz);
+                        try {
+                            // no need to check the coordinate of the chunk, the regionfilecache does that for us
+
+                            CompoundTag chunkNBT = (loader.read(chunkPos).join()).orElse(null);
+
+                            if (chunkNBT == null) {
+                                continue;
+                            }
+
+                            final int versionBefore = ChunkStorage.getVersion(chunkNBT);
+
+                            chunkNBT = loader.upgradeChunkTag(worldKey, persistentDataSupplier, chunkNBT, this.worldInfo.generatorKey, chunkPos, null);
+
+                            boolean modified = versionBefore < SharedConstants.getCurrentVersion().getWorldVersion();
+
+                            if (removeCaches) {
+                                final CompoundTag level = chunkNBT.getCompound("Level");
+                                modified |= level.contains("Heightmaps");
+                                level.remove("Heightmaps");
+                                modified |= level.contains("isLightOn");
+                                level.remove("isLightOn");
+                            }
+
+                            if (modified) {
+                                this.worldInfo.modifiedChunks.getAndIncrement();
+                                loader.write(chunkPos, chunkNBT);
+                            }
+                        } catch (final Exception ex) {
+                            LOGGER.error("Error upgrading chunk {}", chunkPos, ex);
+                        } finally {
+                            this.worldInfo.convertedChunks.getAndIncrement();
                         }
-
-                        final int versionBefore = ChunkStorage.getVersion(chunkNBT);
-
-                        chunkNBT = loader.upgradeChunkTag(worldKey, persistentDataSupplier, chunkNBT, this.worldInfo.generatorKey, chunkPos, null);
-
-                        boolean modified = versionBefore < SharedConstants.getCurrentVersion().getWorldVersion();
-
-                        if (removeCaches) {
-                            final CompoundTag level = chunkNBT.getCompound("Level");
-                            modified |= level.contains("Heightmaps");
-                            level.remove("Heightmaps");
-                            modified |= level.contains("isLightOn");
-                            level.remove("isLightOn");
-                        }
-
-                        if (modified) {
-                            this.worldInfo.modifiedChunks.getAndIncrement();
-                            loader.write(chunkPos, chunkNBT);
-                        }
-                    } catch (final Exception ex) {
-                        LOGGER.error("Error upgrading chunk {}", chunkPos, ex);
-                    } finally {
-                        this.worldInfo.convertedChunks.getAndIncrement();
                     }
                 }
             }
         }
-    }
 }
diff --git a/src/main/java/net/minecraft/commands/arguments/MessageArgument.java b/src/main/java/net/minecraft/commands/arguments/MessageArgument.java
index 4da1ebcd0226897f8b03bd00a851f793df3506f4..cd3f159f9059316f926bcaffaba995ece61d31a5 100644
--- a/src/main/java/net/minecraft/commands/arguments/MessageArgument.java
+++ b/src/main/java/net/minecraft/commands/arguments/MessageArgument.java
@@ -142,20 +142,20 @@ public class MessageArgument implements SignedArgument<MessageArgument.Message>
 
         public Component toComponent(CommandSourceStack source, boolean canUseSelectors) throws CommandSyntaxException {
             if (this.parts.length != 0 && canUseSelectors) {
-                MutableComponent mutableComponent = Component.literal(this.text.substring(0, this.parts[0].getStart()));
-                int i = this.parts[0].getStart();
+                MutableComponent mutableComponent = Component.literal(this.text.substring(0, this.parts[0].start()));
+                int i = this.parts[0].start();
 
                 for(MessageArgument.Part part : this.parts) {
                     Component component = part.toComponent(source);
-                    if (i < part.getStart()) {
-                        mutableComponent.append(this.text.substring(i, part.getStart()));
+                    if (i < part.start()) {
+                        mutableComponent.append(this.text.substring(i, part.start()));
                     }
 
                     if (component != null) {
                         mutableComponent.append(component);
                     }
 
-                    i = part.getEnd();
+                    i = part.end();
                 }
 
                 if (i < this.text.length()) {
@@ -210,32 +210,11 @@ public class MessageArgument implements SignedArgument<MessageArgument.Message>
         }
     }
 
-    public static class Part {
-        private final int start;
-        private final int end;
-        private final EntitySelector selector;
-
-        public Part(int start, int end, EntitySelector selector) {
-            this.start = start;
-            this.end = end;
-            this.selector = selector;
-        }
-
-        public int getStart() {
-            return this.start;
-        }
-
-        public int getEnd() {
-            return this.end;
-        }
-
-        public EntitySelector getSelector() {
-            return this.selector;
-        }
+    public record Part(int start, int end, EntitySelector selector) {
 
         @Nullable
-        public Component toComponent(CommandSourceStack source) throws CommandSyntaxException {
-            return EntitySelector.joinNames(this.selector.findEntities(source));
+            public Component toComponent(CommandSourceStack source) throws CommandSyntaxException {
+                return EntitySelector.joinNames(this.selector.findEntities(source));
+            }
         }
-    }
 }
diff --git a/src/main/java/net/minecraft/util/BitStorage.java b/src/main/java/net/minecraft/util/BitStorage.java
index 106610ccc74b70b557b01c61262d56c4f1147acf..af60479d43db84589927ae88c4afca63c2263751 100644
--- a/src/main/java/net/minecraft/util/BitStorage.java
+++ b/src/main/java/net/minecraft/util/BitStorage.java
@@ -11,7 +11,7 @@ public interface BitStorage {
 
     long[] getRaw();
 
-    int getSize();
+    int size();
 
     int getBits();
 
diff --git a/src/main/java/net/minecraft/util/SimpleBitStorage.java b/src/main/java/net/minecraft/util/SimpleBitStorage.java
index 36e33923bf48e56c743ed043bcbc66bc32f0422f..2930406058953a2f2a85a13e7dfb3024bff9eb17 100644
--- a/src/main/java/net/minecraft/util/SimpleBitStorage.java
+++ b/src/main/java/net/minecraft/util/SimpleBitStorage.java
@@ -115,7 +115,7 @@ public class SimpleBitStorage implements BitStorage {
     }
 
     @Override
-    public int getSize() {
+    public int size() {
         return this.size;
     }
 
diff --git a/src/main/java/net/minecraft/util/ZeroBitStorage.java b/src/main/java/net/minecraft/util/ZeroBitStorage.java
index a510390bf4b657e7d601c3b4d7e28a7bc01222de..83a4c081f6b5df0d37d3467ef66346438578c3c5 100644
--- a/src/main/java/net/minecraft/util/ZeroBitStorage.java
+++ b/src/main/java/net/minecraft/util/ZeroBitStorage.java
@@ -4,13 +4,8 @@ import java.util.Arrays;
 import java.util.function.IntConsumer;
 
 
-public class ZeroBitStorage implements BitStorage {
+public record ZeroBitStorage(int size) implements BitStorage {
     public static final long[] RAW = new long[0];
-    private final int size;
-
-    public ZeroBitStorage(int size) {
-        this.size = size;
-    }
 
     @Override
     public final int getAndSet(int index, int value) { // Paper - make final for inline
@@ -36,11 +31,6 @@ public class ZeroBitStorage implements BitStorage {
         return RAW;
     }
 
-    @Override
-    public int getSize() {
-        return this.size;
-    }
-
     @Override
     public int getBits() {
         return 0;
@@ -49,7 +39,7 @@ public class ZeroBitStorage implements BitStorage {
     // Paper start
     @Override
     public void forEach(DataBitConsumer consumer) {
-        for(int i = 0; i < this.size; ++i) {
+        for (int i = 0; i < this.size; ++i) {
             consumer.accept(i, 0);
         }
     }
@@ -57,7 +47,7 @@ public class ZeroBitStorage implements BitStorage {
 
     @Override
     public void getAll(IntConsumer action) {
-        for(int i = 0; i < this.size; ++i) {
+        for (int i = 0; i < this.size; ++i) {
             action.accept(0);
         }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/gossip/GossipContainer.java b/src/main/java/net/minecraft/world/entity/ai/gossip/GossipContainer.java
index 719f5679a73a3e12f1d04aebb6d73383ba1b615c..f0d78f533def53a2a12d2ccc7a2571a994e689ac 100644
--- a/src/main/java/net/minecraft/world/entity/ai/gossip/GossipContainer.java
+++ b/src/main/java/net/minecraft/world/entity/ai/gossip/GossipContainer.java
@@ -274,35 +274,26 @@ public class GossipContainer {
         // Paper end
     }
 
-    static class GossipEntry {
-        public static final String TAG_TARGET = "Target";
-        public static final String TAG_TYPE = "Type";
-        public static final String TAG_VALUE = "Value";
-        public final UUID target;
-        public final GossipType type;
-        public final int value;
-
-        public GossipEntry(UUID target, GossipType type, int value) {
-            this.target = target;
-            this.type = type;
-            this.value = value;
-        }
-
-        public int weightedValue() {
-            return this.value * this.type.weight;
-        }
-
-        @Override
-        public String toString() {
-            return "GossipEntry{target=" + this.target + ", type=" + this.type + ", value=" + this.value + "}";
-        }
-
-        public <T> Dynamic<T> store(DynamicOps<T> dynamicOps) {
-            return new Dynamic<>(dynamicOps, dynamicOps.createMap(ImmutableMap.of(dynamicOps.createString("Target"), UUIDUtil.CODEC.encodeStart(dynamicOps, this.target).result().orElseThrow(RuntimeException::new), dynamicOps.createString("Type"), dynamicOps.createString(this.type.id), dynamicOps.createString("Value"), dynamicOps.createInt(this.value))));
-        }
-
-        public static DataResult<GossipContainer.GossipEntry> load(Dynamic<?> dynamic) {
-            return DataResult.unbox(DataResult.instance().group(dynamic.get("Target").read(UUIDUtil.CODEC), dynamic.get("Type").asString().map(GossipType::byId), dynamic.get("Value").asNumber().map(Number::intValue)).apply(DataResult.instance(), GossipContainer.GossipEntry::new));
-        }
-    }
+	record GossipEntry(UUID target, GossipType type, int value) {
+		public static final String TAG_TARGET = "Target";
+		public static final String TAG_TYPE = "Type";
+		public static final String TAG_VALUE = "Value";
+
+		public int weightedValue() {
+			return this.value * this.type.weight;
+		}
+
+		@Override
+		public String toString() {
+			return "GossipEntry{target=" + this.target + ", type=" + this.type + ", value=" + this.value + "}";
+		}
+
+		public <T> Dynamic<T> store(DynamicOps<T> dynamicOps) {
+			return new Dynamic<>(dynamicOps, dynamicOps.createMap(ImmutableMap.of(dynamicOps.createString("Target"), UUIDUtil.CODEC.encodeStart(dynamicOps, this.target).result().orElseThrow(RuntimeException::new), dynamicOps.createString("Type"), dynamicOps.createString(this.type.id), dynamicOps.createString("Value"), dynamicOps.createInt(this.value))));
+		}
+
+		public static DataResult<GossipEntry> load(Dynamic<?> dynamic) {
+			return DataResult.unbox(DataResult.instance().group(dynamic.get("Target").read(UUIDUtil.CODEC), dynamic.get("Type").asString().map(GossipType::byId), dynamic.get("Value").asNumber().map(Number::intValue)).apply(DataResult.instance(), GossipContainer.GossipEntry::new));
+		}
+	}
 }
diff --git a/src/main/java/net/minecraft/world/item/crafting/Ingredient.java b/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
index 895c0f1600139e340aa22a7c398978add56fa706..72b78296f36ba92b44d947545d6ba4e152ddaaf1 100644
--- a/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
+++ b/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
@@ -218,36 +218,30 @@ public final class Ingredient implements Predicate<ItemStack> {
         JsonObject serialize();
     }
 
-    private static class TagValue implements Ingredient.Value {
+	private record TagValue(TagKey<Item> tag) implements Value {
 
-        private final TagKey<Item> tag;
+		@Override
+		public Collection<ItemStack> getItems() {
+			List<ItemStack> list = Lists.newArrayList();
+			Iterator iterator = Registry.ITEM.getTagOrEmpty(this.tag).iterator();
 
-        TagValue(TagKey<Item> tag) {
-            this.tag = tag;
-        }
+			while (iterator.hasNext()) {
+				Holder<Item> holder = (Holder) iterator.next();
 
-        @Override
-        public Collection<ItemStack> getItems() {
-            List<ItemStack> list = Lists.newArrayList();
-            Iterator iterator = Registry.ITEM.getTagOrEmpty(this.tag).iterator();
+				list.add(new ItemStack(holder));
+			}
 
-            while (iterator.hasNext()) {
-                Holder<Item> holder = (Holder) iterator.next();
+			return list;
+		}
 
-                list.add(new ItemStack(holder));
-            }
+		@Override
+		public JsonObject serialize() {
+			JsonObject jsonobject = new JsonObject();
 
-            return list;
-        }
-
-        @Override
-        public JsonObject serialize() {
-            JsonObject jsonobject = new JsonObject();
-
-            jsonobject.addProperty("tag", this.tag.location().toString());
-            return jsonobject;
-        }
-    }
+			jsonobject.addProperty("tag", this.tag.location().toString());
+			return jsonobject;
+		}
+	}
 
     public static class ItemValue implements Ingredient.Value {
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
index c3717d033a6110a55ed345fe2e83ce5ad17ae2e3..8376b3966fca61b37fe9351c0410cda56a6819e2 100644
--- a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
@@ -362,7 +362,7 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
     @Override
     public void count(PalettedContainer.CountConsumer<T> counter) {
         if (this.data.palette.getSize() == 1) {
-            counter.accept(this.data.palette.valueFor(0), this.data.storage.getSize());
+            counter.accept(this.data.palette.valueFor(0), this.data.storage.size());
         } else {
             Int2IntOpenHashMap int2IntOpenHashMap = new Int2IntOpenHashMap();
             this.data.storage.getAll((key) -> {
@@ -397,7 +397,7 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
 
     static record Data<T>(PalettedContainer.Configuration<T> configuration, BitStorage storage, Palette<T> palette) {
         public void copyFrom(Palette<T> palette, BitStorage storage) {
-            for(int i = 0; i < storage.getSize(); ++i) {
+            for(int i = 0; i < storage.size(); ++i) {
                 T object = palette.valueFor(storage.get(i));
                 this.storage.set(i, this.palette.idFor(object));
             }
@@ -405,7 +405,7 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
         }
 
         public int getSerializedSize() {
-            return 1 + this.palette.getSerializedSize() + FriendlyByteBuf.getVarIntSize(this.storage.getSize()) + this.storage.getRaw().length * 8;
+            return 1 + this.palette.getSerializedSize() + FriendlyByteBuf.getVarIntSize(this.storage.size()) + this.storage.getRaw().length * 8;
         }
 
         // Paper start - Anti-Xray - Add chunk packet info
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftParticle.java b/src/main/java/org/bukkit/craftbukkit/CraftParticle.java
index 550234b82d2b29acab77f0ff453a512412270910..07d3633231c91f8aad55f907d0335d1c57541a4d 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftParticle.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftParticle.java
@@ -214,7 +214,7 @@ public enum CraftParticle {
                 Location destination = ((Vibration.Destination.BlockDestination) vibration.getDestination()).getLocation();
                 source = new BlockPositionSource(new BlockPos(destination.getBlockX(), destination.getBlockY(), destination.getBlockZ()));
             } else if (vibration.getDestination() instanceof Vibration.Destination.EntityDestination) {
-                Entity destination = ((CraftEntity) ((Vibration.Destination.EntityDestination) vibration.getDestination()).getEntity()).getHandle();
+                Entity destination = ((CraftEntity) ((Vibration.Destination.EntityDestination) vibration.getDestination()).entity()).getHandle();
                 source = new EntityPositionSource(destination, destination.getEyeHeight());
             } else {
                 throw new IllegalArgumentException("Unknown vibration destination " + vibration.getDestination());
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 972e1c5afb38f712509daf302812c814da2f6d27..3461d7197b5c17685619d218ee2dddd92aaa3e01 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -2121,7 +2121,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
             result = this.locateNearestStructure(origin, Structure.BASTION_REMNANT, radius, findUnexplored);
         }
 
-        return (result == null) ? null : result.getLocation();
+        return (result == null) ? null : result.location();
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/advancement/CraftAdvancement.java b/src/main/java/org/bukkit/craftbukkit/advancement/CraftAdvancement.java
index fcc1cb281ab55d37bf0f452e5b7d87ca5e7110cc..1ad0da95a02d47e7ff60737fa638b04018ef93da 100644
--- a/src/main/java/org/bukkit/craftbukkit/advancement/CraftAdvancement.java
+++ b/src/main/java/org/bukkit/craftbukkit/advancement/CraftAdvancement.java
@@ -8,17 +8,7 @@ import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.jetbrains.annotations.NotNull;
 
 
-public class CraftAdvancement implements org.bukkit.advancement.Advancement {
-
-    private final Advancement handle;
-
-    public CraftAdvancement(Advancement handle) {
-        this.handle = handle;
-    }
-
-    public Advancement getHandle() {
-        return this.handle;
-    }
+public record CraftAdvancement(Advancement handle) implements org.bukkit.advancement.Advancement {
 
     @Override
     public @NotNull NamespacedKey getKey() {
diff --git a/src/main/java/org/bukkit/craftbukkit/advancement/CraftAdvancementDisplay.java b/src/main/java/org/bukkit/craftbukkit/advancement/CraftAdvancementDisplay.java
index f559a700af2dd47af6b04733f84f092e79ea74c7..6766a2ca879ea04149e1dd6aa7decf9f8df0036c 100644
--- a/src/main/java/org/bukkit/craftbukkit/advancement/CraftAdvancementDisplay.java
+++ b/src/main/java/org/bukkit/craftbukkit/advancement/CraftAdvancementDisplay.java
@@ -8,60 +8,50 @@ import org.bukkit.inventory.ItemStack;
 import org.jetbrains.annotations.NotNull;
 
 
-public class CraftAdvancementDisplay implements org.bukkit.advancement.AdvancementDisplay {
-
-    private final DisplayInfo handle;
-
-    public CraftAdvancementDisplay(DisplayInfo handle) {
-        this.handle = handle;
-    }
-
-    public DisplayInfo getHandle() {
-        return this.handle;
-    }
-
-    @Override
-    public @NotNull String getTitle() {
-        return CraftChatMessage.fromComponent(this.handle.getTitle());
-    }
-
-    @Override
-    public @NotNull String getDescription() {
-        return CraftChatMessage.fromComponent(this.handle.getDescription());
-    }
-
-    @Override
-    public @NotNull ItemStack getIcon() {
-        return CraftItemStack.asBukkitCopy(this.handle.getIcon());
-    }
-
-    @Override
-    public boolean shouldShowToast() {
-        return this.handle.shouldShowToast();
-    }
-
-    @Override
-    public boolean shouldAnnounceChat() {
-        return this.handle.shouldAnnounceChat();
-    }
-
-    @Override
-    public boolean isHidden() {
-        return this.handle.isHidden();
-    }
-
-    @Override
-    public float getX() {
-        return this.handle.getX();
-    }
-
-    @Override
-    public float getY() {
-        return this.handle.getY();
-    }
-
-    @Override
-    public @NotNull AdvancementDisplayType getType() {
-        return AdvancementDisplayType.values()[this.handle.getFrame().ordinal()];
-    }
+public record CraftAdvancementDisplay(DisplayInfo handle) implements org.bukkit.advancement.AdvancementDisplay {
+
+	@Override
+	public @NotNull String getTitle() {
+		return CraftChatMessage.fromComponent(this.handle.getTitle());
+	}
+
+	@Override
+	public @NotNull String getDescription() {
+		return CraftChatMessage.fromComponent(this.handle.getDescription());
+	}
+
+	@Override
+	public @NotNull ItemStack getIcon() {
+		return CraftItemStack.asBukkitCopy(this.handle.getIcon());
+	}
+
+	@Override
+	public boolean shouldShowToast() {
+		return this.handle.shouldShowToast();
+	}
+
+	@Override
+	public boolean shouldAnnounceChat() {
+		return this.handle.shouldAnnounceChat();
+	}
+
+	@Override
+	public boolean isHidden() {
+		return this.handle.isHidden();
+	}
+
+	@Override
+	public float getX() {
+		return this.handle.getX();
+	}
+
+	@Override
+	public float getY() {
+		return this.handle.getY();
+	}
+
+	@Override
+	public @NotNull AdvancementDisplayType getType() {
+		return AdvancementDisplayType.values()[this.handle.getFrame().ordinal()];
+	}
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/advancement/CraftAdvancementProgress.java b/src/main/java/org/bukkit/craftbukkit/advancement/CraftAdvancementProgress.java
index b2d3b7235eba8e1fbfdbf0411ff72f720898a950..dc5feae6a13648160d5dcf8aaabb2cd3067622c1 100644
--- a/src/main/java/org/bukkit/craftbukkit/advancement/CraftAdvancementProgress.java
+++ b/src/main/java/org/bukkit/craftbukkit/advancement/CraftAdvancementProgress.java
@@ -35,12 +35,12 @@ public class CraftAdvancementProgress implements AdvancementProgress {
 
     @Override
     public boolean awardCriteria(@NotNull String criteria) {
-        return this.playerData.award(this.advancement.getHandle(), criteria);
+        return this.playerData.award(this.advancement.handle(), criteria);
     }
 
     @Override
     public boolean revokeCriteria(@NotNull String criteria) {
-        return this.playerData.revoke(this.advancement.getHandle(), criteria);
+        return this.playerData.revoke(this.advancement.handle(), criteria);
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/boss/CraftBossBar.java b/src/main/java/org/bukkit/craftbukkit/boss/CraftBossBar.java
index ab4fc0faca6c93d85b9676768cce91beb08a520a..3119a9540377b9560cabd4bbe312957b6cb5b853 100644
--- a/src/main/java/org/bukkit/craftbukkit/boss/CraftBossBar.java
+++ b/src/main/java/org/bukkit/craftbukkit/boss/CraftBossBar.java
@@ -4,7 +4,6 @@ import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 
 import java.util.EnumMap;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.function.Consumer;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftArmorStand.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftArmorStand.java
index 4dd0515a380e946dfba45079df17116d86cbcb1e..69bfcef5237540b7fda549e09b2e93e4a4b08117 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftArmorStand.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftArmorStand.java
@@ -4,7 +4,6 @@ import net.minecraft.core.Rotations;
 import org.bukkit.craftbukkit.CraftEquipmentSlot;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.entity.ArmorStand;
-import org.bukkit.entity.ArmorStand.LockType;
 import org.bukkit.entity.EntityType;
 import org.bukkit.inventory.EquipmentSlot;
 import org.bukkit.inventory.ItemStack;
@@ -202,9 +201,9 @@ public class CraftArmorStand extends CraftLivingEntity implements ArmorStand {
 
     private static @NotNull Rotations toNMS(@NotNull EulerAngle old) {
         return new Rotations(
-            (float) Math.toDegrees(old.getX()),
-            (float) Math.toDegrees(old.getY()),
-            (float) Math.toDegrees(old.getZ())
+            (float) Math.toDegrees(old.x()),
+            (float) Math.toDegrees(old.y()),
+            (float) Math.toDegrees(old.z())
         );
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index b040539175d1de4afb5214e759a23cd57336841c..f5ca81f07139a5aa7b2242de606a2b653ba7a399 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -2508,7 +2508,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
         CraftAdvancement craft = (CraftAdvancement) advancement;
         PlayerAdvancements data = this.getHandle().getAdvancements();
-        AdvancementProgress progress = data.getOrStartProgress(craft.getHandle());
+        AdvancementProgress progress = data.getOrStartProgress(craft.handle());
 
         return new CraftAdvancementProgress(craft, data, progress);
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/help/HelpTopicAmendment.java b/src/main/java/org/bukkit/craftbukkit/help/HelpTopicAmendment.java
index b9cc1bb44b4d263e50dfa5c412a6f428a274245f..33a4d48e76c4c4a673c38c47aacb357e41641c87 100644
--- a/src/main/java/org/bukkit/craftbukkit/help/HelpTopicAmendment.java
+++ b/src/main/java/org/bukkit/craftbukkit/help/HelpTopicAmendment.java
@@ -3,48 +3,45 @@ package org.bukkit.craftbukkit.help;
 /**
  * A HelpTopicAmendment represents the contents of a topic amendment from the help.yml
  */
-public class HelpTopicAmendment {
-    private final String topicName;
-    private final String shortText;
-    private final String fullText;
-    private final String permission;
-
-    public HelpTopicAmendment(String topicName, String shortText, String fullText, String permission) {
-        this.fullText = fullText;
-        this.shortText = shortText;
-        this.topicName = topicName;
-        this.permission = permission;
-    }
+public record HelpTopicAmendment(String topicName, String shortText, String fullText, String permission) {
 
     /**
      * Gets the amended full text
+     *
      * @return the full text
      */
-    public String getFullText() {
+    @Override
+    public String fullText() {
         return this.fullText;
     }
 
     /**
      * Gets the amended short text
+     *
      * @return the short text
      */
-    public String getShortText() {
+    @Override
+    public String shortText() {
         return this.shortText;
     }
 
     /**
      * Gets the name of the topic being amended
+     *
      * @return the topic name
      */
-    public String getTopicName() {
+    @Override
+    public String topicName() {
         return this.topicName;
     }
 
     /**
      * Gets the amended permission
+     *
      * @return the permission
      */
-    public String getPermission() {
+    @Override
+    public String permission() {
         return this.permission;
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/help/SimpleHelpMap.java b/src/main/java/org/bukkit/craftbukkit/help/SimpleHelpMap.java
index 9494a708206ba12756e61e1850f2053bf855e4ca..a869bdb2f918f60d708297bd0bc8c4103f58b798 100644
--- a/src/main/java/org/bukkit/craftbukkit/help/SimpleHelpMap.java
+++ b/src/main/java/org/bukkit/craftbukkit/help/SimpleHelpMap.java
@@ -177,10 +177,10 @@ public class SimpleHelpMap implements HelpMap {
 
         // Amend help topics from the help.yml file
         for (HelpTopicAmendment amendment : this.yaml.getTopicAmendments()) {
-            if (this.helpTopics.containsKey(amendment.getTopicName())) {
-                this.helpTopics.get(amendment.getTopicName()).amendTopic(amendment.getShortText(), amendment.getFullText());
-                if (amendment.getPermission() != null) {
-                    this.helpTopics.get(amendment.getTopicName()).amendCanSee(amendment.getPermission());
+            if (this.helpTopics.containsKey(amendment.topicName())) {
+                this.helpTopics.get(amendment.topicName()).amendTopic(amendment.shortText(), amendment.fullText());
+                if (amendment.permission() != null) {
+                    this.helpTopics.get(amendment.topicName()).amendCanSee(amendment.permission());
                 }
             }
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/tags/DeprecatedContainerTagType.java b/src/main/java/org/bukkit/craftbukkit/inventory/tags/DeprecatedContainerTagType.java
index ddcfef486f6d81adc5f939934824b8dcb60de8c2..d3c3a1d74d8c15c8d543ea9e7a2a67707847f2c7 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/tags/DeprecatedContainerTagType.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/tags/DeprecatedContainerTagType.java
@@ -34,7 +34,7 @@ public final class DeprecatedContainerTagType<Z> implements PersistentDataType<P
         Validate.isInstanceOf(DeprecatedCustomTagContainer.class, deprecated, "Could not wrap deprecated API due to foreign CustomItemTagContainer implementation %s", deprecated.getClass().getSimpleName());
 
         DeprecatedCustomTagContainer tagContainer = (DeprecatedCustomTagContainer) deprecated;
-        PersistentDataContainer wrapped = tagContainer.getWrapped();
+        PersistentDataContainer wrapped = tagContainer.wrapped();
         Validate.isInstanceOf(CraftPersistentDataContainer.class, wrapped, "Could not wrap deprecated API due to wrong deprecation wrapper %s", deprecated.getClass().getSimpleName());
 
         CraftPersistentDataContainer craftTagContainer = (CraftPersistentDataContainer) wrapped;
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/tags/DeprecatedCustomTagContainer.java b/src/main/java/org/bukkit/craftbukkit/inventory/tags/DeprecatedCustomTagContainer.java
index ccbb151e225c024c7ff8ee4d02d298172bdbe867..fe9aa93a73def1810fb2fb57058a03917df67f54 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/tags/DeprecatedCustomTagContainer.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/tags/DeprecatedCustomTagContainer.java
@@ -14,57 +14,47 @@ import org.jetbrains.annotations.NotNull;
  * that wraps the new api to still be usable with the old api parts.
  */
 @SuppressWarnings("unchecked")
-public final class DeprecatedCustomTagContainer implements CustomItemTagContainer {
-
-    private final PersistentDataContainer wrapped;
-
-    public DeprecatedCustomTagContainer(PersistentDataContainer wrapped) {
-        this.wrapped = wrapped;
-    }
-
-    @Override
-    public <T, Z> void setCustomTag(@NotNull NamespacedKey key, @NotNull ItemTagType<T, Z> type, @NotNull Z value) {
-        if (Objects.equals(CustomItemTagContainer.class, type.getPrimitiveType())) {
-            this.wrapped.set(key, new DeprecatedContainerTagType<>((ItemTagType<CustomItemTagContainer, Z>) type), value);
-        } else {
-            this.wrapped.set(key, new DeprecatedItemTagType<>(type), value);
-        }
-    }
-
-    @Override
-    public <T, Z> boolean hasCustomTag(@NotNull NamespacedKey key, @NotNull ItemTagType<T, Z> type) {
-        if (Objects.equals(CustomItemTagContainer.class, type.getPrimitiveType())) {
-            return this.wrapped.has(key, new DeprecatedContainerTagType<>((ItemTagType<CustomItemTagContainer, Z>) type));
-        } else {
-            return this.wrapped.has(key, new DeprecatedItemTagType<>(type));
-        }
-    }
-
-    @Override
-    public <T, Z> Z getCustomTag(@NotNull NamespacedKey key, @NotNull ItemTagType<T, Z> type) {
-        if (Objects.equals(CustomItemTagContainer.class, type.getPrimitiveType())) {
-            return this.wrapped.get(key, new DeprecatedContainerTagType<>((ItemTagType<CustomItemTagContainer, Z>) type));
-        } else {
-            return this.wrapped.get(key, new DeprecatedItemTagType<>(type));
-        }
-    }
-
-    @Override
-    public void removeCustomTag(@NotNull NamespacedKey key) {
-        this.wrapped.remove(key);
-    }
-
-    @Override
-    public boolean isEmpty() {
-        return this.wrapped.isEmpty();
-    }
-
-    @Override
-    public @NotNull ItemTagAdapterContext getAdapterContext() {
-        return new DeprecatedItemAdapterContext(this.wrapped.getAdapterContext());
-    }
-
-    public PersistentDataContainer getWrapped() {
-        return this.wrapped;
-    }
+public record DeprecatedCustomTagContainer(PersistentDataContainer wrapped) implements CustomItemTagContainer {
+
+	@Override
+	public <T, Z> void setCustomTag(@NotNull NamespacedKey key, @NotNull ItemTagType<T, Z> type, @NotNull Z value) {
+		if (Objects.equals(CustomItemTagContainer.class, type.getPrimitiveType())) {
+			this.wrapped.set(key, new DeprecatedContainerTagType<>((ItemTagType<CustomItemTagContainer, Z>) type), value);
+		} else {
+			this.wrapped.set(key, new DeprecatedItemTagType<>(type), value);
+		}
+	}
+
+	@Override
+	public <T, Z> boolean hasCustomTag(@NotNull NamespacedKey key, @NotNull ItemTagType<T, Z> type) {
+		if (Objects.equals(CustomItemTagContainer.class, type.getPrimitiveType())) {
+			return this.wrapped.has(key, new DeprecatedContainerTagType<>((ItemTagType<CustomItemTagContainer, Z>) type));
+		} else {
+			return this.wrapped.has(key, new DeprecatedItemTagType<>(type));
+		}
+	}
+
+	@Override
+	public <T, Z> Z getCustomTag(@NotNull NamespacedKey key, @NotNull ItemTagType<T, Z> type) {
+		if (Objects.equals(CustomItemTagContainer.class, type.getPrimitiveType())) {
+			return this.wrapped.get(key, new DeprecatedContainerTagType<>((ItemTagType<CustomItemTagContainer, Z>) type));
+		} else {
+			return this.wrapped.get(key, new DeprecatedItemTagType<>(type));
+		}
+	}
+
+	@Override
+	public void removeCustomTag(@NotNull NamespacedKey key) {
+		this.wrapped.remove(key);
+	}
+
+	@Override
+	public boolean isEmpty() {
+		return this.wrapped.isEmpty();
+	}
+
+	@Override
+	public @NotNull ItemTagAdapterContext getAdapterContext() {
+		return new DeprecatedItemAdapterContext(this.wrapped.getAdapterContext());
+	}
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/persistence/CraftPersistentDataTypeRegistry.java b/src/main/java/org/bukkit/craftbukkit/persistence/CraftPersistentDataTypeRegistry.java
index e280c56991b5fbc6ad5def415e5e75e7e10108ce..77bfe287458a071ca1c40245a1cb6d80b0eb9c3e 100644
--- a/src/main/java/org/bukkit/craftbukkit/persistence/CraftPersistentDataTypeRegistry.java
+++ b/src/main/java/org/bukkit/craftbukkit/persistence/CraftPersistentDataTypeRegistry.java
@@ -45,54 +45,49 @@ public final class CraftPersistentDataTypeRegistry {
             this.extractor = extractor;
         }
 
-        /**
-         * This method will extract the value stored in the tag, according to
-         * the expected primitive type.
-         *
-         * @param base the base to extract from
-         *
-         * @return the value stored inside of the tag
-         *
-         * @throws ClassCastException if the passed base is not an instanced of
-         * the defined base type and therefore is not applicable to the
-         * extractor function
-         */
-        T extract(@NotNull Tag base) {
-            if (!this.nbtBaseType.isInstance(base)) {
-                throw new IllegalArgumentException(String.format("The provided NBTBase was of the type %s. Expected type %s", base.getClass().getSimpleName(), this.nbtBaseType.getSimpleName()));
-            }
-            return this.extractor.apply(this.nbtBaseType.cast(base));
-        }
+		/**
+		 * This method will extract the value stored in the tag, according to
+		 * the expected primitive type.
+		 *
+		 * @param base the base to extract from
+		 * @return the value stored inside of the tag
+		 * @throws ClassCastException if the passed base is not an instanced of
+		 *                            the defined base type and therefore is not applicable to the
+		 *                            extractor function
+		 */
+		T extract(@NotNull Tag base) {
+			if (!this.nbtBaseType.isInstance(base)) {
+				throw new IllegalArgumentException(String.format("The provided NBTBase was of the type %s. Expected type %s", base.getClass().getSimpleName(), this.nbtBaseType.getSimpleName()));
+			}
+			return this.extractor.apply(this.nbtBaseType.cast(base));
+		}
 
-        /**
-         * Builds a tag instance wrapping around the provided value object.
-         *
-         * @param value the value to store inside the created tag
-         *
-         * @return the new tag instance
-         *
-         * @throws ClassCastException if the passed value object is not of the
-         * defined primitive type and therefore is not applicable to the builder
-         * function
-         */
-        Z build(@NotNull Object value) {
-            if (!this.primitiveType.isInstance(value)) {
-                throw new IllegalArgumentException(String.format("The provided value was of the type %s. Expected type %s", value.getClass().getSimpleName(), this.primitiveType.getSimpleName()));
-            }
-            return this.builder.apply(this.primitiveType.cast(value));
-        }
+		/**
+		 * Builds a tag instance wrapping around the provided value object.
+		 *
+		 * @param value the value to store inside the created tag
+		 * @return the new tag instance
+		 * @throws ClassCastException if the passed value object is not of the
+		 *                            defined primitive type and therefore is not applicable to the builder
+		 *                            function
+		 */
+		Z build(@NotNull Object value) {
+			if (!this.primitiveType.isInstance(value)) {
+				throw new IllegalArgumentException(String.format("The provided value was of the type %s. Expected type %s", value.getClass().getSimpleName(), this.primitiveType.getSimpleName()));
+			}
+			return this.builder.apply(this.primitiveType.cast(value));
+		}
 
-        /**
-         * Returns if the tag instance matches the adapters one.
-         *
-         * @param base the base to check
-         *
-         * @return if the tag was an instance of the set type
-         */
-        boolean isInstance(Tag base) {
-            return this.nbtBaseType.isInstance(base);
-        }
-    }
+		/**
+		 * Returns if the tag instance matches the adapters one.
+		 *
+		 * @param base the base to check
+		 * @return if the tag was an instance of the set type
+		 */
+		boolean isInstance(Tag base) {
+			return this.nbtBaseType.isInstance(base);
+		}
+	}
 
     private final Map<Class, TagAdapter> adapters = new HashMap<>();
 
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftIconCache.java b/src/main/java/org/bukkit/craftbukkit/util/CraftIconCache.java
index 3d90b3426873a3528af14f7f1ab0adae0027da2e..f412e1916a5a45fe23c5c6f0bf31d27ae76dcbf2 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftIconCache.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftIconCache.java
@@ -2,11 +2,9 @@ package org.bukkit.craftbukkit.util;
 
 import org.bukkit.util.CachedServerIcon;
 
-public class CraftIconCache implements CachedServerIcon {
-    public final String value;
 
-    public String getData() { return value; } // Paper
-    public CraftIconCache(final String value) {
-        this.value = value;
-    }
+public record CraftIconCache(String value) implements CachedServerIcon {
+	public String getData() {
+		return value;
+	} // Paper
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftStructureSearchResult.java b/src/main/java/org/bukkit/craftbukkit/util/CraftStructureSearchResult.java
index 06fc224d0f4d73bf7e22dfc588e47b48e428fae6..1a825ef6193dfdd7fbbf900fc84c831134c2e70f 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftStructureSearchResult.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftStructureSearchResult.java
@@ -6,21 +6,15 @@ import org.bukkit.util.StructureSearchResult;
 import org.jetbrains.annotations.NotNull;
 
 
-public class CraftStructureSearchResult implements StructureSearchResult {
+public record CraftStructureSearchResult(Structure structure, Location location) implements StructureSearchResult {
 
-    private final Structure structure;
-    private final Location location;
+	@Override
+	public @NotNull Structure structure() {
+		return this.structure;
+	}
 
-    public CraftStructureSearchResult(Structure structure, Location location) {
-        this.structure = structure;
-        this.location = location;
-    }
-
-    public @NotNull Structure getStructure() {
-        return this.structure;
-    }
-
-    public @NotNull Location getLocation() {
-        return this.location;
-    }
+	@Override
+	public @NotNull Location location() {
+		return this.location;
+	}
 }
