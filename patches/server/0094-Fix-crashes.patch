From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: camdenorrb <me@12oclock.dev>
Date: Tue, 15 Nov 2022 03:45:55 -0600
Subject: [PATCH] Fix crashes


diff --git a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
index bacc1724a54ff4fee8127f47a07241ee44ee7ca4..c8aa1266d96c72e61f3cb9354a3905a90091f127 100644
--- a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
+++ b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
@@ -21,6 +21,7 @@ import org.jetbrains.annotations.Nullable;
 
 import java.util.*;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 
@@ -239,16 +240,12 @@ public final class ChunkEntitySlices {
         final EntityCollectionBySection ret = new EntityCollectionBySection(this);
 
         for (int sectionIndex = 0; sectionIndex < this.allEntities.entitiesBySection.length; ++sectionIndex) {
-            final BasicEntityList<Entity> sectionEntities = this.allEntities.entitiesBySection[sectionIndex];
+            final List<Entity> sectionEntities = this.allEntities.entitiesBySection[sectionIndex];
             if (sectionEntities == null) {
                 continue;
             }
 
-            final Entity[] storage = sectionEntities.storage;
-
-            for (int i = 0, len = Math.min(storage.length, sectionEntities.size()); i < len; ++i) {
-                final Entity entity = storage[i];
-
+            for (final Entity entity : sectionEntities) {
                 if (clazz.isInstance(entity)) {
                     ret.addEntity(entity, sectionIndex);
                 }
@@ -269,7 +266,8 @@ public final class ChunkEntitySlices {
         }
     }
 
-    protected static final class BasicEntityList<E extends Entity> {
+
+/*    protected static final class BasicEntityList<E extends Entity> {
 
         protected static final Entity[] EMPTY = new Entity[0];
         protected static final int DEFAULT_CAPACITY = 4;
@@ -344,12 +342,12 @@ public final class ChunkEntitySlices {
             return this.indexOf(entity) != -1;
         }
     }
-
+*/
     protected static final class EntityCollectionBySection {
 
         protected final ChunkEntitySlices manager;
         protected final long @NotNull [] nonEmptyBitset;
-        protected final BasicEntityList<Entity> @NotNull [] entitiesBySection;
+        protected final CopyOnWriteArrayList<Entity> @NotNull [] entitiesBySection;
         protected int count;
 
         public EntityCollectionBySection(final @NotNull ChunkEntitySlices manager) {
@@ -358,18 +356,18 @@ public final class ChunkEntitySlices {
             final int sectionCount = manager.maxSection - manager.minSection + 1;
 
             this.nonEmptyBitset = new long[(sectionCount + (Long.SIZE - 1)) >>> 6]; // (sectionCount + (Long.SIZE - 1)) / Long.SIZE
-            this.entitiesBySection = new BasicEntityList[sectionCount];
+            this.entitiesBySection = new CopyOnWriteArrayList[sectionCount];
         }
 
         public void addEntity(final Entity entity, final int sectionIndex) {
-            BasicEntityList<Entity> list = this.entitiesBySection[sectionIndex];
+            CopyOnWriteArrayList<Entity> list = this.entitiesBySection[sectionIndex];
 
-            if (list != null && list.has(entity)) {
+            if (list != null && list.contains(entity)) {
                 return;
             }
 
             if (list == null) {
-                this.entitiesBySection[sectionIndex] = list = new BasicEntityList<>();
+                this.entitiesBySection[sectionIndex] = list = new CopyOnWriteArrayList<>();
                 this.nonEmptyBitset[sectionIndex >>> 6] |= (1L << (sectionIndex & (Long.SIZE - 1)));
             }
 
@@ -378,7 +376,7 @@ public final class ChunkEntitySlices {
         }
 
         public void removeEntity(final Entity entity, final int sectionIndex) {
-            final BasicEntityList<Entity> list = this.entitiesBySection[sectionIndex];
+            final CopyOnWriteArrayList<Entity> list = this.entitiesBySection[sectionIndex];
 
             if (list == null || !list.remove(entity)) {
                 return;
@@ -403,19 +401,16 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
+            final CopyOnWriteArrayList<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
-                final BasicEntityList<Entity> list = entitiesBySection[section - minSection];
+                final CopyOnWriteArrayList<Entity> list = entitiesBySection[section - minSection];
 
                 if (list == null) {
                     continue;
                 }
 
-                final Entity[] storage = list.storage;
-
-                for (int i = 0, len = Math.min(storage.length, list.size()); i < len; ++i) {
-                    final Entity entity = storage[i];
+                for (final Entity entity : list) {
 
                     if (entity == null || entity == except || !entity.getBoundingBox().intersects(box)) {
                         continue;
@@ -442,20 +437,16 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
+            final List<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
-                final BasicEntityList<Entity> list = entitiesBySection[section - minSection];
+                final List<Entity> list = entitiesBySection[section - minSection];
 
                 if (list == null) {
                     continue;
                 }
 
-                final Entity[] storage = list.storage;
-
-                for (int i = 0, len = Math.min(storage.length, list.size()); i < len; ++i) {
-                    final Entity entity = storage[i];
-
+                for (final Entity entity : list) {
                     if (entity == null || entity == except || !entity.getBoundingBox().intersects(box)) {
                         continue;
                     }
@@ -493,19 +484,17 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
+            final List<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
-                final BasicEntityList<Entity> list = entitiesBySection[section - minSection];
+                final List<Entity> list = entitiesBySection[section - minSection];
 
                 if (list == null) {
                     continue;
                 }
 
-                final Entity[] storage = list.storage;
 
-                for (int i = 0, len = Math.min(storage.length, list.size()); i < len; ++i) {
-                    final Entity entity = storage[i];
+                for (final Entity entity : list) {
 
                     if (entity == null || entity == except || !entity.getBoundingBox().intersects(box)) {
                         continue;
@@ -528,6 +517,7 @@ public final class ChunkEntitySlices {
                             into.add(part);
                         }
                     }
+
                 }
             }
         }
@@ -544,20 +534,17 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
+            final List<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
-                final BasicEntityList<Entity> list = entitiesBySection[section - minSection];
+                final List<Entity> list = entitiesBySection[section - minSection];
 
                 if (list == null) {
                     continue;
                 }
 
-                final Entity[] storage = list.storage;
-
-                for (int i = 0, len = Math.min(storage.length, list.size()); i < len; ++i) {
-                    final Entity entity = storage[i];
 
+                for (final Entity entity : list) {
                     if (entity == null || (type != null && entity.getType() != type) || !entity.getBoundingBox().intersects(box)) {
                         continue;
                     }
@@ -568,6 +555,7 @@ public final class ChunkEntitySlices {
 
                     into.add((T)entity);
                 }
+
             }
         }
     }
