From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: camdenorrb <me@12oclock.dev>
Date: Sun, 4 Dec 2022 11:49:31 -0600
Subject: [PATCH] Fixes


diff --git a/build.gradle.kts b/build.gradle.kts
index f7c5bd7e32cf4e4adc4b95dbd62f1bf6898b5a0b..5bfb40909bf7e1fa609da994af73a387dd4aa604 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -41,7 +41,7 @@ dependencies {
      */
     implementation("org.apache.logging.log4j:log4j-core:2.19.0") // Paper - implementation
     annotationProcessor("org.apache.logging.log4j:log4j-core:2.19.0") // Paper - Needed to generate meta for our Log4j plugins
-    implementation("io.netty:netty-codec-haproxy:4.1.84.Final")
+    implementation("io.netty:netty-codec-haproxy:4.1.85.Final")
     // Paper end
     implementation("org.apache.logging.log4j:log4j-iostreams:2.19.0") // Paper
     implementation("org.apache.logging.log4j:log4j-slf4j2-impl:2.19.0") // Paper
@@ -50,27 +50,27 @@ dependencies {
     implementation("org.spongepowered:configurate-yaml:4.1.2") // Paper - config files
     implementation("commons-lang:commons-lang:2.6")
     implementation("net.fabricmc:mapping-io:0.3.0") // Paper - needed to read mappings for stacktrace deobfuscation
-    // Paper start - Use Velocity cipher
-    implementation("com.velocitypowered:velocity-native:3.1.2-SNAPSHOT") {
-        isTransitive = false
-    }
-    // Paper end
-    runtimeOnly("org.xerial:sqlite-jdbc:3.39.3.0")
-    runtimeOnly("mysql:mysql-connector-java:8.0.30")
-    runtimeOnly("com.lmax:disruptor:3.4.4") // Paper
-
-    runtimeOnly("org.apache.maven:maven-resolver-provider:3.8.5")
-    runtimeOnly("org.apache.maven.resolver:maven-resolver-connector-basic:1.8.2")
-    runtimeOnly("org.apache.maven.resolver:maven-resolver-transport-http:1.8.2")
-
-    testImplementation("io.github.classgraph:classgraph:4.8.149") // Paper - mob goal test
-    testImplementation("org.junit.jupiter:junit-jupiter-api:5.9.0")
-    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.9.0")
-    testImplementation("org.junit.jupiter:junit-jupiter-params:5.9.0")
-    testImplementation("org.hamcrest:hamcrest-library:2.2")
-    testImplementation("org.mockito:mockito-core:4.8.0")
-
-    implementation("io.netty:netty-all:4.1.84.Final") // Paper - Bump netty
+	// Paper start - Use Velocity cipher
+	implementation("com.velocitypowered:velocity-native:3.1.2-SNAPSHOT") {
+		isTransitive = false
+	}
+	// Paper end
+	runtimeOnly("org.xerial:sqlite-jdbc:3.40.0.0")
+	runtimeOnly("mysql:mysql-connector-java:8.0.30")
+	runtimeOnly("com.lmax:disruptor:3.4.4") // Paper
+
+	runtimeOnly("org.apache.maven:maven-resolver-provider:3.8.5")
+	runtimeOnly("org.apache.maven.resolver:maven-resolver-connector-basic:1.9.2")
+	runtimeOnly("org.apache.maven.resolver:maven-resolver-transport-http:1.9.2")
+
+	testImplementation("io.github.classgraph:classgraph:4.8.151") // Paper - mob goal test
+	testImplementation("org.junit.jupiter:junit-jupiter-api:5.9.0")
+	testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.9.0")
+	testImplementation("org.junit.jupiter:junit-jupiter-params:5.9.0")
+	testImplementation("org.hamcrest:hamcrest-library:2.2")
+	testImplementation("org.mockito:mockito-core:4.8.0")
+
+	implementation("io.netty:netty-all:4.1.85.Final") // Paper - Bump netty
 }
 
 val craftbukkitPackageVersion = "1_19_R1" // Paper
diff --git a/src/main/java/io/papermc/paper/chunk/SingleThreadChunkRegionManager.java b/src/main/java/io/papermc/paper/chunk/SingleThreadChunkRegionManager.java
index be860452b43c032b31961b021e0639ea173137f3..37b7454201efe1c2bf15f59a8f96503b36270cd8 100644
--- a/src/main/java/io/papermc/paper/chunk/SingleThreadChunkRegionManager.java
+++ b/src/main/java/io/papermc/paper/chunk/SingleThreadChunkRegionManager.java
@@ -1,19 +1,16 @@
 package io.papermc.paper.chunk;
 
-import io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet;
+import dev.twelveoclock.fastutil.set.impl.ConcurrentObjectOpenHashSet;
+import io.papermc.paper.util.MCUtil;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ReferenceLinkedOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
-import io.papermc.paper.util.MCUtil;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.level.ChunkPos;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.List;
+import java.util.*;
 import java.util.function.Supplier;
 
 public final class SingleThreadChunkRegionManager {
@@ -215,27 +212,28 @@ public final class SingleThreadChunkRegionManager {
         region.dead = true;
 
         // destroy region state
-        for (final Iterator<RegionSection> iterator = region.sections.unsafeIterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
+        for (final Iterator<RegionSection> iterator = region.sections.iterator(); iterator.hasNext(); ) {
             final RegionSection aliveSection = iterator.next();
             if (!aliveSection.hasChunks()) {
                 throw new IllegalStateException("Alive section '" + aliveSection.toStringWithRegion() + "' has no chunks!");
             }
             if (!this.regionsBySection.remove(aliveSection.regionCoordinate, aliveSection)) {
                 throw new IllegalStateException("Cannot remove alive section '" +
-                        aliveSection.toStringWithRegion() + "' from section state! State at section coordinate: " +
-                        this.regionsBySection.get(aliveSection.regionCoordinate));
+                    aliveSection.toStringWithRegion() + "' from section state! State at section coordinate: " +
+                    this.regionsBySection.get(aliveSection.regionCoordinate));
             }
         }
 
         // rebuild regions
-        for (final Iterator<RegionSection> iterator = region.sections.unsafeIterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
+        for (final Iterator<RegionSection> iterator = region.sections.iterator(); iterator.hasNext(); ) {
             final RegionSection aliveSection = iterator.next();
             this.getOrCreateAndMergeSection(aliveSection.getSectionX(), aliveSection.getSectionZ(), aliveSection);
         }
     }
 
     public static final class Region {
-        protected final IteratorSafeOrderedReferenceSet<RegionSection> sections = new IteratorSafeOrderedReferenceSet<>();
+        // TODO: Move to my own concurrent version, be sure to look at git history for this file
+        protected final Set<RegionSection> sections = new ConcurrentObjectOpenHashSet<>();
         protected final ReferenceOpenHashSet<RegionSection> deadSections = new ReferenceOpenHashSet<>(16, 0.7f);
         protected boolean dead;
         protected boolean markedForRecalc;
@@ -248,12 +246,12 @@ public final class SingleThreadChunkRegionManager {
             this.regionData = regionManager.regionDataSupplier.get();
         }
 
-        public IteratorSafeOrderedReferenceSet.@NotNull Iterator<RegionSection> getSections() {
-            return this.sections.iterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS);
+        public @NotNull Iterator<RegionSection> getSections() {
+            return this.sections.iterator();
         }
 
         protected final double getDeadSectionPercent() {
-            return (double)this.deadSections.size() / (double)this.sections.size();
+            return (double) this.deadSections.size() / (double) this.sections.size();
         }
 
         /*
@@ -310,7 +308,7 @@ public final class SingleThreadChunkRegionManager {
                 this.regionManager.removeFromRecalcQueue(this);
             }
 
-            for (final Iterator<RegionSection> iterator = this.sections.unsafeIterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
+            for (final Iterator<RegionSection> iterator = this.sections.iterator(); iterator.hasNext(); ) {
                 final RegionSection section = iterator.next();
 
                 if (!mergeTarget.addRegionSection(section)) {
@@ -353,7 +351,7 @@ public final class SingleThreadChunkRegionManager {
 
             ret.append("sectionCount=").append(this.sections.size()).append(',');
             ret.append("sections=[");
-            for (final Iterator<RegionSection> iterator = this.sections.unsafeIterator(IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS); iterator.hasNext();) {
+            for (final Iterator<RegionSection> iterator = this.sections.iterator(); iterator.hasNext(); ) {
                 final RegionSection section = iterator.next();
                 ret.append(section);
                 if (iterator.hasNext()) {
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 4f66638d4f392980e2ba7e82313a2341ff61e321..9d3b4de2f43bb081d343509ef77c64d90f344d5f 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -4,6 +4,7 @@ import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.Lists;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
+import dev.twelveoclock.fastutil.set.impl.ConcurrentObjectOpenHashSet;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -270,8 +271,8 @@ public class ServerChunkCache extends ChunkSource {
         this.distanceManager.removeTicket(ticketType, chunkPos, ticketLevel, identifier);
     }
 
-    public final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<LevelChunk> tickingChunks = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(4096, 0.75f, 4096, 0.15, true);
-    public final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<LevelChunk> entityTickingChunks = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(4096, 0.75f, 4096, 0.15, true);
+    public final ConcurrentObjectOpenHashSet<LevelChunk> tickingChunks = new ConcurrentObjectOpenHashSet<>();
+    public final ConcurrentObjectOpenHashSet<LevelChunk> entityTickingChunks = new ConcurrentObjectOpenHashSet<>();
     // Paper end
 
     public ServerChunkCache(final ServerLevel world, final LevelStorageSource.LevelStorageAccess session, final DataFixer dataFixer, final StructureTemplateManager structureTemplateManager, final Executor workerExecutor, final ChunkGenerator chunkGenerator, final int viewDistance, final int simulationDistance, final boolean dsync, final ChunkProgressListener worldGenerationProgressListener, final ChunkStatusUpdateListener chunkStatusChangeListener, final Supplier<DimensionDataStorage> persistentStateManagerFactory) {
@@ -689,7 +690,7 @@ public class ServerChunkCache extends ChunkSource {
             if (this.level.paperConfig().entities.spawning.perPlayerMobSpawns) {
                 iterator1 = this.entityTickingChunks.iterator();
             } else {
-                iterator1 = this.entityTickingChunks.unsafeIterator();
+                iterator1 = this.entityTickingChunks.iterator();
                 final List<LevelChunk> shuffled = Lists.newArrayListWithCapacity(this.entityTickingChunks.size());
                 while (iterator1.hasNext()) {
                     shuffled.add(iterator1.next());
@@ -699,7 +700,6 @@ public class ServerChunkCache extends ChunkSource {
             }
 
             int chunksTicked = 0; // Paper
-            try {
             while (iterator1.hasNext()) {
                 final LevelChunk chunk1 = iterator1.next();
                 final ChunkHolder holder = chunk1.playerChunk;
@@ -722,12 +722,6 @@ public class ServerChunkCache extends ChunkSource {
                 // Paper start - optimise chunk tick iteration
                 }
             }
-
-            } finally {
-                if (iterator1 instanceof io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.Iterator safeIterator) {
-                    safeIterator.finishedIterating();
-                }
-            }
             // Paper end - optimise chunk tick iteration
             gameprofilerfiller.popPush("customSpawners");
             if (flag2) {
