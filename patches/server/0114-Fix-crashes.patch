From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: camdenorrb <me@12oclock.dev>
Date: Thu, 17 Nov 2022 19:56:50 -0600
Subject: [PATCH] Fix crashes


diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
index 9ecdaf6c3ef37f300ffc62cf44884ac1a5352b29..12db2ecb0a4023d53b22f62457975ada81ee1849 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
@@ -1186,7 +1186,9 @@ public final class NewChunkHolder {
         for (long curr = (long)CHUNK_STATUS_HANDLE.getVolatile((NewChunkHolder)this);;) {
             final ChunkHolder.FullChunkStatus currPending = getPendingChunkStatus(curr);
             if (loaded && currPending != ChunkHolder.FullChunkStatus.INACCESSIBLE) {
-                throw new IllegalStateException("Expected " + ChunkHolder.FullChunkStatus.INACCESSIBLE + " for pending, but got " + currPending);
+                System.err.println("Tried to queue border status for chunk " + this + " but it already has a pending status of " + currPending);
+                return false;
+                //throw new IllegalStateException("Expected " + ChunkHolder.FullChunkStatus.INACCESSIBLE + " for pending, but got " + currPending);
             }
 
             final long update = (curr & ~PENDING_STATUS_MASK) | ((long)toStatus.ordinal() << 32);
diff --git a/src/main/java/io/papermc/paper/command/SpawnAllMobsCommand.java b/src/main/java/io/papermc/paper/command/SpawnAllMobsCommand.java
index bd75e67637d69ca0949d5fab6349d76a2621d303..1efa5d89549ed07cedb58ec292b78b52ce69c649 100644
--- a/src/main/java/io/papermc/paper/command/SpawnAllMobsCommand.java
+++ b/src/main/java/io/papermc/paper/command/SpawnAllMobsCommand.java
@@ -4,6 +4,8 @@ import org.bukkit.Bukkit;
 import org.bukkit.Location;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandSender;
+import org.bukkit.entity.EntityType;
+import org.bukkit.entity.Hanging;
 import org.bukkit.entity.Player;
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.framework.qual.DefaultQualifier;
@@ -48,6 +50,9 @@ public final class SpawnAllMobsCommand extends Command {
 		// Spawn all mobs at player's location
 		for (final org.bukkit.entity.EntityType type : org.bukkit.entity.EntityType.values()) {
 			if (type.isSpawnable()) {
+				if (type == EntityType.PAINTING) {
+					continue;
+				}
 				location.getWorld().spawnEntity(location, type);
 			}
 		}
diff --git a/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java b/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
index 81f7fdc2c01939512fdcaffccef67d77ae7cc37c..5227d0cee16d7c812ac34cc41fbbc53118376590 100644
--- a/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
+++ b/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
@@ -384,15 +384,19 @@ public abstract class PathNavigation {
     }
 
     protected void trimPath() {
-        if (this.path != null) {
-            for(int i = 0; i < this.path.getNodeCount(); ++i) {
-                Node node = this.path.getNode(i);
-                Node node2 = i + 1 < this.path.getNodeCount() ? this.path.getNode(i + 1) : null;
-                BlockState blockState = this.level.getBlockState(new BlockPos(node.x, node.y, node.z));
+
+        final Level level = this.level;
+        final Path path = this.path;
+
+        if (level != null && path != null) {
+            for(int i = 0; i < path.getNodeCount(); ++i) {
+                Node node = path.getNode(i);
+                Node node2 = i + 1 < path.getNodeCount() ? path.getNode(i + 1) : null;
+                BlockState blockState = level.getBlockState(new BlockPos(node.x, node.y, node.z));
                 if (blockState.is(BlockTags.CAULDRONS)) {
-                    this.path.replaceNode(i, node.cloneAndMove(node.x, node.y + 1, node.z));
+                    path.replaceNode(i, node.cloneAndMove(node.x, node.y + 1, node.z));
                     if (node2 != null && node.y >= node2.y) {
-                        this.path.replaceNode(i + 1, node.cloneAndMove(node2.x, node.y + 1, node2.z));
+                        path.replaceNode(i + 1, node.cloneAndMove(node2.x, node.y + 1, node2.z));
                     }
                 }
             }
@@ -428,14 +432,19 @@ public abstract class PathNavigation {
 
     public boolean shouldRecomputePath(BlockPos pos) {
 
+        final Mob mob = this.mob;
         final Path path = this.path;
 
+        if (mob == null || path == null) {
+            return false;
+        }
+
         if (this.hasDelayedRecomputation) {
             return false;
         } else if (path != null && !this.path.isDone() && this.path.getNodeCount() != 0) {
             Node node = path.getEndNode();
-            Vec3 vec3 = new Vec3(((double)node.x + this.mob.getX()) / 2.0D, ((double)node.y + this.mob.getY()) / 2.0D, ((double)node.z + this.mob.getZ()) / 2.0D);
-            return pos.closerToCenterThan(vec3, this.path.getNodeCount() - this.path.getNextNodeIndex());
+            Vec3 vec3 = new Vec3(((double)node.x + mob.getX()) / 2.0D, ((double)node.y + mob.getY()) / 2.0D, ((double)node.z + mob.getZ()) / 2.0D);
+            return pos.closerToCenterThan(vec3, path.getNodeCount() - path.getNextNodeIndex());
         } else {
             return false;
         }
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java b/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
index e06b4955e813e5d4d42993b2950ff6dae2dd578e..6930dbd215dc23449e143a56468077a375f801a7 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
@@ -13,6 +13,7 @@ import net.minecraft.tags.FluidTags;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Mob;
 import net.minecraft.world.level.BlockGetter;
+import net.minecraft.world.level.Level;
 import net.minecraft.world.level.PathNavigationRegion;
 import net.minecraft.world.level.block.BaseRailBlock;
 import net.minecraft.world.level.block.Block;
@@ -43,7 +44,13 @@ public class WalkNodeEvaluator extends NodeEvaluator {
 
     @Override
     public void done() {
-        this.mob.setPathfindingMalus(BlockPathTypes.WATER, this.oldWaterCost);
+
+        final Mob mob = this.mob;
+        if (mob == null) {
+            return;
+        }
+
+        mob.setPathfindingMalus(BlockPathTypes.WATER, this.oldWaterCost);
         this.pathTypesByPosCache.clear();
         this.collisionCache.clear();
         super.done();
@@ -53,9 +60,10 @@ public class WalkNodeEvaluator extends NodeEvaluator {
     @Override
     public @org.jetbrains.annotations.Nullable Node getStart() {
 
+        final PathNavigationRegion level = this.level;
         final Mob mob = this.mob;
 
-        if (mob == null) {
+        if (level == null || mob == null) {
             return null;
         }
 
@@ -256,6 +264,10 @@ public class WalkNodeEvaluator extends NodeEvaluator {
             }
 
             BlockPathTypes blockPathTypes = this.getCachedBlockType(mob, x, y, z);
+            if (blockPathTypes == null) {
+                return null;
+            }
+
             float f = mob.getPathfindingMalus(blockPathTypes);
             double e = (double)mob.getBbWidth() / 2.0D;
             if (f >= 0.0F) {
@@ -287,10 +299,14 @@ public class WalkNodeEvaluator extends NodeEvaluator {
                     while(y > mob.level.getMinBuildHeight()) {
                         --y;
                         blockPathTypes = this.getCachedBlockType(mob, x, y, z);
+                        if (blockPathTypes == null) {
+                            return null;
+                        }
                         if (blockPathTypes != BlockPathTypes.WATER) {
                             return node;
                         }
 
+
                         node = this.getNodeAndUpdateCostToMax(x, y, z, blockPathTypes, mob.getPathfindingMalus(blockPathTypes));
                     }
                 }
