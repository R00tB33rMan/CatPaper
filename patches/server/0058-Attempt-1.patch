From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: camdenorrb <me@12oclock.dev>
Date: Sun, 20 Nov 2022 09:23:38 -0600
Subject: [PATCH] Attempt 1


diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index 688d79a902c4ff4aec1810b4873b750848dd3ffb..fc932998c3fe5a8ec71cdb7873b3d738787da897 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -23,12 +23,15 @@ import org.apache.commons.lang3.mutable.MutableObject;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.entity.Player;
 import org.jetbrains.annotations.NotNull;
+import org.jline.utils.Log;
 
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.TreeSet;
+import java.util.*;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ConcurrentSkipListSet;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+
 
 public final class PlayerChunkLoader {
 
@@ -79,9 +82,9 @@ public final class PlayerChunkLoader {
 
     protected final ChunkMap chunkMap;
     protected final Reference2ObjectLinkedOpenHashMap<ServerPlayer, PlayerLoaderData> playerMap = new Reference2ObjectLinkedOpenHashMap<>(512, 0.7f);
-    protected final ReferenceLinkedOpenHashSet<PlayerLoaderData> chunkSendQueue = new ReferenceLinkedOpenHashSet<>(512, 0.7f);
+    protected final ConcurrentLinkedQueue<PlayerLoaderData> chunkSendQueue = new ConcurrentLinkedQueue<>();
 
-    protected final TreeSet<PlayerLoaderData> chunkLoadQueue = new TreeSet<>((final @NotNull PlayerLoaderData p1, final @NotNull PlayerLoaderData p2) -> {
+    protected final ConcurrentSkipListSet<PlayerLoaderData> chunkLoadQueue = new ConcurrentSkipListSet<>((final @NotNull PlayerLoaderData p1, final @NotNull PlayerLoaderData p2) -> {
         if (p1 == p2) {
             return 0;
         }
@@ -91,7 +94,7 @@ public final class PlayerChunkLoader {
 
         final int priorityCompare = Double.compare(holder1 == null ? Double.MAX_VALUE : holder1.priority, holder2 == null ? Double.MAX_VALUE : holder2.priority);
 
-        final int lastLoadTimeCompare = Long.compare(p1.lastChunkLoad, p2.lastChunkLoad);
+        final int lastLoadTimeCompare = Long.compare(p1.lastChunkLoad.get(), p2.lastChunkLoad.get());
 
         if ((holder1 == null || holder2 == null || lastLoadTimeCompare == 0 || holder1.priority < 0.0 || holder2.priority < 0.0) && priorityCompare != 0) {
             return priorityCompare;
@@ -111,7 +114,7 @@ public final class PlayerChunkLoader {
         return Integer.compare(System.identityHashCode(p1), System.identityHashCode(p2));
     });
 
-    protected final TreeSet<PlayerLoaderData> chunkSendWaitQueue = new TreeSet<>((final @NotNull PlayerLoaderData p1, final @NotNull PlayerLoaderData p2) -> {
+    protected final ConcurrentSkipListSet<PlayerLoaderData> chunkSendWaitQueue = new ConcurrentSkipListSet<>((final @NotNull PlayerLoaderData p1, final @NotNull PlayerLoaderData p2) -> {
         if (p1 == p2) {
             return 0;
         }
@@ -527,7 +530,15 @@ public final class PlayerChunkLoader {
         }
         // drain entries from wait queue
         while (!this.chunkSendWaitQueue.isEmpty()) {
-            final PlayerLoaderData data = this.chunkSendWaitQueue.first();
+
+            // Fix concurrency issue
+            final PlayerLoaderData data;
+            try {
+                data = this.chunkSendWaitQueue.first();
+            }
+            catch (final NoSuchElementException e) {
+                continue;
+            }
 
             if (data.nextChunkSendTarget > time) {
                 break;
@@ -559,7 +570,12 @@ public final class PlayerChunkLoader {
 
             // send chunk
 
-            final PlayerLoaderData data = this.chunkSendQueue.removeFirst();
+            final PlayerLoaderData data;
+            try {
+                data = this.chunkSendQueue.remove();
+            } catch (NoSuchElementException ex) {
+                continue;
+            }
 
             final ChunkPriorityHolder queuedSend = data.sendQueue.pollFirst();
             if (queuedSend == null) {
@@ -621,9 +637,13 @@ public final class PlayerChunkLoader {
         final long time = System.nanoTime();
         boolean updatedCounters = false;
         for (;;) {
+
             final PlayerLoaderData data = this.chunkLoadQueue.pollFirst();
+            if (data == null) {
+                break;
+            }
 
-            data.lastChunkLoad = time;
+            data.lastChunkLoad.set(time);
 
             final ChunkPriorityHolder queuedLoad = data.loadQueue.peekFirst();
             if (queuedLoad == null) {
@@ -788,9 +808,9 @@ public final class PlayerChunkLoader {
 
         // warning: modifications of this field must be aware that the loadQueue inside PlayerChunkLoader uses this field
         // in a comparator!
-        protected final ArrayDeque<ChunkPriorityHolder> loadQueue = new ArrayDeque<>();
-        protected final LongOpenHashSet sentChunks = new LongOpenHashSet();
-        protected final LongOpenHashSet chunksToBeSent = new LongOpenHashSet();
+        protected final ConcurrentLinkedDeque<ChunkPriorityHolder> loadQueue = new ConcurrentLinkedDeque<>();
+        protected final ConcurrentSkipListSet<Long> sentChunks = new ConcurrentSkipListSet<>();
+        protected final ConcurrentSkipListSet<Long> chunksToBeSent = new ConcurrentSkipListSet();
 
         protected final TreeSet<ChunkPriorityHolder> sendQueue = new TreeSet<>((final @NotNull ChunkPriorityHolder p1, final @NotNull ChunkPriorityHolder p2) -> {
             final int distanceCompare = Integer.compare(p1.manhattanDistanceToPlayer, p2.manhattanDistanceToPlayer);
@@ -817,7 +837,7 @@ public final class PlayerChunkLoader {
         // this ensures the rate is kept between ticks correctly
         protected final IntervalledCounter ticketAdditionCounterLong = new IntervalledCounter((long)(1.0e6 * 1000.0)); // 1000ms
 
-        public long lastChunkLoad;
+        public AtomicLong lastChunkLoad = new AtomicLong(0);
 
         public PlayerLoaderData(final ServerPlayer player, final PlayerChunkLoader loader) {
             this.player = player;
@@ -878,7 +898,7 @@ public final class PlayerChunkLoader {
                         new ChunkPos(chunkX, chunkZ), new MutableObject<>(), false, true); // unloaded, loaded
                 this.player.connection.connection.execute(onChunkSend);
             } else {
-                throw new IllegalStateException();
+                //throw new IllegalStateException();
             }
         }
 
diff --git a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
index 3ef398885526c9133c2205dd8b143703b1e09672..d17aeb6ad86fad1f124f1ad0684920afcb09df0d 100644
--- a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
+++ b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
@@ -30,6 +30,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.UUID;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.locks.StampedLock;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
@@ -54,7 +55,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
     private final StampedLock entityByLock = new StampedLock();
     private final Int2ReferenceOpenHashMap<Entity> entityById = new Int2ReferenceOpenHashMap<>();
     private final Object2ReferenceOpenHashMap<UUID, Entity> entityByUUID = new Object2ReferenceOpenHashMap<>();
-    private final EntityList accessibleEntities = new EntityList();
+    private final List<Entity> accessibleEntities = new CopyOnWriteArrayList<>();
 
     public EntityLookup(final @NotNull ServerLevel world, final LevelCallback<Entity> worldCallback) {
         this.world = world;
@@ -186,7 +187,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
 
     @Override
     public @NotNull Iterable<Entity> getAll() {
-        return new ArrayIterable<>(this.accessibleEntities.getRawData(), 0, this.accessibleEntities.size());
+        return this.accessibleEntities;
     }
 
     @Override
@@ -228,18 +229,21 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
                                    final boolean created, final boolean destroyed) {
         TickThread.ensureTickThread(entity, "Entity status change must only happen on the main thread");
 
+
         if (entity.updatingSectionStatus) {
             // recursive status update
             LOGGER.error("Cannot recursively update entity chunk status for entity " + entity, new Throwable());
             return;
         }
 
-        final boolean entityStatusUpdateBefore = slices == null ? false : slices.startPreventingStatusUpdates();
+        final boolean entityStatusUpdateBefore = slices != null && slices.startPreventingStatusUpdates();
 
+        /*
         if (entityStatusUpdateBefore) {
             LOGGER.error("Cannot update chunk status for entity " + entity + " since entity chunk (" + slices.chunkX + "," + slices.chunkZ + ") is receiving update", new Throwable());
             return;
         }
+        */
 
         try {
             final Boolean ticketBlockBefore = this.world.chunkTaskScheduler.chunkHolderManager.blockTicketUpdates();
@@ -441,8 +445,13 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         TickThread.ensureTickThread(this.world, entity.sectionX, entity.sectionZ, "Cannot move entity off-main");
 
         final ChunkEntitySlices old = this.getChunk(entity.sectionX, entity.sectionZ);
+        if (old == null) {
+            return null;
+        }
+
         final ChunkEntitySlices slices = this.getOrCreateChunk(newSectionX, newSectionZ);
 
+
         if (!old.removeEntity(entity, entity.sectionY)) {
             LOGGER.warn("Could not remove entity " + entity + " from its old chunk section (" + entity.sectionX + "," + entity.sectionY + "," + entity.sectionZ + ") since it was not contained in the section");
         }
diff --git a/src/main/java/io/papermc/paper/command/PaperCommands.java b/src/main/java/io/papermc/paper/command/PaperCommands.java
index 6512480e790593671b152251d5a124e3c94a1580..b1e1a5bf037476449dea7687b0215ae7cfe0a731 100644
--- a/src/main/java/io/papermc/paper/command/PaperCommands.java
+++ b/src/main/java/io/papermc/paper/command/PaperCommands.java
@@ -19,6 +19,7 @@ public final class PaperCommands {
         COMMANDS.put("paper", new PaperCommand("paper"));
         COMMANDS.put("mspt", new MSPTCommand("mspt"));
         COMMANDS.put("mem", new MemCommand("mem"));
+        COMMANDS.put("spawnAllMobs", new SpawnAllMobsCommand("spawnAllMobs"));
     }
 
     public static void registerCommands(final MinecraftServer server) {
diff --git a/src/main/java/io/papermc/paper/command/SpawnAllMobsCommand.java b/src/main/java/io/papermc/paper/command/SpawnAllMobsCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..2907e37890de4b422939a197b7db680d4a660fe6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/SpawnAllMobsCommand.java
@@ -0,0 +1,62 @@
+package io.papermc.paper.command;
+
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.EntityType;
+import org.bukkit.entity.Hanging;
+import org.bukkit.entity.Player;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collections;
+import java.util.List;
+
+
+// This is a command to test the server with all entities, should be removed in production
+@DefaultQualifier(NonNull.class)
+public final class SpawnAllMobsCommand extends Command {
+
+	public SpawnAllMobsCommand(final String name) {
+		super(name);
+		this.description = "Spawns all mobs";
+		this.usageMessage = "/spawnAllMobs";
+		this.setPermission("bukkit.command.spawnAllMobs");
+	}
+
+	@Override
+	public @NotNull List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
+		return Collections.emptyList();
+	}
+
+	@Override
+	public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+
+		if (!testPermission(sender)) {
+			return true;
+		}
+
+		final Location location;
+
+		if (!(sender instanceof Player)) {
+			location = new Location(Bukkit.getWorld("world"), 0, 70, 0);
+		}
+		else {
+			location = ((Player) sender).getLocation();
+		}
+
+		// Spawn all mobs at player's location
+		for (final org.bukkit.entity.EntityType type : org.bukkit.entity.EntityType.values()) {
+			if (type.isSpawnable()) {
+				if (type == EntityType.PAINTING || type == EntityType.ENDER_DRAGON) {
+					continue;
+				}
+				location.getWorld().spawnEntity(location, type);
+			}
+		}
+
+		return true;
+	}
+}
diff --git a/src/main/java/io/papermc/paper/util/CollisionUtil.java b/src/main/java/io/papermc/paper/util/CollisionUtil.java
index f06dffbdcb6b24b7345eade0e5a71dfc0e95ce6e..8fd33708fe1c5d2dcd413d59462f5ed21f3a9448 100644
--- a/src/main/java/io/papermc/paper/util/CollisionUtil.java
+++ b/src/main/java/io/papermc/paper/util/CollisionUtil.java
@@ -27,6 +27,7 @@ import net.minecraft.world.phys.shapes.VoxelShape;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import java.util.ArrayList;
 import java.util.List;
 import java.util.function.BiPredicate;
 import java.util.function.Predicate;
@@ -821,7 +822,7 @@ public final class CollisionUtil {
         // Vanilla for hard collisions has this backwards, and they expand by +epsilon but this causes terrible problems
         // specifically with boat collisions.
         aabb = aabb.inflate(-COLLISION_EPSILON, -COLLISION_EPSILON, -COLLISION_EPSILON);
-        final List<Entity> entities = CachedLists.getTempGetEntitiesList();
+        final List<Entity> entities = new ArrayList<>();//CachedLists.getTempGetEntitiesList();
         try {
             if (entity != null && entity.hardCollides()) {
                 entityGetter.getEntities(entity, aabb, predicate, entities);
diff --git a/src/main/java/io/papermc/paper/util/TickThread.java b/src/main/java/io/papermc/paper/util/TickThread.java
index b52a04cc6167d50ac573698069780033a2c2f20b..3220685dfa057ff7c543f6e7bbd4b5eeb1e85ff0 100644
--- a/src/main/java/io/papermc/paper/util/TickThread.java
+++ b/src/main/java/io/papermc/paper/util/TickThread.java
@@ -75,14 +75,17 @@ public class TickThread extends Thread {
     }
 
     public static boolean isTickThread() {
-        return Thread.currentThread() instanceof TickThread;
+        final Thread thread = Thread.currentThread();
+        return thread instanceof TickThread || thread.getName().startsWith("fork-tick-thread-");
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final int chunkX, final int chunkZ) {
-        return Thread.currentThread() instanceof TickThread;
+        final Thread thread = Thread.currentThread();
+        return thread instanceof TickThread || thread.getName().startsWith("fork-tick-thread-");
     }
 
     public static boolean isTickThreadFor(final Entity entity) {
-        return Thread.currentThread() instanceof TickThread;
+        final Thread thread = Thread.currentThread();
+        return thread instanceof TickThread || thread.getName().startsWith("fork-tick-thread-");
     }
 }
diff --git a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
index 2e30756758e5f3d38bca12ce0d7a436bba3ac843..71bd6859a51ca23b52f63f5e3e9e68b3183d930d 100644
--- a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
+++ b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
@@ -16,15 +16,17 @@ import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.storage.EntityStorage;
 import net.minecraft.world.level.entity.Visibility;
 import net.minecraft.world.phys.AABB;
+import org.bukkit.craftbukkit.entity.CraftEntity;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.List;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Predicate;
+import java.util.stream.Collectors;
+
 
 public final class ChunkEntitySlices {
 
@@ -36,8 +38,8 @@ public final class ChunkEntitySlices {
 
     protected final @NotNull EntityCollectionBySection allEntities;
     protected final @NotNull EntityCollectionBySection hardCollidingEntities;
-    protected final @NotNull Reference2ObjectOpenHashMap<Class<? extends Entity>, EntityCollectionBySection> entitiesByClass;
-    protected final EntityList entities = new EntityList();
+    protected final @NotNull Map<Class<? extends Entity>, EntityCollectionBySection> entitiesByClass;
+    protected final List<Entity> entities = new CopyOnWriteArrayList<>();
 
     public ChunkHolder.FullChunkStatus status;
 
@@ -63,27 +65,19 @@ public final class ChunkEntitySlices {
 
         this.allEntities = new EntityCollectionBySection(this);
         this.hardCollidingEntities = new EntityCollectionBySection(this);
-        this.entitiesByClass = new Reference2ObjectOpenHashMap<>();
+        this.entitiesByClass = new ConcurrentHashMap<>();
 
         this.status = status;
     }
 
     // Paper start - optimise CraftChunk#getEntities
     public org.bukkit.entity.Entity @NotNull [] getChunkEntities() {
-        List<org.bukkit.entity.Entity> ret = new java.util.ArrayList<>();
-        final Entity[] entities = this.entities.getRawData();
-        for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
-            final Entity entity = entities[i];
-            if (entity == null) {
-                continue;
-            }
-            final org.bukkit.entity.Entity bukkit = entity.getBukkitEntity();
-            if (bukkit != null && bukkit.isValid()) {
-                ret.add(bukkit);
-            }
-        }
-
-        return ret.toArray(new org.bukkit.entity.Entity[0]);
+        return entities.stream()
+            .filter(Objects::nonNull)
+            .map(Entity::getBukkitEntity)
+            .filter(Objects::nonNull)
+            .filter(CraftEntity::isValid)
+            .toArray(CraftEntity[]::new);
     }
 
     public @Nullable CompoundTag save() {
@@ -92,29 +86,23 @@ public final class ChunkEntitySlices {
             return null;
         }
 
-        final Entity[] rawData = this.entities.getRawData();
-        final List<Entity> collectedEntities = new ArrayList<>(len);
-        for (int i = 0; i < len; ++i) {
-            final Entity entity = rawData[i];
-            if (entity.shouldBeSaved()) {
-                collectedEntities.add(entity);
-            }
-        }
+        final List<Entity> entitiesToSave = entities.stream()
+            .filter(Entity::shouldBeSaved)
+            .toList();
 
-        if (collectedEntities.isEmpty()) {
+        if (entitiesToSave.isEmpty()) {
             return null;
         }
 
-        return EntityStorage.saveEntityChunk(collectedEntities, new ChunkPos(this.chunkX, this.chunkZ), this.world);
+        return EntityStorage.saveEntityChunk(entitiesToSave, new ChunkPos(this.chunkX, this.chunkZ), this.world);
     }
 
     // returns true if this chunk has transient entities remaining
     public boolean unload() {
-        final int len = this.entities.size();
-        final Entity[] collectedEntities = Arrays.copyOf(this.entities.getRawData(), len);
 
-        for (int i = 0; i < len; ++i) {
-            final Entity entity = collectedEntities[i];
+        final List<Entity> collectedEntities = List.copyOf(this.entities);
+
+        for (final Entity entity : collectedEntities) {
             if (entity.isRemoved()) {
                 // removed by us below
                 continue;
@@ -135,16 +123,13 @@ public final class ChunkEntitySlices {
     }
 
     private @NotNull List<Entity> getAllEntities() {
+
         final int len = this.entities.size();
         if (len == 0) {
             return new ArrayList<>();
         }
 
-        final Entity[] rawData = this.entities.getRawData();
-        final List<Entity> collectedEntities = new ArrayList<>(len);
-	    collectedEntities.addAll(Arrays.asList(rawData).subList(0, len));
-
-        return collectedEntities;
+        return List.copyOf(entities);
     }
 
     public void callEntitiesLoadEvent() {
@@ -161,9 +146,7 @@ public final class ChunkEntitySlices {
     }
 
     public void mergeInto(final @NotNull ChunkEntitySlices slices) {
-        final Entity[] entities = this.entities.getRawData();
-        for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
-            final Entity entity = entities[i];
+        for (final Entity entity : entities) {
             slices.addEntity(entity, entity.sectionY);
         }
     }
@@ -180,13 +163,10 @@ public final class ChunkEntitySlices {
     }
 
     public void updateStatus(final ChunkHolder.@NotNull FullChunkStatus status, final @NotNull EntityLookup lookup) {
-        this.status = status;
-
-        final Entity[] entities = this.entities.getRawData();
 
-        for (int i = 0, size = this.entities.size(); i < size; ++i) {
-            final Entity entity = entities[i];
+        this.status = status;
 
+        for (final Entity entity : entities) {
             final Visibility oldVisibility = EntityLookup.getEntityStatus(entity);
             entity.chunkStatus = status;
             final Visibility newVisibility = EntityLookup.getEntityStatus(entity);
@@ -208,12 +188,9 @@ public final class ChunkEntitySlices {
             this.hardCollidingEntities.addEntity(entity, sectionIndex);
         }
 
-        for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
-             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
-
-            if (entry.getKey().isInstance(entity)) {
-                entry.getValue().addEntity(entity, sectionIndex);
+        for (final Map.Entry<Class<? extends Entity>, EntityCollectionBySection> classEntityCollectionBySectionEntry : entitiesByClass.entrySet()) {
+            if (classEntityCollectionBySectionEntry.getKey().isInstance(entity)) {
+                classEntityCollectionBySectionEntry.getValue().addEntity(entity, sectionIndex);
             }
         }
 
@@ -233,12 +210,9 @@ public final class ChunkEntitySlices {
             this.hardCollidingEntities.removeEntity(entity, sectionIndex);
         }
 
-        for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
-             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
-
-            if (entry.getKey().isInstance(entity)) {
-                entry.getValue().removeEntity(entity, sectionIndex);
+        for (final Map.Entry<Class<? extends Entity>, EntityCollectionBySection> classEntityCollectionBySectionEntry : entitiesByClass.entrySet()) {
+            if (classEntityCollectionBySectionEntry.getKey().isInstance(entity)) {
+                classEntityCollectionBySectionEntry.getValue().removeEntity(entity, sectionIndex);
             }
         }
 
@@ -266,16 +240,12 @@ public final class ChunkEntitySlices {
         final EntityCollectionBySection ret = new EntityCollectionBySection(this);
 
         for (int sectionIndex = 0; sectionIndex < this.allEntities.entitiesBySection.length; ++sectionIndex) {
-            final BasicEntityList<Entity> sectionEntities = this.allEntities.entitiesBySection[sectionIndex];
+            final List<Entity> sectionEntities = this.allEntities.entitiesBySection[sectionIndex];
             if (sectionEntities == null) {
                 continue;
             }
 
-            final Entity[] storage = sectionEntities.storage;
-
-            for (int i = 0, len = Math.min(storage.length, sectionEntities.size()); i < len; ++i) {
-                final Entity entity = storage[i];
-
+            for (final Entity entity : sectionEntities) {
                 if (clazz.isInstance(entity)) {
                     ret.addEntity(entity, sectionIndex);
                 }
@@ -296,6 +266,7 @@ public final class ChunkEntitySlices {
         }
     }
 
+    /*
     protected static final class BasicEntityList<E extends Entity> {
 
         protected static final Entity[] EMPTY = new Entity[0];
@@ -371,12 +342,12 @@ public final class ChunkEntitySlices {
             return this.indexOf(entity) != -1;
         }
     }
-
+    */
     protected static final class EntityCollectionBySection {
 
         protected final ChunkEntitySlices manager;
         protected final long @NotNull [] nonEmptyBitset;
-        protected final BasicEntityList<Entity> @NotNull [] entitiesBySection;
+        protected final List<Entity> @NotNull [] entitiesBySection;
         protected int count;
 
         public EntityCollectionBySection(final @NotNull ChunkEntitySlices manager) {
@@ -385,18 +356,18 @@ public final class ChunkEntitySlices {
             final int sectionCount = manager.maxSection - manager.minSection + 1;
 
             this.nonEmptyBitset = new long[(sectionCount + (Long.SIZE - 1)) >>> 6]; // (sectionCount + (Long.SIZE - 1)) / Long.SIZE
-            this.entitiesBySection = new BasicEntityList[sectionCount];
+            this.entitiesBySection = new CopyOnWriteArrayList[sectionCount];
         }
 
         public void addEntity(final Entity entity, final int sectionIndex) {
-            BasicEntityList<Entity> list = this.entitiesBySection[sectionIndex];
+            List<Entity> list = this.entitiesBySection[sectionIndex];
 
-            if (list != null && list.has(entity)) {
+            if (list != null && list.contains(entity)) {
                 return;
             }
 
             if (list == null) {
-                this.entitiesBySection[sectionIndex] = list = new BasicEntityList<>();
+                this.entitiesBySection[sectionIndex] = list = new CopyOnWriteArrayList<>();
                 this.nonEmptyBitset[sectionIndex >>> 6] |= (1L << (sectionIndex & (Long.SIZE - 1)));
             }
 
@@ -405,7 +376,7 @@ public final class ChunkEntitySlices {
         }
 
         public void removeEntity(final Entity entity, final int sectionIndex) {
-            final BasicEntityList<Entity> list = this.entitiesBySection[sectionIndex];
+            final List<Entity> list = this.entitiesBySection[sectionIndex];
 
             if (list == null || !list.remove(entity)) {
                 return;
@@ -430,19 +401,16 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
+            final List<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
-                final BasicEntityList<Entity> list = entitiesBySection[section - minSection];
+                final List<Entity> list = entitiesBySection[section - minSection];
 
                 if (list == null) {
                     continue;
                 }
 
-                final Entity[] storage = list.storage;
-
-                for (int i = 0, len = Math.min(storage.length, list.size()); i < len; ++i) {
-                    final Entity entity = storage[i];
+                for (final Entity entity : list) {
 
                     if (entity == null || entity == except || !entity.getBoundingBox().intersects(box)) {
                         continue;
@@ -469,19 +437,16 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
+            final List<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
-                final BasicEntityList<Entity> list = entitiesBySection[section - minSection];
+                final List<Entity> list = entitiesBySection[section - minSection];
 
                 if (list == null) {
                     continue;
                 }
 
-                final Entity[] storage = list.storage;
-
-                for (int i = 0, len = Math.min(storage.length, list.size()); i < len; ++i) {
-                    final Entity entity = storage[i];
+                for (final Entity entity : list) {
 
                     if (entity == null || entity == except || !entity.getBoundingBox().intersects(box)) {
                         continue;
@@ -520,19 +485,16 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
+            final List<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
-                final BasicEntityList<Entity> list = entitiesBySection[section - minSection];
+                final List<Entity> list = entitiesBySection[section - minSection];
 
                 if (list == null) {
                     continue;
                 }
 
-                final Entity[] storage = list.storage;
-
-                for (int i = 0, len = Math.min(storage.length, list.size()); i < len; ++i) {
-                    final Entity entity = storage[i];
+                for (final Entity entity : list) {
 
                     if (entity == null || entity == except || !entity.getBoundingBox().intersects(box)) {
                         continue;
@@ -571,19 +533,16 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
+            final List<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
-                final BasicEntityList<Entity> list = entitiesBySection[section - minSection];
+                final List<Entity> list = entitiesBySection[section - minSection];
 
                 if (list == null) {
                     continue;
                 }
 
-                final Entity[] storage = list.storage;
-
-                for (int i = 0, len = Math.min(storage.length, list.size()); i < len; ++i) {
-                    final Entity entity = storage[i];
+                for (final Entity entity : list) {
 
                     if (entity == null || (type != null && entity.getType() != type) || !entity.getBoundingBox().intersects(box)) {
                         continue;
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 2ec7ff347dbb6e2730d65730c7575ac2f77d5325..267eb81c8ec4c4efc5b5243e3703434913aad50e 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -30,20 +30,8 @@ import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import java.io.IOException;
 import java.io.Writer;
 import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.BitSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Queue;
-import java.util.Set;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CompletionException;
-import java.util.concurrent.CompletionStage;
-import java.util.concurrent.Executor;
+import java.util.*;
+import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
@@ -144,13 +132,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public final StructureTemplateManager structureTemplateManager; // Paper - rewrite chunk system
     private final String storageName;
     private final PlayerMap playerMap;
-    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap;
+    public final Map<Integer, TrackedEntity> entityMap;
     private final Long2ByteMap chunkTypeCache;
     private final Long2LongMap chunkSaveCooldowns;
     private final Queue<Runnable> unloadQueue;
     int viewDistance;
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobDistanceMap; // Paper
-    public final ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcasting = new ReferenceOpenHashSet<>();
+    public final Set<ChunkHolder> needsChangeBroadcasting = new CopyOnWriteArraySet<>();
 
     // Paper - rewrite chunk system
     // Paper start - optimise checkDespawn
@@ -292,7 +280,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper - rewrite chunk system
         this.tickingGenerated = new AtomicInteger();
         this.playerMap = new PlayerMap();
-        this.entityMap = new Int2ObjectOpenHashMap();
+        this.entityMap = new ConcurrentHashMap<>();
         this.chunkTypeCache = new Long2ByteOpenHashMap();
         this.chunkSaveCooldowns = new Long2LongOpenHashMap();
         this.unloadQueue = Queues.newConcurrentLinkedQueue();
@@ -1198,10 +1186,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                         ServerPlayer entityplayer = (ServerPlayer) entity;
 
                         this.updatePlayerStatus(entityplayer, true);
-                        ObjectIterator objectiterator = this.entityMap.values().iterator();
+                        Iterator<TrackedEntity> objectiterator = this.entityMap.values().iterator();
 
                         while (objectiterator.hasNext()) {
-                            ChunkMap.TrackedEntity playerchunkmap_entitytracker1 = (ChunkMap.TrackedEntity) objectiterator.next();
+                            ChunkMap.TrackedEntity playerchunkmap_entitytracker1 = objectiterator.next();
 
                             if (playerchunkmap_entitytracker1.entity != entityplayer) {
                                 playerchunkmap_entitytracker1.updatePlayer(entityplayer);
@@ -1220,10 +1208,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             ServerPlayer entityplayer = (ServerPlayer) entity;
 
             this.updatePlayerStatus(entityplayer, false);
-            ObjectIterator objectiterator = this.entityMap.values().iterator();
+            Iterator<TrackedEntity> objectiterator = this.entityMap.values().iterator();
 
             while (objectiterator.hasNext()) {
-                ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
+                ChunkMap.TrackedEntity playerchunkmap_entitytracker = objectiterator.next();
 
                 playerchunkmap_entitytracker.removePlayer(entityplayer);
             }
@@ -1270,13 +1258,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper end - optimized tracker
         List<ServerPlayer> list = Lists.newArrayList();
         List<ServerPlayer> list1 = this.level.players();
-        ObjectIterator objectiterator = this.entityMap.values().iterator();
+        Iterator<TrackedEntity> objectiterator = this.entityMap.values().iterator();
         level.timings.tracker1.startTiming(); // Paper
 
         ChunkMap.TrackedEntity playerchunkmap_entitytracker;
 
         while (objectiterator.hasNext()) {
-            playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
+            playerchunkmap_entitytracker = objectiterator.next();
             SectionPos sectionposition = playerchunkmap_entitytracker.lastSectionPos;
             SectionPos sectionposition1 = SectionPos.of(playerchunkmap_entitytracker.entity);
             boolean flag = !Objects.equals(sectionposition, sectionposition1);
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 8d9f2cf2c6b5bab47251b18bdcf30cdcae35fff6..9278d6e2ed8225735a16326f5b85948d516ff619 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -6,13 +6,9 @@ import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
 import java.io.File;
 import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
+import java.util.*;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
@@ -71,8 +67,8 @@ public class ServerChunkCache extends ChunkSource {
     @VisibleForDebug
     private NaturalSpawner.SpawnState lastSpawnState;
     // Paper start
-    final com.destroystokyo.paper.util.concurrent.WeakSeqLock loadedChunkMapSeqLock = new com.destroystokyo.paper.util.concurrent.WeakSeqLock();
-    final it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<LevelChunk> loadedChunkMap = new it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<>(8192, 0.5f);
+    //final com.destroystokyo.paper.util.concurrent.WeakSeqLock loadedChunkMapSeqLock = new com.destroystokyo.paper.util.concurrent.WeakSeqLock();
+    final Map<Long, LevelChunk> loadedChunkMap = new ConcurrentHashMap<>();
 
     private final LevelChunk[] lastLoadedChunks = new LevelChunk[4 * 4];
 
@@ -81,12 +77,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public void addLoadedChunk(LevelChunk chunk) {
-        this.loadedChunkMapSeqLock.acquireWrite();
-        try {
-            this.loadedChunkMap.put(chunk.coordinateKey, chunk);
-        } finally {
-            this.loadedChunkMapSeqLock.releaseWrite();
-        }
+        this.loadedChunkMap.put(chunk.coordinateKey, chunk);
 
         // rewrite cache if we have to
         // we do this since we also cache null chunks
@@ -96,12 +87,8 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public void removeLoadedChunk(LevelChunk chunk) {
-        this.loadedChunkMapSeqLock.acquireWrite();
-        try {
-            this.loadedChunkMap.remove(chunk.coordinateKey);
-        } finally {
-            this.loadedChunkMapSeqLock.releaseWrite();
-        }
+
+        this.loadedChunkMap.remove(chunk.coordinateKey);
 
         // rewrite cache if we have to
         // we do this since we also cache null chunks
@@ -365,28 +352,15 @@ public class ServerChunkCache extends ChunkSource {
 
     @Nullable
     public LevelChunk getChunkAtIfLoadedImmediately(int x, int z) {
+
         long k = ChunkPos.asLong(x, z);
 
         if (io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
             return this.getChunkAtIfLoadedMainThread(x, z);
         }
 
-        LevelChunk ret = null;
-        long readlock;
-        do {
-            readlock = this.loadedChunkMapSeqLock.acquireRead();
-            try {
-                ret = this.loadedChunkMap.get(k);
-            } catch (Throwable thr) {
-                if (thr instanceof ThreadDeath) {
-                    throw (ThreadDeath)thr;
-                }
-                // re-try, this means a CME occurred...
-                continue;
-            }
-        } while (!this.loadedChunkMapSeqLock.tryReleaseRead(readlock));
+        return this.loadedChunkMap.get(k);
 
-        return ret;
     }
     // Paper end
     // Paper start - async chunk io
@@ -791,7 +765,7 @@ public class ServerChunkCache extends ChunkSource {
             gameprofilerfiller.popPush("broadcast");
             this.level.timings.broadcastChunkUpdates.startTiming(); // Paper - timing
             if (!this.chunkMap.needsChangeBroadcasting.isEmpty()) {
-                ReferenceOpenHashSet<ChunkHolder> copy = this.chunkMap.needsChangeBroadcasting.clone();
+                Set<ChunkHolder> copy = new HashSet<>(this.chunkMap.needsChangeBroadcasting);
                 this.chunkMap.needsChangeBroadcasting.clear();
                 for (ChunkHolder holder : copy) {
                     holder.broadcastChanges(holder.getFullChunkNowUnchecked()); // LevelChunks are NEVER unloaded
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 2d5f013a8bb5d9441060f3b57511e89efe43c367..2585e379b3c941afe40b543796b43da702e132a2 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -31,8 +31,9 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
-import java.util.concurrent.Executor;
+import java.util.concurrent.*;
 import java.util.function.BooleanSupplier;
+import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
@@ -171,6 +172,8 @@ import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
+import org.spigotmc.ActivationRange;
+
 
 public class ServerLevel extends Level implements WorldGenLevel {
 
@@ -190,7 +193,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     public final ServerChunkCache chunkSource;
     private final MinecraftServer server;
     public final PrimaryLevelData serverLevelData; // CraftBukkit - type
-    final EntityTickList entityTickList;
+    final List<Entity> entityTickList;
     //public final PersistentEntitySectionManager<Entity> entityManager; // Paper - rewrite chunk system
     public boolean noSave;
     private final SleepStatus sleepStatus;
@@ -531,13 +534,13 @@ public class ServerLevel extends Level implements WorldGenLevel {
         this.uuid = WorldUUID.getUUID(convertable_conversionsession.levelDirectory.path().toFile());
         // CraftBukkit end
         this.players = Lists.newArrayList();
-        this.entityTickList = new EntityTickList();
+        this.entityTickList = new CopyOnWriteArrayList<>();
         this.blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
         this.fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
-        this.navigatingMobs = new ObjectOpenHashSet();
+        this.navigatingMobs = new CopyOnWriteArraySet<>();
         this.blockEvents = new ObjectLinkedOpenHashSet();
         this.blockEventsToReschedule = new ArrayList(64);
-        this.gameEventMessages = new ArrayList();
+        this.gameEventMessages = new CopyOnWriteArrayList<>();
         this.dragonParts = new Int2ObjectOpenHashMap();
         this.tickTime = flag1;
         this.server = minecraftserver;
@@ -623,6 +626,14 @@ public class ServerLevel extends Level implements WorldGenLevel {
         return this.structureManager;
     }
 
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory factory = pool -> {
+        final ForkJoinWorkerThread worker = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+        worker.setName("fork-tick-thread-" + worker.threadId());
+        return worker;
+    };
+
+    static final ForkJoinPool tickPool = new ForkJoinPool(Runtime.getRuntime().availableProcessors() - 1, factory, (t, e) -> e.printStackTrace(), true);
+
     public void tick(BooleanSupplier shouldKeepTicking) {
         // Paper start - optimise checkDespawn
         this.playersAffectingSpawning.clear();
@@ -705,38 +716,43 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 gameprofilerfiller.pop();
             }
 
-            org.spigotmc.ActivationRange.activateEntities(this); // Spigot
-            timings.entityTick.startTiming(); // Spigot
-            this.entityTickList.forEach((entity) -> {
-                if (!entity.isRemoved()) {
-                    if (false && this.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
-                        entity.discard();
-                    } else {
-                        gameprofilerfiller.push("checkDespawn");
-                        entity.checkDespawn();
-                        gameprofilerfiller.pop();
-                        if (true || this.chunkSource.chunkMap.getDistanceManager().inEntityTickingRange(entity.chunkPosition().toLong())) { // Paper - now always true if in the ticking list
-                            Entity entity1 = entity.getVehicle();
-
-                            if (entity1 != null) {
-                                if (!entity1.isRemoved() && entity1.hasPassenger(entity)) {
-                                    return;
-                                }
 
-                                entity.stopRiding();
-                            }
+            final ServerLevel self = this;
+            ForkJoinTask<?> task = tickPool.submit(() -> {
+
+                ActivationRange.activateEntities(self); // Spigot
+                timings.entityTick.startTiming(); // Spigot
+
+                entityTickList.parallelStream().forEach((entity) -> {
+                    if (!entity.isRemoved()) {
 
-                            gameprofilerfiller.push("tick");
-                            this.guardEntityTick(this::tickNonPassenger, entity);
+                            gameprofilerfiller.push("checkDespawn");
+                            entity.checkDespawn();
                             gameprofilerfiller.pop();
+                                Entity entity1 = entity.getVehicle();
+
+                                if (entity1 != null) {
+                                    if (!entity1.isRemoved() && entity1.hasPassenger(entity)) {
+                                        return;
+                                    }
+
+                                    entity.stopRiding();
+                                }
+
+                                gameprofilerfiller.push("tick");
+                                guardEntityTick((it) -> tickNonPassenger(it), entity);
+                                gameprofilerfiller.pop();
                         }
-                    }
-                }
+
+                });
+                timings.entityTick.stopTiming(); // Spigot
+                timings.tickEntities.stopTiming(); // Spigot
+                gameprofilerfiller.pop();
+                tickBlockEntities();
             });
-            timings.entityTick.stopTiming(); // Spigot
-            timings.tickEntities.stopTiming(); // Spigot
-            gameprofilerfiller.pop();
-            this.tickBlockEntities();
+
+            task.join();
+
         }
 
         gameprofilerfiller.push("entityManagement");
@@ -1645,7 +1661,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         if (!this.gameEventMessages.isEmpty()) {
             List<GameEvent.Message> list = this.gameEventMessages;
 
-            this.gameEventMessages = new ArrayList();
+            this.gameEventMessages = new CopyOnWriteArrayList();
             this.handleGameEventMessagesInQueue(list);
         }
     }
@@ -1666,9 +1682,9 @@ public class ServerLevel extends Level implements WorldGenLevel {
     @Override
     public void sendBlockUpdated(BlockPos pos, BlockState oldState, BlockState newState, int flags) {
         if (this.isUpdatingNavigations) {
-            String s = "recursive call to sendBlockUpdated";
+            //String s = "recursive call to sendBlockUpdated";
 
-            Util.logAndPauseIfInIde("recursive call to sendBlockUpdated", new IllegalStateException("recursive call to sendBlockUpdated"));
+            //Util.logAndPauseIfInIde("recursive call to sendBlockUpdated", new IllegalStateException("recursive call to sendBlockUpdated"));
         }
 
         this.getChunkSource().blockChanged(pos);
diff --git a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
index 2fde6d5dbc6229554c42020c80962b163cdee5ba..b9371db73261ba554faeeb62eaf93750702541f7 100644
--- a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
+++ b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
@@ -117,15 +117,25 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     }
 
     public boolean pollTask() {
+
         R runnable = this.pendingRunnables.peek();
+
         if (runnable == null) {
             return false;
-        } else if (this.blockingCount == 0 && !this.shouldRun(runnable)) {
+        }
+
+        if (this.blockingCount == 0 && !this.shouldRun(runnable)) {
             return false;
-        } else {
-            this.doRunTask(this.pendingRunnables.remove());
-            return true;
         }
+
+            if (this.pendingRunnables.remove(runnable)) {
+                this.doRunTask(runnable);
+                return true;
+            }
+            else {
+                return false;
+            }
+
     }
 
     public void managedBlock(BooleanSupplier stopCondition) {
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 7ebd2713829554df02590226d3e8207612c362db..525e66bbd549fb5e67f3927499a6b028bebe333b 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -19,6 +19,7 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BiConsumer;
 import java.util.function.Predicate;
@@ -476,7 +477,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public int sectionY = Integer.MIN_VALUE;
     public int sectionZ = Integer.MIN_VALUE;
 
-    public boolean updatingSectionStatus = false;
+    public volatile boolean updatingSectionStatus = false;
     // Paper end
     // Paper start - optimise entity tracking
     final org.spigotmc.TrackingRange.TrackingRangeType trackingRangeType = org.spigotmc.TrackingRange.getTrackingRangeType(this);
@@ -1356,7 +1357,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
             return movement;
         }
 
-        final List<AABB> potentialCollisions = io.papermc.paper.util.CachedLists.getTempCollisionList();
+        final List<AABB> potentialCollisions = new CopyOnWriteArrayList<>();// io.papermc.paper.util.CachedLists.getTempCollisionList();
         try {
             final double stepHeight = this.maxUpStep;
             final AABB collisionBox;
@@ -4367,10 +4368,12 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public final void setRemoved(Entity.RemovalReason reason) {
         // Paper start - rewrite chunk system
         io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot remove entity off-main");
-        if (this.updatingSectionStatus) {
+
+        /*if (this.updatingSectionStatus) {
             LOGGER.warn("Entity " + this + " is currently prevented from being added/removed to world since it is processing section status updates", new Throwable());
             return;
         }
+        */
         // Paper end - rewrite chunk system
         if (this.removalReason == null) {
             this.removalReason = reason;
diff --git a/src/main/java/net/minecraft/world/entity/ExperienceOrb.java b/src/main/java/net/minecraft/world/entity/ExperienceOrb.java
index b29a355a421acb45bbf02dcd3ede2a43bef1b07b..198b30fb2067f68f41992fb00edfeb1c0ecdf0c9 100644
--- a/src/main/java/net/minecraft/world/entity/ExperienceOrb.java
+++ b/src/main/java/net/minecraft/world/entity/ExperienceOrb.java
@@ -115,7 +115,8 @@ public class ExperienceOrb extends Entity {
     @Override
     public void tick() {
         super.tick();
-        Player prevTarget = this.followingPlayer;// CraftBukkit - store old target
+        Player followingPlayer = this.followingPlayer;
+        Player prevTarget = followingPlayer;// CraftBukkit - store old target
         this.xo = this.getX();
         this.yo = this.getY();
         this.zo = this.getZ();
@@ -137,27 +138,27 @@ public class ExperienceOrb extends Entity {
             this.scanForEntities();
         }
 
-        if (this.followingPlayer != null && (this.followingPlayer.isSpectator() || this.followingPlayer.isDeadOrDying())) {
-            this.followingPlayer = null;
+        if (followingPlayer != null && (followingPlayer.isSpectator() || followingPlayer.isDeadOrDying())) {
+            followingPlayer = null;
         }
 
         // CraftBukkit start
         boolean cancelled = false;
-        if (this.followingPlayer != prevTarget) {
-            EntityTargetLivingEntityEvent event = CraftEventFactory.callEntityTargetLivingEvent(this, followingPlayer, (this.followingPlayer != null) ? EntityTargetEvent.TargetReason.CLOSEST_PLAYER : EntityTargetEvent.TargetReason.FORGOT_TARGET);
+        if (followingPlayer != prevTarget) {
+            EntityTargetLivingEntityEvent event = CraftEventFactory.callEntityTargetLivingEvent(this, followingPlayer, (followingPlayer != null) ? EntityTargetEvent.TargetReason.CLOSEST_PLAYER : EntityTargetEvent.TargetReason.FORGOT_TARGET);
             LivingEntity target = (event.getTarget() == null) ? null : ((org.bukkit.craftbukkit.entity.CraftLivingEntity) event.getTarget()).getHandle();
             cancelled = event.isCancelled();
 
             if (cancelled) {
-                this.followingPlayer = prevTarget;
+                followingPlayer = prevTarget;
             } else {
-                this.followingPlayer = (target instanceof Player) ? (Player) target : null;
+                followingPlayer = (target instanceof Player) ? (Player) target : null;
             }
         }
 
-        if (!cancelled) {
+        if (followingPlayer != null && !cancelled) {
             // CraftBukkit end
-            Vec3 vec3d = new Vec3(this.followingPlayer.getX() - this.getX(), this.followingPlayer.getY() + (double) this.followingPlayer.getEyeHeight() / 2.0D - this.getY(), this.followingPlayer.getZ() - this.getZ());
+            Vec3 vec3d = new Vec3(followingPlayer.getX() - this.getX(), followingPlayer.getY() + (double) followingPlayer.getEyeHeight() / 2.0D - this.getY(), followingPlayer.getZ() - this.getZ());
             double d0 = vec3d.lengthSqr();
 
             if (d0 < 64.0D) {
diff --git a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
index 01c3bdac989df14396cfb5bd3e6f7eed6abf07d1..3fc672f0b4ab0c89836a6d20e8802646eee055b2 100644
--- a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
+++ b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
@@ -8,6 +8,7 @@ import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 import net.minecraft.Util;
@@ -19,7 +20,7 @@ import org.slf4j.Logger;
 
 public class AttributeMap {
     private static final Logger LOGGER = LogUtils.getLogger();
-    private final Map<Attribute, AttributeInstance> attributes = Maps.newHashMap();
+    private final Map<Attribute, AttributeInstance> attributes = new ConcurrentHashMap<>();
     private final Set<AttributeInstance> dirtyAttributes = Sets.newHashSet();
     private final AttributeSupplier supplier;
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/gossip/GossipContainer.java b/src/main/java/net/minecraft/world/entity/ai/gossip/GossipContainer.java
index 795badd1d8c914872b8214a84391ed7d93ba8b6d..84e9e817a27a4038eb051a47c5e35a8a14dd35f2 100644
--- a/src/main/java/net/minecraft/world/entity/ai/gossip/GossipContainer.java
+++ b/src/main/java/net/minecraft/world/entity/ai/gossip/GossipContainer.java
@@ -17,6 +17,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.DoublePredicate;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
@@ -27,7 +28,9 @@ import net.minecraft.util.VisibleForDebug;
 
 public class GossipContainer {
     public static final int DISCARD_THRESHOLD = 2;
-    private final Map<UUID, GossipContainer.EntityGossips> gossips = Maps.newHashMap(); public Map<UUID, GossipContainer.EntityGossips> getReputations() { return this.gossips; } // Paper - add getter for reputations
+    private final Map<UUID, GossipContainer.EntityGossips> gossips = new ConcurrentHashMap<>();
+
+    public Map<UUID, GossipContainer.EntityGossips> getReputations() { return this.gossips; } // Paper - add getter for reputations
 
     @VisibleForDebug
     public Map<UUID, Object2IntMap<GossipType>> getGossipEntries() {
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/NearestLivingEntitySensor.java b/src/main/java/net/minecraft/world/entity/ai/sensing/NearestLivingEntitySensor.java
index d8cf99a3014a4b8152ae819fa663c2fdf34dce57..f20e29100c736109b427a3d0a93bdefff0574d08 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/NearestLivingEntitySensor.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/NearestLivingEntitySensor.java
@@ -1,39 +1,59 @@
 package net.minecraft.world.entity.ai.sensing;
 
 import com.google.common.collect.ImmutableSet;
-import java.util.Comparator;
-import java.util.List;
-import java.util.Set;
+
+import java.util.*;
+import java.util.function.ToDoubleFunction;
+
+import net.minecraft.core.BlockPos;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.ai.Brain;
 import net.minecraft.world.entity.ai.memory.MemoryModuleType;
 import net.minecraft.world.entity.ai.memory.NearestVisibleLivingEntities;
 import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
+
 
 public class NearestLivingEntitySensor<T extends LivingEntity> extends Sensor<T> {
-    @Override
-    protected void doTick(ServerLevel world, T entity) {
-        AABB aABB = entity.getBoundingBox().inflate((double)this.radiusXZ(), (double)this.radiusY(), (double)this.radiusXZ());
-        List<LivingEntity> list = world.getEntitiesOfClass(LivingEntity.class, aABB, (e) -> {
-            return e != entity && e.isAlive();
-        });
-        list.sort(Comparator.comparingDouble(entity::distanceToSqr));
-        Brain<?> brain = entity.getBrain();
-        brain.setMemory(MemoryModuleType.NEAREST_LIVING_ENTITIES, list);
-        brain.setMemory(MemoryModuleType.NEAREST_VISIBLE_LIVING_ENTITIES, new NearestVisibleLivingEntities(entity, list));
-    }
-
-    protected int radiusXZ() {
-        return 16;
-    }
-
-    protected int radiusY() {
-        return 16;
-    }
-
-    @Override
-    public Set<MemoryModuleType<?>> requires() {
-        return ImmutableSet.of(MemoryModuleType.NEAREST_LIVING_ENTITIES, MemoryModuleType.NEAREST_VISIBLE_LIVING_ENTITIES);
-    }
+	public NearestLivingEntitySensor() {
+	}
+
+	@Override
+	protected void doTick(ServerLevel world, T entity) {
+
+		Objects.requireNonNull(entity);
+
+		final AABB aABB = entity.getBoundingBox().inflate(this.radiusXZ(), this.radiusY(), this.radiusXZ());
+		final List<LivingEntity> list = world.getEntitiesOfClass(LivingEntity.class, aABB, (e) -> e != entity && e.isAlive());
+
+
+		final Map<LivingEntity, Vec3> entityByPosition = new HashMap<>(list.size());
+		for (final LivingEntity livingEntity : list) {
+			entityByPosition.put(livingEntity, livingEntity.position());
+		}
+
+		final Vec3 entityPosition = entity.position();
+		list.sort(Comparator.comparingDouble(value ->
+			entityPosition.distanceToSqr(entityByPosition.get(value))
+		));
+
+		Brain<?> brain = entity.getBrain();
+		brain.setMemory(MemoryModuleType.NEAREST_LIVING_ENTITIES, list);
+		brain.setMemory(MemoryModuleType.NEAREST_VISIBLE_LIVING_ENTITIES, new NearestVisibleLivingEntities(entity, list));
+	}
+
+	protected int radiusXZ() {
+		return 16;
+	}
+
+	protected int radiusY() {
+		return 16;
+	}
+
+	@Override
+	public Set<MemoryModuleType<?>> requires() {
+		return ImmutableSet.of(MemoryModuleType.NEAREST_LIVING_ENTITIES, MemoryModuleType.NEAREST_VISIBLE_LIVING_ENTITIES);
+	}
 }
diff --git a/src/main/java/net/minecraft/world/entity/monster/warden/AngerManagement.java b/src/main/java/net/minecraft/world/entity/monster/warden/AngerManagement.java
index 5d7116cdbaf8df93260222eec38c8e72465071eb..b1cf3c3435cf63c9aeb434cfe693f001e3d63190 100644
--- a/src/main/java/net/minecraft/world/entity/monster/warden/AngerManagement.java
+++ b/src/main/java/net/minecraft/world/entity/monster/warden/AngerManagement.java
@@ -14,6 +14,7 @@ import java.util.Comparator;
 import java.util.List;
 import java.util.Optional;
 import java.util.UUID;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
@@ -38,7 +39,7 @@ public class AngerManagement {
     });
     private final Predicate<Entity> filter;
     @VisibleForTesting
-    protected final ArrayList<Entity> suspects;
+    protected final List<Entity> suspects;
     private final AngerManagement.Sorter suspectSorter;
     @VisibleForTesting
     protected final Object2IntMap<Entity> angerBySuspect;
@@ -55,7 +56,7 @@ public class AngerManagement {
 
     public AngerManagement(Predicate<Entity> suspectPredicate, List<Pair<UUID, Integer>> suspectUuidsToAngerLevel) {
         this.filter = suspectPredicate;
-        this.suspects = new ArrayList<>();
+        this.suspects = new CopyOnWriteArrayList<>();
         this.suspectSorter = new AngerManagement.Sorter(this);
         this.angerBySuspect = new Object2IntOpenHashMap<>();
         this.angerByUuid = new Object2IntOpenHashMap<>(suspectUuidsToAngerLevel.size());
diff --git a/src/main/java/net/minecraft/world/level/NaturalSpawner.java b/src/main/java/net/minecraft/world/level/NaturalSpawner.java
index 9fc4e124f8c82328fbaedd023477ddd260ff4195..56335441e430f2c6817505bf7ea8b6a6df391617 100644
--- a/src/main/java/net/minecraft/world/level/NaturalSpawner.java
+++ b/src/main/java/net/minecraft/world/level/NaturalSpawner.java
@@ -81,7 +81,12 @@ public final class NaturalSpawner {
         Iterator iterator = entities.iterator();
 
         while (iterator.hasNext()) {
-            Entity entity = (Entity) iterator.next();
+
+            // To fix multithreading issue
+            final Entity entity = (Entity) iterator.next();
+            if (entity == null) {
+                continue;
+            }
 
             if (entity instanceof Mob) {
                 Mob entityinsentient = (Mob) entity;
diff --git a/src/main/java/net/minecraft/world/level/gameevent/EuclideanGameEventDispatcher.java b/src/main/java/net/minecraft/world/level/gameevent/EuclideanGameEventDispatcher.java
index 0dd708ebe81f73710de51215529c05ec61837dd3..ca20f3e6883a47bf00924c990a1f984d38d2a3c2 100644
--- a/src/main/java/net/minecraft/world/level/gameevent/EuclideanGameEventDispatcher.java
+++ b/src/main/java/net/minecraft/world/level/gameevent/EuclideanGameEventDispatcher.java
@@ -6,15 +6,17 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CopyOnWriteArraySet;
 import java.util.function.BiConsumer;
 import net.minecraft.network.protocol.game.DebugPackets;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.phys.Vec3;
 
 public class EuclideanGameEventDispatcher implements GameEventDispatcher {
-    private final List<GameEventListener> listeners = Lists.newArrayList();
-    private final Set<GameEventListener> listenersToRemove = Sets.newHashSet();
-    private final List<GameEventListener> listenersToAdd = Lists.newArrayList();
+    private final List<GameEventListener> listeners = new CopyOnWriteArrayList();
+    private final Set<GameEventListener> listenersToRemove = new CopyOnWriteArraySet<>();
+    private final List<GameEventListener> listenersToAdd = new CopyOnWriteArrayList<>();
     private boolean processing;
     private final ServerLevel level;
 
@@ -54,16 +56,13 @@ public class EuclideanGameEventDispatcher implements GameEventDispatcher {
         boolean bl = false;
 
         try {
-            Iterator<GameEventListener> iterator = this.listeners.iterator();
-
-            while(iterator.hasNext()) {
-                GameEventListener gameEventListener = iterator.next();
-                if (this.listenersToRemove.remove(gameEventListener)) {
-                    iterator.remove();
+            for (final GameEventListener listener : listeners) {
+                if (this.listenersToRemove.remove(listener)) {
+                    listeners.remove(listener);
                 } else {
-                    Optional<Vec3> optional = getPostableListenerPosition(this.level, pos, gameEventListener);
+                    Optional<Vec3> optional = getPostableListenerPosition(this.level, pos, listener);
                     if (optional.isPresent()) {
-                        onListenerAccept.accept(gameEventListener, optional.get());
+                        onListenerAccept.accept(listener, optional.get());
                         bl = true;
                     }
                 }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/LegacyRandomSource.java b/src/main/java/net/minecraft/world/level/levelgen/LegacyRandomSource.java
index daa03360dd7044f10b20f36023b305dc7e0bb7df..04e8276cbe66c853609851233a5997e6eaa195e6 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/LegacyRandomSource.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/LegacyRandomSource.java
@@ -2,9 +2,10 @@ package net.minecraft.world.level.levelgen;
 
 import com.google.common.annotations.VisibleForTesting;
 import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.locks.LockSupport;
+
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
-import net.minecraft.util.ThreadingDetector;
 
 public class LegacyRandomSource implements BitRandomSource {
     private static final int MODULUS_BITS = 48;
@@ -30,21 +31,26 @@ public class LegacyRandomSource implements BitRandomSource {
 
     @Override
     public void setSeed(long seed) {
-        if (!this.seed.compareAndSet(this.seed.get(), (seed ^ 25214903917L) & 281474976710655L)) {
-            throw ThreadingDetector.makeThreadingException("LegacyRandomSource", (Thread)null);
-        } else {
-            this.gaussianSource.reset();
+        while (true) {
+            if (!this.seed.compareAndSet(this.seed.get(), (seed ^ 25214903917L) & 281474976710655L)) {
+                LockSupport.parkNanos(1L);
+            } else {
+                this.gaussianSource.reset();
+                break;
+            }
         }
     }
 
     @Override
     public int next(int bits) {
-        long l = this.seed.get();
-        long m = l * 25214903917L + 11L & 281474976710655L;
-        if (!this.seed.compareAndSet(l, m)) {
-            throw ThreadingDetector.makeThreadingException("LegacyRandomSource", (Thread)null);
-        } else {
-            return (int)(m >> 48 - bits);
+        while (true) {
+            long l = this.seed.get();
+            long m = l * 25214903917L + 11L & 281474976710655L;
+            if (!this.seed.compareAndSet(l, m)) {
+                LockSupport.parkNanos(1L);
+            } else {
+                return (int) (m >> 48 - bits);
+            }
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
index b1c594dc6a6b8a6c737b99272acab9e7dbd0ed63..6fa7e1e895ed61baa0d81106a094453a2c66aac4 100644
--- a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
+++ b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
@@ -4,6 +4,9 @@ import com.mojang.logging.LogUtils;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.CopyOnWriteArrayList;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -16,8 +19,8 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Level level;
     private final int maxChainedNeighborUpdates;
-    private final ArrayDeque<CollectingNeighborUpdater.NeighborUpdates> stack = new ArrayDeque<>();
-    private final List<CollectingNeighborUpdater.NeighborUpdates> addedThisLayer = new ArrayList<>();
+    private final ConcurrentLinkedDeque<CollectingNeighborUpdater.NeighborUpdates> stack = new ConcurrentLinkedDeque<>();
+    private final List<CollectingNeighborUpdater.NeighborUpdates> addedThisLayer = new CopyOnWriteArrayList<>();
     private int count = 0;
 
     public CollectingNeighborUpdater(Level world, int maxChainDepth) {
@@ -68,16 +71,24 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     private void runUpdates() {
         try {
             while(!this.stack.isEmpty() || !this.addedThisLayer.isEmpty()) {
-                for(int i = this.addedThisLayer.size() - 1; i >= 0; --i) {
-                    this.stack.push(this.addedThisLayer.get(i));
+
+                for (final NeighborUpdates neighborUpdates : addedThisLayer) {
+                    this.stack.push(neighborUpdates);
                 }
 
                 this.addedThisLayer.clear();
                 CollectingNeighborUpdater.NeighborUpdates neighborUpdates = this.stack.peek();
+                if (neighborUpdates == null) {
+                    continue;
+                }
 
                 while(this.addedThisLayer.isEmpty()) {
                     if (!neighborUpdates.runNext(this.level)) {
-                        this.stack.pop();
+                        try {
+                            this.stack.pop();
+                        } catch (final NoSuchElementException e) {
+                            // NOOP
+                        }
                         break;
                     }
                 }
@@ -103,7 +114,7 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
         private final Block sourceBlock;
         @Nullable
         private final Direction skipDirection;
-        private int idx = 0;
+        private volatile int idx = 0;
 
         MultiNeighborUpdate(BlockPos pos, Block sourceBlock, @Nullable Direction except) {
             this.sourcePos = pos;
diff --git a/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java b/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
index ac807277a6b26d140ea9873d17c7aa4fb5fe37b2..045322428d6f25695c101797dd3963f282b4386a 100644
--- a/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
+++ b/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
@@ -8,6 +8,8 @@ import java.util.Optional;
 import java.util.PriorityQueue;
 import java.util.Queue;
 import java.util.Set;
+import java.util.concurrent.ConcurrentSkipListSet;
+import java.util.concurrent.CopyOnWriteArraySet;
 import java.util.function.BiConsumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
@@ -21,7 +23,7 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
     private final Queue<ScheduledTick<T>> tickQueue = new PriorityQueue<>(ScheduledTick.DRAIN_ORDER);
     @Nullable
     private List<SavedTick<T>> pendingTicks;
-    private final Set<ScheduledTick<?>> ticksPerPosition = new ObjectOpenCustomHashSet<>(ScheduledTick.UNIQUE_TICK_HASH);
+    private final Set<ScheduledTick<?>> ticksPerPosition = new CopyOnWriteArraySet<>();
     @Nullable
     private BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>> onTickAdded;
 
