From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: camdenorrb <me@12oclock.dev>
Date: Fri, 25 Nov 2022 05:40:46 -0600
Subject: [PATCH] Simplify neighbor updating


diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index fc932998c3fe5a8ec71cdb7873b3d738787da897..7d5bb6c999428cc7cb7cc73066605d13f1b74b04 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -812,7 +812,7 @@ public final class PlayerChunkLoader {
         protected final ConcurrentSkipListSet<Long> sentChunks = new ConcurrentSkipListSet<>();
         protected final ConcurrentSkipListSet<Long> chunksToBeSent = new ConcurrentSkipListSet();
 
-        protected final TreeSet<ChunkPriorityHolder> sendQueue = new TreeSet<>((final @NotNull ChunkPriorityHolder p1, final @NotNull ChunkPriorityHolder p2) -> {
+        protected final ConcurrentSkipListSet<ChunkPriorityHolder> sendQueue = new ConcurrentSkipListSet<>((final @NotNull ChunkPriorityHolder p1, final @NotNull ChunkPriorityHolder p2) -> {
             final int distanceCompare = Integer.compare(p1.manhattanDistanceToPlayer, p2.manhattanDistanceToPlayer);
             if (distanceCompare != 0) {
                 return distanceCompare;
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
index 7b3df576a12d693b74d96a0dbbc94d425a851427..b885d916364e2eb0017a1bcc9e871012fb549ed8 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
@@ -38,13 +38,8 @@ import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 import java.io.IOException;
 import java.text.DecimalFormat;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
+import java.util.*;
+import java.util.concurrent.ConcurrentSkipListSet;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
@@ -75,7 +70,7 @@ public final class ChunkHolderManager {
     private long currentTick;
 
     private final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = new ArrayDeque<>();
-    private final ObjectRBTreeSet<NewChunkHolder> autoSaveQueue = new ObjectRBTreeSet<>((final @NotNull NewChunkHolder c1, final @NotNull NewChunkHolder c2) -> {
+    private final ConcurrentSkipListSet<NewChunkHolder> autoSaveQueue = new ConcurrentSkipListSet<>((final @NotNull NewChunkHolder c1, final @NotNull NewChunkHolder c2) -> {
         if (c1 == c2) {
             return 0;
         }
@@ -174,8 +169,16 @@ public final class ChunkHolderManager {
         final List<NewChunkHolder> reschedule = new ArrayList<>();
         final long currentTick = MinecraftServer.currentTickLong;
         final long maxSaveTime = currentTick - this.world.paperConfig().chunks.autoSaveInterval.value();
-        for (int autoSaved = 0; autoSaved < this.world.paperConfig().chunks.maxAutoSaveChunksPerTick && !this.autoSaveQueue.isEmpty();) {
-            final NewChunkHolder holder = this.autoSaveQueue.first();
+
+
+        for (int autoSaved = 0; autoSaved < this.world.paperConfig().chunks.maxAutoSaveChunksPerTick;) {
+
+            final NewChunkHolder holder;
+            try {
+                holder = this.autoSaveQueue.first();
+            } catch (final NoSuchElementException ex) {
+                break;
+            }
 
             if (holder.lastAutoSave > maxSaveTime) {
                 break;
diff --git a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
index 82e85cbf2ebbd1ca15290c167031caf5d5c02bcf..4c12afa912526e2ede15438f0994582a6d015d85 100644
--- a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
+++ b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
@@ -2,9 +2,7 @@ package net.minecraft.world.level.redstone;
 
 import com.mojang.logging.LogUtils;
 
-import java.util.*;
 import java.util.concurrent.ConcurrentLinkedDeque;
-import java.util.concurrent.CopyOnWriteArrayList;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -18,8 +16,6 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     private final Level level;
     private final int maxChainedNeighborUpdates;
     private final ConcurrentLinkedDeque<CollectingNeighborUpdater.NeighborUpdates> stack = new ConcurrentLinkedDeque<>();
-    private final List<CollectingNeighborUpdater.NeighborUpdates> addedThisLayer = new CopyOnWriteArrayList<>();
-    private volatile int count = 0;
 
     public CollectingNeighborUpdater(Level world, int maxChainDepth) {
         this.level = world;
@@ -47,61 +43,29 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     }
 
     private void addAndRun(BlockPos pos, CollectingNeighborUpdater.NeighborUpdates entry) {
-        boolean bl = this.count > 0;
-        boolean bl2 = this.maxChainedNeighborUpdates >= 0 && this.count >= this.maxChainedNeighborUpdates;
-        ++this.count;
-        if (!bl2) {
-            if (bl) {
-                this.addedThisLayer.add(entry);
-            } else {
-                this.stack.push(entry);
-            }
-        } else if (this.count - 1 == this.maxChainedNeighborUpdates) {
-            LOGGER.error("Too many chained neighbor updates. Skipping the rest. First skipped position: " + pos.toShortString());
-        }
-
-        if (!bl) {
-            this.runUpdates();
-        }
-
+        this.stack.push(entry);
+        this.runUpdates();
     }
 
     private void runUpdates() {
-        try {
-            while(!this.stack.isEmpty() || !this.addedThisLayer.isEmpty()) {
 
-                for (int i = this.addedThisLayer.size() - 1; i >= 0; --i) {
-                    try {
-                        this.stack.push(this.addedThisLayer.get(i));
-                    }
-                    catch (IndexOutOfBoundsException ex) {
-                        // NOOP, used for multithreaded purposes
-                    }
-                }
+        //int count = 0;
 
-                this.addedThisLayer.clear();
-                CollectingNeighborUpdater.NeighborUpdates neighborUpdates = this.stack.peek();
-                if (neighborUpdates == null) {
-                    continue;
-                }
+        //while (count < this.maxChainedNeighborUpdates) {
 
-                while(this.addedThisLayer.isEmpty()) {
-                    if (!neighborUpdates.runNext(this.level)) {
-                        try {
-                            this.stack.pop();
-                        } catch (final NoSuchElementException e) {
-                            // NOOP
-                        }
-                        break;
-                    }
-                }
+        while (true) {
+
+            final CollectingNeighborUpdater.NeighborUpdates entry = this.stack.peek();
+            if (entry == null) {
+                break;
+            }
+
+            if (!entry.runNext(this.level)) {
+                stack.remove(entry);
             }
-        } finally {
-            this.stack.clear();
-            this.addedThisLayer.clear();
-            this.count = 0;
-        }
 
+            //count++;
+        }
     }
 
     static record FullNeighborUpdate(BlockState state, BlockPos pos, Block block, BlockPos neighborPos, boolean movedByPiston) implements CollectingNeighborUpdater.NeighborUpdates {
diff --git a/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java b/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
index 045322428d6f25695c101797dd3963f282b4386a..0dd3a90b0a1b04dd017acbbdeda9bb456fa56a6d 100644
--- a/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
+++ b/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
@@ -23,7 +23,9 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
     private final Queue<ScheduledTick<T>> tickQueue = new PriorityQueue<>(ScheduledTick.DRAIN_ORDER);
     @Nullable
     private List<SavedTick<T>> pendingTicks;
-    private final Set<ScheduledTick<?>> ticksPerPosition = new CopyOnWriteArraySet<>();
+
+    // Note: Don't change this to something that doesn't filter by tick hash, breaks the game
+    private final Set<ScheduledTick<?>> ticksPerPosition = new ObjectOpenCustomHashSet<>(ScheduledTick.UNIQUE_TICK_HASH);
     @Nullable
     private BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>> onTickAdded;
 
