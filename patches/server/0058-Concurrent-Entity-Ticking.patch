From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: camdenorrb <me@12oclock.dev>
Date: Mon, 14 Nov 2022 13:18:36 -0600
Subject: [PATCH] Concurrent Entity Ticking


diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java b/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
index 032c0fb9cd09dc4e353120d0679bc2ae9b80370f..eea2a07df122b76f905ad57413eac221d091f1a0 100644
--- a/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
@@ -1,4 +1,5 @@
 package com.destroystokyo.paper.util.maplist;
+/*
 
 import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
 import net.minecraft.world.entity.Entity;
@@ -10,9 +11,11 @@ import java.util.Iterator;
 import java.util.NoSuchElementException;
 
 // list with O(1) remove & contains
+*/
 /**
  * @author Spottedleaf
- */
+ *//*
+
 public final class EntityList implements Iterable<Entity> {
 
     protected final Int2IntOpenHashMap entityToIndex = new Int2IntOpenHashMap(2, 0.8f);
@@ -128,4 +131,4 @@ public final class EntityList implements Iterable<Entity> {
             }
         };
     }
-}
+}*/
diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index 688d79a902c4ff4aec1810b4873b750848dd3ffb..e7b63f84c5b8ab86b2ec2ed17592825720b6f77a 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -24,10 +24,9 @@ import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.entity.Player;
 import org.jetbrains.annotations.NotNull;
 
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.TreeSet;
+import java.util.*;
+import java.util.concurrent.ConcurrentSkipListSet;
+import java.util.concurrent.CopyOnWriteArraySet;
 import java.util.concurrent.atomic.AtomicInteger;
 
 public final class PlayerChunkLoader {
@@ -79,7 +78,7 @@ public final class PlayerChunkLoader {
 
     protected final ChunkMap chunkMap;
     protected final Reference2ObjectLinkedOpenHashMap<ServerPlayer, PlayerLoaderData> playerMap = new Reference2ObjectLinkedOpenHashMap<>(512, 0.7f);
-    protected final ReferenceLinkedOpenHashSet<PlayerLoaderData> chunkSendQueue = new ReferenceLinkedOpenHashSet<>(512, 0.7f);
+    protected final Set<PlayerLoaderData> chunkSendQueue = new CopyOnWriteArraySet<>();
 
     protected final TreeSet<PlayerLoaderData> chunkLoadQueue = new TreeSet<>((final @NotNull PlayerLoaderData p1, final @NotNull PlayerLoaderData p2) -> {
         if (p1 == p2) {
@@ -111,7 +110,7 @@ public final class PlayerChunkLoader {
         return Integer.compare(System.identityHashCode(p1), System.identityHashCode(p2));
     });
 
-    protected final TreeSet<PlayerLoaderData> chunkSendWaitQueue = new TreeSet<>((final @NotNull PlayerLoaderData p1, final @NotNull PlayerLoaderData p2) -> {
+    protected final ConcurrentSkipListSet<PlayerLoaderData> chunkSendWaitQueue = new ConcurrentSkipListSet<>((final @NotNull PlayerLoaderData p1, final @NotNull PlayerLoaderData p2) -> {
         if (p1 == p2) {
             return 0;
         }
@@ -548,6 +547,12 @@ public final class PlayerChunkLoader {
             if (this.chunkSendQueue.isEmpty()) {
                 break;
             }
+
+            final PlayerLoaderData data = this.chunkSendQueue.stream().findFirst().orElse(null);
+            if (data == null) {
+                break;
+            }
+
             final int currSends = concurrentChunkSends.get();
             if (currSends >= maxSends) {
                 break;
@@ -557,9 +562,7 @@ public final class PlayerChunkLoader {
                 continue;
             }
 
-            // send chunk
-
-            final PlayerLoaderData data = this.chunkSendQueue.removeFirst();
+            this.chunkSendQueue.remove(data);
 
             final ChunkPriorityHolder queuedSend = data.sendQueue.pollFirst();
             if (queuedSend == null) {
@@ -621,7 +624,11 @@ public final class PlayerChunkLoader {
         final long time = System.nanoTime();
         boolean updatedCounters = false;
         for (;;) {
+
             final PlayerLoaderData data = this.chunkLoadQueue.pollFirst();
+            if (data == null) {
+                break;
+            }
 
             data.lastChunkLoad = time;
 
@@ -789,10 +796,10 @@ public final class PlayerChunkLoader {
         // warning: modifications of this field must be aware that the loadQueue inside PlayerChunkLoader uses this field
         // in a comparator!
         protected final ArrayDeque<ChunkPriorityHolder> loadQueue = new ArrayDeque<>();
-        protected final LongOpenHashSet sentChunks = new LongOpenHashSet();
+        protected final ConcurrentSkipListSet<Long> sentChunks = new ConcurrentSkipListSet<>();
         protected final LongOpenHashSet chunksToBeSent = new LongOpenHashSet();
 
-        protected final TreeSet<ChunkPriorityHolder> sendQueue = new TreeSet<>((final @NotNull ChunkPriorityHolder p1, final @NotNull ChunkPriorityHolder p2) -> {
+        protected final ConcurrentSkipListSet<ChunkPriorityHolder> sendQueue = new ConcurrentSkipListSet<>((final @NotNull ChunkPriorityHolder p1, final @NotNull ChunkPriorityHolder p2) -> {
             final int distanceCompare = Integer.compare(p1.manhattanDistanceToPlayer, p2.manhattanDistanceToPlayer);
             if (distanceCompare != 0) {
                 return distanceCompare;
diff --git a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
index 3ef398885526c9133c2205dd8b143703b1e09672..fedb515c5db4447cc3a8697c636146a8c20adfed 100644
--- a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
+++ b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
@@ -1,6 +1,5 @@
 package io.papermc.paper.chunk.system.entity;
 
-import com.destroystokyo.paper.util.maplist.EntityList;
 import com.mojang.logging.LogUtils;
 import io.papermc.paper.util.CoordinateUtils;
 import io.papermc.paper.util.TickThread;
@@ -25,11 +24,8 @@ import net.minecraft.world.phys.AABB;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.NoSuchElementException;
-import java.util.UUID;
+
+import java.util.*;
 import java.util.concurrent.locks.StampedLock;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
@@ -54,7 +50,9 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
     private final StampedLock entityByLock = new StampedLock();
     private final Int2ReferenceOpenHashMap<Entity> entityById = new Int2ReferenceOpenHashMap<>();
     private final Object2ReferenceOpenHashMap<UUID, Entity> entityByUUID = new Object2ReferenceOpenHashMap<>();
-    private final EntityList accessibleEntities = new EntityList();
+
+    // ID -> Entity
+    private final Map<Integer, Entity> accessibleEntities = new HashMap<>();
 
     public EntityLookup(final @NotNull ServerLevel world, final LevelCallback<Entity> worldCallback) {
         this.world = world;
@@ -131,62 +129,9 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         return "count_id:" + this.entityById.size() + ",count_uuid:" + this.entityByUUID.size() + ",region_count:" + this.regions.size();
     }
 
-    static final class ArrayIterable<T> implements Iterable<T> {
-
-        private final T[] array;
-        private final int off;
-        private final int length;
-
-        public ArrayIterable(final T @NotNull [] array, final int off, final int length) {
-            this.array = array;
-            this.off = off;
-            this.length = length;
-            if (length > array.length) {
-                throw new IllegalArgumentException("Length must be no greater-than the array length");
-            }
-        }
-
-        @NotNull
-        @Override
-        public Iterator<T> iterator() {
-            return new ArrayIterator<>(this.array, this.off, this.length);
-        }
-
-        static final class ArrayIterator<T> implements Iterator<T> {
-
-            private final T[] array;
-            private int off;
-            private final int length;
-
-            public ArrayIterator(final T[] array, final int off, final int length) {
-                this.array = array;
-                this.off = off;
-                this.length = length;
-            }
-
-            @Override
-            public boolean hasNext() {
-                return this.off < this.length;
-            }
-
-            @Override
-            public T next() {
-                if (this.off >= this.length) {
-                    throw new NoSuchElementException();
-                }
-                return this.array[this.off++];
-            }
-
-            @Override
-            public void remove() {
-                throw new UnsupportedOperationException();
-            }
-        }
-    }
-
     @Override
     public @NotNull Iterable<Entity> getAll() {
-        return new ArrayIterable<>(this.accessibleEntities.getRawData(), 0, this.accessibleEntities.size());
+        return this.accessibleEntities.values();
     }
 
     @Override
@@ -228,7 +173,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
                                    final boolean created, final boolean destroyed) {
         TickThread.ensureTickThread(entity, "Entity status change must only happen on the main thread");
 
-        if (entity.updatingSectionStatus) {
+        if (entity.updatingSectionStatus.get()) {
             // recursive status update
             LOGGER.error("Cannot recursively update entity chunk status for entity " + entity, new Throwable());
             return;
@@ -237,14 +182,14 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         final boolean entityStatusUpdateBefore = slices == null ? false : slices.startPreventingStatusUpdates();
 
         if (entityStatusUpdateBefore) {
-            LOGGER.error("Cannot update chunk status for entity " + entity + " since entity chunk (" + slices.chunkX + "," + slices.chunkZ + ") is receiving update", new Throwable());
+            //LOGGER.error("Cannot update chunk status for entity " + entity + " since entity chunk (" + slices.chunkX + "," + slices.chunkZ + ") is receiving update", new Throwable());
             return;
         }
 
         try {
             final Boolean ticketBlockBefore = this.world.chunkTaskScheduler.chunkHolderManager.blockTicketUpdates();
             try {
-                entity.updatingSectionStatus = true;
+                entity.updatingSectionStatus.set(true);
                 try {
                     if (created) {
                         EntityLookup.this.worldCallback.onCreated(entity);
@@ -260,7 +205,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
                     if (newVisibility.ordinal() > oldVisibility.ordinal()) {
                         // status upgrade
                         if (!oldVisibility.isAccessible() && newVisibility.isAccessible()) {
-                            this.accessibleEntities.add(entity);
+                            this.accessibleEntities.put(entity.getId(), entity);
                             EntityLookup.this.worldCallback.onTrackingStart(entity);
                         }
 
@@ -274,7 +219,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
                         }
 
                         if (oldVisibility.isAccessible() && !newVisibility.isAccessible()) {
-                            this.accessibleEntities.remove(entity);
+                            this.accessibleEntities.remove(entity.getId());
                             EntityLookup.this.worldCallback.onTrackingEnd(entity);
                         }
                     }
@@ -287,7 +232,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
                         EntityLookup.this.worldCallback.onDestroyed(entity);
                     }
                 } finally {
-                    entity.updatingSectionStatus = false;
+                    entity.updatingSectionStatus.set(false);
                 }
             } finally {
                 this.world.chunkTaskScheduler.chunkHolderManager.unblockTicketUpdates(ticketBlockBefore);
@@ -345,7 +290,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
             return false;
         }
 
-        if (entity.updatingSectionStatus) {
+        if (entity.updatingSectionStatus.get()) {
             LOGGER.warn("Entity " + entity + " is currently prevented from being added/removed to world since it is processing section status updates", new Throwable());
             return false;
         }
@@ -443,7 +388,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         final ChunkEntitySlices old = this.getChunk(entity.sectionX, entity.sectionZ);
         final ChunkEntitySlices slices = this.getOrCreateChunk(newSectionX, newSectionZ);
 
-        if (!old.removeEntity(entity, entity.sectionY)) {
+        if (old == null || !old.removeEntity(entity, entity.sectionY)) {
             LOGGER.warn("Could not remove entity " + entity + " from its old chunk section (" + entity.sectionX + "," + entity.sectionY + "," + entity.sectionZ + ") since it was not contained in the section");
         }
 
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
index 7b3df576a12d693b74d96a0dbbc94d425a851427..abc2b2c9fde8d32b19aab54d04fddcbb8cc345dc 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
@@ -38,13 +38,8 @@ import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 import java.io.IOException;
 import java.text.DecimalFormat;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
+import java.util.*;
+import java.util.concurrent.ConcurrentSkipListSet;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
@@ -75,7 +70,7 @@ public final class ChunkHolderManager {
     private long currentTick;
 
     private final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = new ArrayDeque<>();
-    private final ObjectRBTreeSet<NewChunkHolder> autoSaveQueue = new ObjectRBTreeSet<>((final @NotNull NewChunkHolder c1, final @NotNull NewChunkHolder c2) -> {
+    private final ConcurrentSkipListSet<NewChunkHolder> autoSaveQueue = new ConcurrentSkipListSet<>((final @NotNull NewChunkHolder c1, final @NotNull NewChunkHolder c2) -> {
         if (c1 == c2) {
             return 0;
         }
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
index b8849248a7398f25894ef215aa250a2c7f714950..2dd64f7944286f66289c9c5094a486355f13716d 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
@@ -269,12 +269,14 @@ public final class ChunkTaskScheduler {
     public void scheduleTickingState(final int chunkX, final int chunkZ, final ChunkHolder.@NotNull FullChunkStatus toStatus,
                                      final boolean addTicket, final PrioritisedExecutor.@NotNull Priority priority,
                                      final @Nullable Consumer<LevelChunk> onComplete) {
+
+        /*
         if (!TickThread.isTickThread()) {
             this.scheduleChunkTask(chunkX, chunkZ, () -> {
                 ChunkTaskScheduler.this.scheduleTickingState(chunkX, chunkZ, toStatus, addTicket, priority, onComplete);
             }, priority);
             return;
-        }
+        }*/
         if (this.chunkHolderManager.ticketLock.isHeldByCurrentThread()) {
             throw new IllegalStateException("Cannot schedule chunk load during ticket level update");
         }
@@ -384,12 +386,15 @@ public final class ChunkTaskScheduler {
 
     public void scheduleChunkLoad(final int chunkX, final int chunkZ, final @NotNull ChunkStatus toStatus, final boolean addTicket,
                                   final PrioritisedExecutor.@NotNull Priority priority, final @Nullable Consumer<ChunkAccess> onComplete) {
+
+        /*
         if (!TickThread.isTickThread()) {
-            this.scheduleChunkTask(chunkX, chunkZ, () -> {
-                ChunkTaskScheduler.this.scheduleChunkLoad(chunkX, chunkZ, toStatus, addTicket, priority, onComplete);
-            }, priority);
+            //this.scheduleChunkTask(chunkX, chunkZ, () -> {
+            ChunkTaskScheduler.this.scheduleChunkLoad(chunkX, chunkZ, toStatus, addTicket, priority, onComplete);
+            //}, priority);
             return;
         }
+        */
         if (this.chunkHolderManager.ticketLock.isHeldByCurrentThread()) {
             throw new IllegalStateException("Cannot schedule chunk load during ticket level update");
         }
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
index 9ecdaf6c3ef37f300ffc62cf44884ac1a5352b29..12db2ecb0a4023d53b22f62457975ada81ee1849 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/NewChunkHolder.java
@@ -1186,7 +1186,9 @@ public final class NewChunkHolder {
         for (long curr = (long)CHUNK_STATUS_HANDLE.getVolatile((NewChunkHolder)this);;) {
             final ChunkHolder.FullChunkStatus currPending = getPendingChunkStatus(curr);
             if (loaded && currPending != ChunkHolder.FullChunkStatus.INACCESSIBLE) {
-                throw new IllegalStateException("Expected " + ChunkHolder.FullChunkStatus.INACCESSIBLE + " for pending, but got " + currPending);
+                System.err.println("Tried to queue border status for chunk " + this + " but it already has a pending status of " + currPending);
+                return false;
+                //throw new IllegalStateException("Expected " + ChunkHolder.FullChunkStatus.INACCESSIBLE + " for pending, but got " + currPending);
             }
 
             final long update = (curr & ~PENDING_STATUS_MASK) | ((long)toStatus.ordinal() << 32);
diff --git a/src/main/java/io/papermc/paper/command/PaperCommands.java b/src/main/java/io/papermc/paper/command/PaperCommands.java
index 6512480e790593671b152251d5a124e3c94a1580..b1e1a5bf037476449dea7687b0215ae7cfe0a731 100644
--- a/src/main/java/io/papermc/paper/command/PaperCommands.java
+++ b/src/main/java/io/papermc/paper/command/PaperCommands.java
@@ -19,6 +19,7 @@ public final class PaperCommands {
         COMMANDS.put("paper", new PaperCommand("paper"));
         COMMANDS.put("mspt", new MSPTCommand("mspt"));
         COMMANDS.put("mem", new MemCommand("mem"));
+        COMMANDS.put("spawnAllMobs", new SpawnAllMobsCommand("spawnAllMobs"));
     }
 
     public static void registerCommands(final MinecraftServer server) {
diff --git a/src/main/java/io/papermc/paper/command/SpawnAllMobsCommand.java b/src/main/java/io/papermc/paper/command/SpawnAllMobsCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..1efa5d89549ed07cedb58ec292b78b52ce69c649
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/SpawnAllMobsCommand.java
@@ -0,0 +1,62 @@
+package io.papermc.paper.command;
+
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.EntityType;
+import org.bukkit.entity.Hanging;
+import org.bukkit.entity.Player;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collections;
+import java.util.List;
+
+
+// This is a command to test the server with all entities, should be removed in production
+@DefaultQualifier(NonNull.class)
+public final class SpawnAllMobsCommand extends Command {
+
+	public SpawnAllMobsCommand(final String name) {
+		super(name);
+		this.description = "Spawns all mobs";
+		this.usageMessage = "/spawnAllMobs";
+		this.setPermission("bukkit.command.spawnAllMobs");
+	}
+
+	@Override
+	public @NotNull List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
+		return Collections.emptyList();
+	}
+
+	@Override
+	public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+
+		if (!testPermission(sender)) {
+			return true;
+		}
+
+		final Location location;
+
+		if (!(sender instanceof Player)) {
+			location = new Location(Bukkit.getWorld("world"), 0, 70, 0);
+		}
+		else {
+			location = ((Player) sender).getLocation();
+		}
+
+		// Spawn all mobs at player's location
+		for (final org.bukkit.entity.EntityType type : org.bukkit.entity.EntityType.values()) {
+			if (type.isSpawnable()) {
+				if (type == EntityType.PAINTING) {
+					continue;
+				}
+				location.getWorld().spawnEntity(location, type);
+			}
+		}
+
+		return true;
+	}
+}
diff --git a/src/main/java/io/papermc/paper/util/TickThread.java b/src/main/java/io/papermc/paper/util/TickThread.java
index b52a04cc6167d50ac573698069780033a2c2f20b..92f091ec5890f2d6125a4679ad241a0ffa76a0a1 100644
--- a/src/main/java/io/papermc/paper/util/TickThread.java
+++ b/src/main/java/io/papermc/paper/util/TickThread.java
@@ -33,24 +33,38 @@ public class TickThread extends Thread {
      */
     @Deprecated
     public static void ensureTickThread(final String reason) {
+
+        // Cat - Who cares >:)
+
+        /*
         if (!isTickThread()) {
             MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
             throw new IllegalStateException(reason);
         }
+        */
     }
 
     public static void ensureTickThread(final ServerLevel world, final int chunkX, final int chunkZ, final String reason) {
+
+        // Cat - Who cares >:)
+
+        /*
         if (!isTickThreadFor(world, chunkX, chunkZ)) {
             MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
             throw new IllegalStateException(reason);
         }
+        */
     }
 
     public static void ensureTickThread(final Entity entity, final String reason) {
+        // Cat - Who cares >:)
+
+        /*
         if (!isTickThreadFor(entity)) {
             MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
             throw new IllegalStateException(reason);
         }
+        */
     }
 
     public final int id; /* We don't override getId as the spec requires that it be unique (with respect to all other threads) */
diff --git a/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java b/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java
index bedffdcc5751e2242aebae016bcc223f43f93296..8b776a14b1aa9341953f2b6ffb775e5749867662 100644
--- a/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java
+++ b/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java
@@ -7,7 +7,10 @@ import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 import java.util.Arrays;
+import java.util.List;
 import java.util.NoSuchElementException;
+import java.util.concurrent.CopyOnWriteArrayList;
+
 
 public final class IteratorSafeOrderedReferenceSet<E> {
 
@@ -17,8 +20,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
     protected int firstInvalidIndex = -1;
 
     /* list impl */
-    protected E[] listElements;
-    protected int listSize;
+    protected CopyOnWriteArrayList<E> listElements;
 
     protected final double maxFragFactor;
 
@@ -43,7 +45,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         this.indexMap = new Reference2IntLinkedOpenHashMap<>(setCapacity, setLoadFactor);
         this.indexMap.defaultReturnValue(-1);
         this.maxFragFactor = maxFragFactor;
-        this.listElements = (E[])new Object[arrayCapacity];
+        this.listElements = new CopyOnWriteArrayList();
         this.threadRestricted = threadRestricted;
     }
 
@@ -93,9 +95,11 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         return !this.threadRestricted || Bukkit.isPrimaryThread();
     }
 
+    /*
     protected final double getFragFactor() {
         return 1.0 - ((double)this.indexMap.size() / (double)this.listSize);
     }
+    */
 
     public int createRawIterator() {
         if (this.allowSafeIteration()) {
@@ -109,23 +113,16 @@ public final class IteratorSafeOrderedReferenceSet<E> {
     }
 
     public int advanceRawIterator(final int index) {
-        final E[] elements = this.listElements;
-        int ret = index + 1;
-        for (int len = this.listSize; ret < len; ++ret) {
-            if (elements[ret] != null) {
-                return ret;
-            }
-        }
-
-        return -1;
+        return this.listElements.get(index + 1) == null ? -1 : index + 1;
     }
 
     public void finishRawIterator() {
+        /*
         if (this.allowSafeIteration() && --this.iteratorCount == 0) {
             if (this.getFragFactor() >= this.maxFragFactor) {
                 this.defrag();
             }
-        }
+        }*/
     }
 
     public boolean remove(final E element) {
@@ -134,13 +131,9 @@ public final class IteratorSafeOrderedReferenceSet<E> {
             if (this.firstInvalidIndex < 0 || index < this.firstInvalidIndex) {
                 this.firstInvalidIndex = index;
             }
-            if (this.listElements[index] != element) {
+            if (!this.listElements.remove(element)) {
                 throw new IllegalStateException();
             }
-            this.listElements[index] = null;
-            if (this.allowSafeIteration() && this.iteratorCount == 0 && this.getFragFactor() >= this.maxFragFactor) {
-                this.defrag();
-            }
             //this.check();
             return true;
         }
@@ -152,23 +145,21 @@ public final class IteratorSafeOrderedReferenceSet<E> {
     }
 
     public boolean add(final E element) {
-        final int listSize = this.listSize;
+        //final int listSize = this.listSize;
 
-        final int previous = this.indexMap.putIfAbsent(element, listSize);
+        final int previous = this.indexMap.putIfAbsent(element, listElements.size());
         if (previous != -1) {
             return false;
         }
 
-        if (listSize >= this.listElements.length) {
-            this.listElements = Arrays.copyOf(this.listElements, listSize * 2);
-        }
-        this.listElements[listSize] = element;
-        this.listSize = listSize + 1;
+        this.listElements.add(element);
+        //this.listSize = listSize + 1;
 
         //this.check();
         return true;
     }
 
+    /*
     protected void defrag() {
         if (this.firstInvalidIndex < 0) {
             return; // nothing to do
@@ -224,10 +215,10 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         this.listSize = lastValidIndex;
         this.firstInvalidIndex = -1;
         //this.check();
-    }
+    }*/
 
     public E rawGet(final int index) {
-        return this.listElements[index];
+        return this.listElements.get(index);
     }
 
     public int size() {
@@ -243,14 +234,14 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         if (this.allowSafeIteration()) {
             ++this.iteratorCount;
         }
-        return new BaseIterator<>(this, true, (flags & ITERATOR_FLAG_SEE_ADDITIONS) != 0 ? Integer.MAX_VALUE : this.listSize);
+        return new BaseIterator<>(this, true, (flags & ITERATOR_FLAG_SEE_ADDITIONS) != 0 ? Integer.MAX_VALUE : this.listElements.size());
     }
 
     public java.util.@NotNull Iterator<E> unsafeIterator() {
         return this.unsafeIterator(0);
     }
     public java.util.@NotNull Iterator<E> unsafeIterator(final int flags) {
-        return new BaseIterator<>(this, false, (flags & ITERATOR_FLAG_SEE_ADDITIONS) != 0 ? Integer.MAX_VALUE : this.listSize);
+        return new BaseIterator<>(this, false, (flags & ITERATOR_FLAG_SEE_ADDITIONS) != 0 ? Integer.MAX_VALUE : this.listElements.size());
     }
 
     public static interface Iterator<E> extends java.util.Iterator<E> {
@@ -263,7 +254,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
 
         protected final IteratorSafeOrderedReferenceSet<E> set;
         protected final boolean canFinish;
-        protected final int maxIndex;
+        //protected final int maxIndex;
         protected int nextIndex;
         protected @Nullable E pendingValue;
         protected boolean finished;
@@ -272,7 +263,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         protected BaseIterator(final IteratorSafeOrderedReferenceSet<E> set, final boolean canFinish, final int maxIndex) {
             this.set = set;
             this.canFinish = canFinish;
-            this.maxIndex = maxIndex;
+            //this.maxIndex = maxIndex;
         }
 
         @Override
@@ -284,10 +275,10 @@ public final class IteratorSafeOrderedReferenceSet<E> {
                 return true;
             }
 
-            final E[] elements = this.set.listElements;
+            final List<E> elements = this.set.listElements;
             int index, len;
-            for (index = this.nextIndex, len = Math.min(this.maxIndex, this.set.listSize); index < len; ++index) {
-                final E element = elements[index];
+            for (index = this.nextIndex, len = elements.size(); index < len; ++index) {
+                final E element = elements.get(index);
                 if (element != null) {
                     this.pendingValue = element;
                     this.nextIndex = index + 1;
diff --git a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
index 2e30756758e5f3d38bca12ce0d7a436bba3ac843..c8aa1266d96c72e61f3cb9354a3905a90091f127 100644
--- a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
+++ b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
@@ -1,6 +1,5 @@
 package io.papermc.paper.world;
 
-import com.destroystokyo.paper.util.maplist.EntityList;
 import io.papermc.paper.chunk.system.entity.EntityLookup;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap;
@@ -20,11 +19,12 @@ import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.List;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Predicate;
+import java.util.stream.Collectors;
+
 
 public final class ChunkEntitySlices {
 
@@ -36,8 +36,10 @@ public final class ChunkEntitySlices {
 
     protected final @NotNull EntityCollectionBySection allEntities;
     protected final @NotNull EntityCollectionBySection hardCollidingEntities;
-    protected final @NotNull Reference2ObjectOpenHashMap<Class<? extends Entity>, EntityCollectionBySection> entitiesByClass;
-    protected final EntityList entities = new EntityList();
+    protected final @NotNull Map<Class<? extends Entity>, EntityCollectionBySection> entitiesByClass;
+
+    // ID -> Entity
+    protected final Map<Integer, Entity> entities = new ConcurrentHashMap<>();
 
     public ChunkHolder.FullChunkStatus status;
 
@@ -63,43 +65,29 @@ public final class ChunkEntitySlices {
 
         this.allEntities = new EntityCollectionBySection(this);
         this.hardCollidingEntities = new EntityCollectionBySection(this);
-        this.entitiesByClass = new Reference2ObjectOpenHashMap<>();
+        this.entitiesByClass = new ConcurrentHashMap<>();
 
         this.status = status;
     }
 
     // Paper start - optimise CraftChunk#getEntities
-    public org.bukkit.entity.Entity @NotNull [] getChunkEntities() {
-        List<org.bukkit.entity.Entity> ret = new java.util.ArrayList<>();
-        final Entity[] entities = this.entities.getRawData();
-        for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
-            final Entity entity = entities[i];
-            if (entity == null) {
-                continue;
-            }
-            final org.bukkit.entity.Entity bukkit = entity.getBukkitEntity();
-            if (bukkit != null && bukkit.isValid()) {
-                ret.add(bukkit);
-            }
-        }
-
-        return ret.toArray(new org.bukkit.entity.Entity[0]);
+    public @NotNull List<org.bukkit.entity.Entity> getChunkEntities() {
+        return this.entities.values().stream()
+            .map(Entity::getBukkitEntity)
+            .filter(Objects::nonNull)
+            .filter(org.bukkit.entity.Entity::isValid)
+            .collect(Collectors.toList());
     }
 
     public @Nullable CompoundTag save() {
-        final int len = this.entities.size();
-        if (len == 0) {
+
+        if (this.entities.isEmpty()) {
             return null;
         }
 
-        final Entity[] rawData = this.entities.getRawData();
-        final List<Entity> collectedEntities = new ArrayList<>(len);
-        for (int i = 0; i < len; ++i) {
-            final Entity entity = rawData[i];
-            if (entity.shouldBeSaved()) {
-                collectedEntities.add(entity);
-            }
-        }
+        final List<Entity> collectedEntities = this.entities.values().stream()
+            .filter(Entity::shouldBeSaved)
+            .collect(Collectors.toList());
 
         if (collectedEntities.isEmpty()) {
             return null;
@@ -111,10 +99,10 @@ public final class ChunkEntitySlices {
     // returns true if this chunk has transient entities remaining
     public boolean unload() {
         final int len = this.entities.size();
-        final Entity[] collectedEntities = Arrays.copyOf(this.entities.getRawData(), len);
+        final List<Entity> collectedEntities = this.entities.values().stream().toList();
 
         for (int i = 0; i < len; ++i) {
-            final Entity entity = collectedEntities[i];
+            final Entity entity = collectedEntities.get(i);
             if (entity.isRemoved()) {
                 // removed by us below
                 continue;
@@ -135,16 +123,7 @@ public final class ChunkEntitySlices {
     }
 
     private @NotNull List<Entity> getAllEntities() {
-        final int len = this.entities.size();
-        if (len == 0) {
-            return new ArrayList<>();
-        }
-
-        final Entity[] rawData = this.entities.getRawData();
-        final List<Entity> collectedEntities = new ArrayList<>(len);
-	    collectedEntities.addAll(Arrays.asList(rawData).subList(0, len));
-
-        return collectedEntities;
+        return this.entities.values().stream().toList();
     }
 
     public void callEntitiesLoadEvent() {
@@ -161,9 +140,7 @@ public final class ChunkEntitySlices {
     }
 
     public void mergeInto(final @NotNull ChunkEntitySlices slices) {
-        final Entity[] entities = this.entities.getRawData();
-        for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
-            final Entity entity = entities[i];
+        for (final Entity entity : this.entities.values()) {
             slices.addEntity(entity, entity.sectionY);
         }
     }
@@ -182,10 +159,7 @@ public final class ChunkEntitySlices {
     public void updateStatus(final ChunkHolder.@NotNull FullChunkStatus status, final @NotNull EntityLookup lookup) {
         this.status = status;
 
-        final Entity[] entities = this.entities.getRawData();
-
-        for (int i = 0, size = this.entities.size(); i < size; ++i) {
-            final Entity entity = entities[i];
+        for (final Entity entity : this.entities.values()) {
 
             final Visibility oldVisibility = EntityLookup.getEntityStatus(entity);
             entity.chunkStatus = status;
@@ -196,9 +170,13 @@ public final class ChunkEntitySlices {
     }
 
     public boolean addEntity(final @NotNull Entity entity, final int chunkSection) {
-        if (!this.entities.add(entity)) {
+
+        if (this.entities.containsKey(entity.getId())) {
             return false;
         }
+
+        this.entities.put(entity.getId(), entity);
+
         entity.chunkStatus = this.status;
         final int sectionIndex = chunkSection - this.minSection;
 
@@ -208,10 +186,8 @@ public final class ChunkEntitySlices {
             this.hardCollidingEntities.addEntity(entity, sectionIndex);
         }
 
-        for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
-             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
-
+        // Loop through entitiesByClass entry set
+        for (final Map.Entry<Class<? extends Entity>, EntityCollectionBySection> entry : this.entitiesByClass.entrySet()) {
             if (entry.getKey().isInstance(entity)) {
                 entry.getValue().addEntity(entity, sectionIndex);
             }
@@ -221,7 +197,7 @@ public final class ChunkEntitySlices {
     }
 
     public boolean removeEntity(final @NotNull Entity entity, final int chunkSection) {
-        if (!this.entities.remove(entity)) {
+        if (this.entities.remove(entity.getId()) == null) {
             return false;
         }
         entity.chunkStatus = null;
@@ -233,10 +209,8 @@ public final class ChunkEntitySlices {
             this.hardCollidingEntities.removeEntity(entity, sectionIndex);
         }
 
-        for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
-             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
-
+        // Loop through entitiesByClass entry set
+        for (final Map.Entry<Class<? extends Entity>, EntityCollectionBySection> entry : this.entitiesByClass.entrySet()) {
             if (entry.getKey().isInstance(entity)) {
                 entry.getValue().removeEntity(entity, sectionIndex);
             }
@@ -266,16 +240,12 @@ public final class ChunkEntitySlices {
         final EntityCollectionBySection ret = new EntityCollectionBySection(this);
 
         for (int sectionIndex = 0; sectionIndex < this.allEntities.entitiesBySection.length; ++sectionIndex) {
-            final BasicEntityList<Entity> sectionEntities = this.allEntities.entitiesBySection[sectionIndex];
+            final List<Entity> sectionEntities = this.allEntities.entitiesBySection[sectionIndex];
             if (sectionEntities == null) {
                 continue;
             }
 
-            final Entity[] storage = sectionEntities.storage;
-
-            for (int i = 0, len = Math.min(storage.length, sectionEntities.size()); i < len; ++i) {
-                final Entity entity = storage[i];
-
+            for (final Entity entity : sectionEntities) {
                 if (clazz.isInstance(entity)) {
                     ret.addEntity(entity, sectionIndex);
                 }
@@ -296,7 +266,8 @@ public final class ChunkEntitySlices {
         }
     }
 
-    protected static final class BasicEntityList<E extends Entity> {
+
+/*    protected static final class BasicEntityList<E extends Entity> {
 
         protected static final Entity[] EMPTY = new Entity[0];
         protected static final int DEFAULT_CAPACITY = 4;
@@ -358,7 +329,7 @@ public final class ChunkEntitySlices {
 
             final int size = --this.size;
             final E[] storage = this.storage;
-            if (idx != size) {
+            if (idx != size && size - idx >= 0) {
                 System.arraycopy(storage, idx + 1, storage, idx, size - idx);
             }
 
@@ -371,12 +342,12 @@ public final class ChunkEntitySlices {
             return this.indexOf(entity) != -1;
         }
     }
-
+*/
     protected static final class EntityCollectionBySection {
 
         protected final ChunkEntitySlices manager;
         protected final long @NotNull [] nonEmptyBitset;
-        protected final BasicEntityList<Entity> @NotNull [] entitiesBySection;
+        protected final CopyOnWriteArrayList<Entity> @NotNull [] entitiesBySection;
         protected int count;
 
         public EntityCollectionBySection(final @NotNull ChunkEntitySlices manager) {
@@ -385,18 +356,18 @@ public final class ChunkEntitySlices {
             final int sectionCount = manager.maxSection - manager.minSection + 1;
 
             this.nonEmptyBitset = new long[(sectionCount + (Long.SIZE - 1)) >>> 6]; // (sectionCount + (Long.SIZE - 1)) / Long.SIZE
-            this.entitiesBySection = new BasicEntityList[sectionCount];
+            this.entitiesBySection = new CopyOnWriteArrayList[sectionCount];
         }
 
         public void addEntity(final Entity entity, final int sectionIndex) {
-            BasicEntityList<Entity> list = this.entitiesBySection[sectionIndex];
+            CopyOnWriteArrayList<Entity> list = this.entitiesBySection[sectionIndex];
 
-            if (list != null && list.has(entity)) {
+            if (list != null && list.contains(entity)) {
                 return;
             }
 
             if (list == null) {
-                this.entitiesBySection[sectionIndex] = list = new BasicEntityList<>();
+                this.entitiesBySection[sectionIndex] = list = new CopyOnWriteArrayList<>();
                 this.nonEmptyBitset[sectionIndex >>> 6] |= (1L << (sectionIndex & (Long.SIZE - 1)));
             }
 
@@ -405,7 +376,7 @@ public final class ChunkEntitySlices {
         }
 
         public void removeEntity(final Entity entity, final int sectionIndex) {
-            final BasicEntityList<Entity> list = this.entitiesBySection[sectionIndex];
+            final CopyOnWriteArrayList<Entity> list = this.entitiesBySection[sectionIndex];
 
             if (list == null || !list.remove(entity)) {
                 return;
@@ -430,19 +401,16 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
+            final CopyOnWriteArrayList<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
-                final BasicEntityList<Entity> list = entitiesBySection[section - minSection];
+                final CopyOnWriteArrayList<Entity> list = entitiesBySection[section - minSection];
 
                 if (list == null) {
                     continue;
                 }
 
-                final Entity[] storage = list.storage;
-
-                for (int i = 0, len = Math.min(storage.length, list.size()); i < len; ++i) {
-                    final Entity entity = storage[i];
+                for (final Entity entity : list) {
 
                     if (entity == null || entity == except || !entity.getBoundingBox().intersects(box)) {
                         continue;
@@ -469,20 +437,16 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
+            final List<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
-                final BasicEntityList<Entity> list = entitiesBySection[section - minSection];
+                final List<Entity> list = entitiesBySection[section - minSection];
 
                 if (list == null) {
                     continue;
                 }
 
-                final Entity[] storage = list.storage;
-
-                for (int i = 0, len = Math.min(storage.length, list.size()); i < len; ++i) {
-                    final Entity entity = storage[i];
-
+                for (final Entity entity : list) {
                     if (entity == null || entity == except || !entity.getBoundingBox().intersects(box)) {
                         continue;
                     }
@@ -520,19 +484,17 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
+            final List<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
-                final BasicEntityList<Entity> list = entitiesBySection[section - minSection];
+                final List<Entity> list = entitiesBySection[section - minSection];
 
                 if (list == null) {
                     continue;
                 }
 
-                final Entity[] storage = list.storage;
 
-                for (int i = 0, len = Math.min(storage.length, list.size()); i < len; ++i) {
-                    final Entity entity = storage[i];
+                for (final Entity entity : list) {
 
                     if (entity == null || entity == except || !entity.getBoundingBox().intersects(box)) {
                         continue;
@@ -555,6 +517,7 @@ public final class ChunkEntitySlices {
                             into.add(part);
                         }
                     }
+
                 }
             }
         }
@@ -571,20 +534,17 @@ public final class ChunkEntitySlices {
             final int min = Mth.clamp(Mth.floor(box.minY - 2.0) >> 4, minSection, maxSection);
             final int max = Mth.clamp(Mth.floor(box.maxY + 2.0) >> 4, minSection, maxSection);
 
-            final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
+            final List<Entity>[] entitiesBySection = this.entitiesBySection;
 
             for (int section = min; section <= max; ++section) {
-                final BasicEntityList<Entity> list = entitiesBySection[section - minSection];
+                final List<Entity> list = entitiesBySection[section - minSection];
 
                 if (list == null) {
                     continue;
                 }
 
-                final Entity[] storage = list.storage;
-
-                for (int i = 0, len = Math.min(storage.length, list.size()); i < len; ++i) {
-                    final Entity entity = storage[i];
 
+                for (final Entity entity : list) {
                     if (entity == null || (type != null && entity.getType() != type) || !entity.getBoundingBox().intersects(box)) {
                         continue;
                     }
@@ -595,6 +555,7 @@ public final class ChunkEntitySlices {
 
                     into.add((T)entity);
                 }
+
             }
         }
     }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
index 44961c070a25a9f73bdca3e820d0ac61730021be..0e188c979289fde407fe071d26ceb1ef3bc2297f 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
@@ -2,6 +2,9 @@ package net.minecraft.network.protocol.game;
 
 import it.unimi.dsi.fastutil.shorts.ShortIterator;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
+
+import java.util.Iterator;
+import java.util.Set;
 import java.util.function.BiConsumer;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -19,7 +22,7 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     private final BlockState[] states;
     private final boolean suppressLightUpdates;
 
-    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, ShortSet positions, LevelChunkSection section, boolean noLightingUpdates) {
+    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, Set<Short> positions, LevelChunkSection section, boolean noLightingUpdates) {
         this.sectionPos = sectionPos;
         this.suppressLightUpdates = noLightingUpdates;
         int i = positions.size();
@@ -28,7 +31,7 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
         this.states = new BlockState[i];
         int j = 0;
 
-        for (ShortIterator shortiterator = positions.iterator(); shortiterator.hasNext(); ++j) {
+        for (Iterator<Short> shortiterator = positions.iterator(); shortiterator.hasNext(); ++j) {
             short short0 = shortiterator.next().shortValue();
 
             this.positions[j] = short0;
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 904fcdeb7937d36208cc9a8d5eca9ef3a5b2cd9e..54dd0e4e67cc7dd5740a48288ef3f457ae2d2d7d 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -4,11 +4,10 @@ import com.mojang.datafixers.util.Either;
 import com.mojang.datafixers.util.Pair;
 import it.unimi.dsi.fastutil.shorts.ShortOpenHashSet;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
-import java.util.ArrayList;
-import java.util.BitSet;
-import java.util.List;
-import java.util.Optional;
+
+import java.util.*;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CopyOnWriteArraySet;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicReferenceArray;
 import java.util.function.IntConsumer;
@@ -58,7 +57,7 @@ public class ChunkHolder {
     // Paper - rewrite chunk system
     public final ChunkPos pos;
     private boolean hasChangedSections;
-    private final ShortSet[] changedBlocksPerSection;
+    private final CopyOnWriteArraySet<Short>[] changedBlocksPerSection;
     private final BitSet blockChangedLightSectionFilter;
     private final BitSet skyChangedLightSectionFilter;
     private final LevelLightEngine lightEngine;
@@ -140,7 +139,7 @@ public class ChunkHolder {
         this.onLevelChange = null; // Paper - rewrite chunk system
         this.playerProvider = playersWatchingChunkProvider;
         // Paper - rewrite chunk system
-        this.changedBlocksPerSection = new ShortSet[world.getSectionsCount()];
+        this.changedBlocksPerSection = new CopyOnWriteArraySet[world.getSectionsCount()];
         this.chunkMap = (ChunkMap)playersWatchingChunkProvider; // Paper
     }
 
@@ -233,7 +232,7 @@ public class ChunkHolder {
             if (i < 0 || i >= this.changedBlocksPerSection.length) return; // CraftBukkit - SPIGOT-6086, SPIGOT-6296
             if (this.changedBlocksPerSection[i] == null) {
                 this.hasChangedSections = true; this.addToBroadcastMap(); // Paper - optimise chunk tick iteration
-                this.changedBlocksPerSection[i] = new ShortOpenHashSet();
+                this.changedBlocksPerSection[i] = new CopyOnWriteArraySet<>();
             }
 
             this.changedBlocksPerSection[i].add(SectionPos.sectionRelativePos(pos));
@@ -301,14 +300,14 @@ public class ChunkHolder {
             }
 
             for (j = 0; j < this.changedBlocksPerSection.length; ++j) {
-                ShortSet shortset = this.changedBlocksPerSection[j];
+                Set<Short> shortset = this.changedBlocksPerSection[j];
 
                 if (shortset != null) {
                     int k = this.levelHeightAccessor.getSectionYFromSectionIndex(j);
                     SectionPos sectionposition = SectionPos.of(chunk.getPos(), k);
 
                     if (shortset.size() == 1) {
-                        BlockPos blockposition = sectionposition.relativeToBlockPos(shortset.iterator().nextShort());
+                        BlockPos blockposition = sectionposition.relativeToBlockPos(shortset.iterator().next());
                         BlockState iblockdata = world.getBlockState(blockposition);
 
                         this.broadcast(new ClientboundBlockUpdatePacket(blockposition, iblockdata), false);
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 2ec7ff347dbb6e2730d65730c7575ac2f77d5325..f6bda3743e562436077897441cd99b88ee562e46 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -30,20 +30,8 @@ import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import java.io.IOException;
 import java.io.Writer;
 import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.BitSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Queue;
-import java.util.Set;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CompletionException;
-import java.util.concurrent.CompletionStage;
-import java.util.concurrent.Executor;
+import java.util.*;
+import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
@@ -144,13 +132,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public final StructureTemplateManager structureTemplateManager; // Paper - rewrite chunk system
     private final String storageName;
     private final PlayerMap playerMap;
-    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap;
+    public final Map<Integer, TrackedEntity> entityMap = new ConcurrentHashMap<>();
     private final Long2ByteMap chunkTypeCache;
     private final Long2LongMap chunkSaveCooldowns;
     private final Queue<Runnable> unloadQueue;
     int viewDistance;
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobDistanceMap; // Paper
-    public final ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcasting = new ReferenceOpenHashSet<>();
+    public final CopyOnWriteArraySet<ChunkHolder> needsChangeBroadcasting = new CopyOnWriteArraySet<>();
 
     // Paper - rewrite chunk system
     // Paper start - optimise checkDespawn
@@ -292,7 +280,6 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper - rewrite chunk system
         this.tickingGenerated = new AtomicInteger();
         this.playerMap = new PlayerMap();
-        this.entityMap = new Int2ObjectOpenHashMap();
         this.chunkTypeCache = new Long2ByteOpenHashMap();
         this.chunkSaveCooldowns = new Long2LongOpenHashMap();
         this.unloadQueue = Queues.newConcurrentLinkedQueue();
@@ -1198,17 +1185,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                         ServerPlayer entityplayer = (ServerPlayer) entity;
 
                         this.updatePlayerStatus(entityplayer, true);
-                        ObjectIterator objectiterator = this.entityMap.values().iterator();
-
-                        while (objectiterator.hasNext()) {
-                            ChunkMap.TrackedEntity playerchunkmap_entitytracker1 = (ChunkMap.TrackedEntity) objectiterator.next();
-
+                        this.entityMap.values().forEach((playerchunkmap_entitytracker1) -> {
                             if (playerchunkmap_entitytracker1.entity != entityplayer) {
                                 playerchunkmap_entitytracker1.updatePlayer(entityplayer);
                             }
-                        }
-                    }
 
+                        });
+                    }
                 }
             }
         }
@@ -1220,13 +1203,9 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             ServerPlayer entityplayer = (ServerPlayer) entity;
 
             this.updatePlayerStatus(entityplayer, false);
-            ObjectIterator objectiterator = this.entityMap.values().iterator();
-
-            while (objectiterator.hasNext()) {
-                ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
-
+            this.entityMap.values().forEach((playerchunkmap_entitytracker) -> {
                 playerchunkmap_entitytracker.removePlayer(entityplayer);
-            }
+            });
         }
 
         ChunkMap.TrackedEntity playerchunkmap_entitytracker1 = this.entityMap.remove(entity.getId());
@@ -1270,7 +1249,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper end - optimized tracker
         List<ServerPlayer> list = Lists.newArrayList();
         List<ServerPlayer> list1 = this.level.players();
-        ObjectIterator objectiterator = this.entityMap.values().iterator();
+        Iterator objectiterator = this.entityMap.values().iterator();
         level.timings.tracker1.startTiming(); // Paper
 
         ChunkMap.TrackedEntity playerchunkmap_entitytracker;
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 8d9f2cf2c6b5bab47251b18bdcf30cdcae35fff6..770610b6395cd02491ac5240d98347f005c6fac5 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -6,13 +6,10 @@ import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
 import java.io.File;
 import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
+import java.util.*;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
@@ -71,8 +68,8 @@ public class ServerChunkCache extends ChunkSource {
     @VisibleForDebug
     private NaturalSpawner.SpawnState lastSpawnState;
     // Paper start
-    final com.destroystokyo.paper.util.concurrent.WeakSeqLock loadedChunkMapSeqLock = new com.destroystokyo.paper.util.concurrent.WeakSeqLock();
-    final it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<LevelChunk> loadedChunkMap = new it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<>(8192, 0.5f);
+    //final com.destroystokyo.paper.util.concurrent.WeakSeqLock loadedChunkMapSeqLock = new com.destroystokyo.paper.util.concurrent.WeakSeqLock();
+    final ConcurrentMap<Long, LevelChunk> loadedChunkMap = new ConcurrentHashMap<>(8192, 0.5f);
 
     private final LevelChunk[] lastLoadedChunks = new LevelChunk[4 * 4];
 
@@ -81,12 +78,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public void addLoadedChunk(LevelChunk chunk) {
-        this.loadedChunkMapSeqLock.acquireWrite();
-        try {
-            this.loadedChunkMap.put(chunk.coordinateKey, chunk);
-        } finally {
-            this.loadedChunkMapSeqLock.releaseWrite();
-        }
+        this.loadedChunkMap.put(chunk.coordinateKey, chunk);
 
         // rewrite cache if we have to
         // we do this since we also cache null chunks
@@ -96,12 +88,8 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public void removeLoadedChunk(LevelChunk chunk) {
-        this.loadedChunkMapSeqLock.acquireWrite();
-        try {
-            this.loadedChunkMap.remove(chunk.coordinateKey);
-        } finally {
-            this.loadedChunkMapSeqLock.releaseWrite();
-        }
+
+        this.loadedChunkMap.remove(chunk.coordinateKey);
 
         // rewrite cache if we have to
         // we do this since we also cache null chunks
@@ -371,23 +359,9 @@ public class ServerChunkCache extends ChunkSource {
             return this.getChunkAtIfLoadedMainThread(x, z);
         }
 
-        LevelChunk ret = null;
-        long readlock;
-        do {
-            readlock = this.loadedChunkMapSeqLock.acquireRead();
-            try {
-                ret = this.loadedChunkMap.get(k);
-            } catch (Throwable thr) {
-                if (thr instanceof ThreadDeath) {
-                    throw (ThreadDeath)thr;
-                }
-                // re-try, this means a CME occurred...
-                continue;
-            }
-        } while (!this.loadedChunkMapSeqLock.tryReleaseRead(readlock));
-
-        return ret;
+        return this.loadedChunkMap.get(k);
     }
+
     // Paper end
     // Paper start - async chunk io
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkAtAsynchronously(int x, int z, boolean gen, boolean isUrgent) {
@@ -416,11 +390,6 @@ public class ServerChunkCache extends ChunkSource {
     @Override
     public ChunkAccess getChunk(int x, int z, ChunkStatus leastStatus, boolean create) {
         final int x1 = x; final int z1 = z; // Paper - conflict on variable change
-        if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
-            return CompletableFuture.supplyAsync(() -> {
-                return this.getChunk(x, z, leastStatus, create);
-            }, this.mainThreadProcessor).join();
-        } else {
             // Paper start - optimise for loaded chunks
             LevelChunk ifLoaded = this.getChunkAtIfLoadedMainThread(x, z);
             if (ifLoaded != null) {
@@ -437,7 +406,7 @@ public class ServerChunkCache extends ChunkSource {
             // Paper - rewrite chunk system - there are no correct callbacks to remove items from cache in the new chunk system
 
             gameprofilerfiller.incrementCounter("getChunkCacheMiss");
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getChunkFutureMainThread(x, z, leastStatus, create, true); // Paper
+            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getChunkFuture(x, z, leastStatus, create); // Paper
             ServerChunkCache.MainThreadExecutor chunkproviderserver_b = this.mainThreadProcessor;
 
             Objects.requireNonNull(completablefuture);
@@ -462,7 +431,6 @@ public class ServerChunkCache extends ChunkSource {
             });
             this.storeInCache(k, ichunkaccess, leastStatus);
             return ichunkaccess;
-        }
     }
 
     @Nullable
@@ -791,7 +759,7 @@ public class ServerChunkCache extends ChunkSource {
             gameprofilerfiller.popPush("broadcast");
             this.level.timings.broadcastChunkUpdates.startTiming(); // Paper - timing
             if (!this.chunkMap.needsChangeBroadcasting.isEmpty()) {
-                ReferenceOpenHashSet<ChunkHolder> copy = this.chunkMap.needsChangeBroadcasting.clone();
+                HashSet<ChunkHolder> copy = new HashSet<>(this.chunkMap.needsChangeBroadcasting);
                 this.chunkMap.needsChangeBroadcasting.clear();
                 for (ChunkHolder holder : copy) {
                     holder.broadcastChanges(holder.getFullChunkNowUnchecked()); // LevelChunks are NEVER unloaded
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 2d5f013a8bb5d9441060f3b57511e89efe43c367..15fe06b98aed511fa001842b26920fe7d7b5e434 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -3,6 +3,7 @@ package net.minecraft.server.level;
 import com.google.common.annotations.VisibleForTesting;
 import co.aikar.timings.TimingHistory; // Paper
 import com.google.common.collect.Lists;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
@@ -31,7 +32,8 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
-import java.util.concurrent.Executor;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
 import java.util.function.Predicate;
@@ -78,13 +80,7 @@ import net.minecraft.util.Unit;
 import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.damagesource.DamageSource;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.LightningBolt;
-import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.Mob;
-import net.minecraft.world.entity.MobCategory;
-import net.minecraft.world.entity.ReputationEventHandler;
+import net.minecraft.world.entity.*;
 import net.minecraft.world.entity.ai.navigation.PathNavigation;
 import net.minecraft.world.entity.ai.village.ReputationEventType;
 import net.minecraft.world.entity.ai.village.poi.PoiManager;
@@ -125,12 +121,9 @@ import net.minecraft.world.level.chunk.storage.EntityStorage;
 import net.minecraft.world.level.dimension.BuiltinDimensionTypes;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.dimension.end.EndDragonFight;
-import net.minecraft.world.level.entity.EntityPersistentStorage;
-import net.minecraft.world.level.entity.EntityTickList;
 import net.minecraft.world.level.entity.EntityTypeTest;
 import net.minecraft.world.level.entity.LevelCallback;
 import net.minecraft.world.level.entity.LevelEntityGetter;
-import net.minecraft.world.level.entity.PersistentEntitySectionManager;
 import net.minecraft.world.level.gameevent.DynamicGameEventListener;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.gameevent.GameEventListener;
@@ -171,6 +164,8 @@ import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
+import org.spigotmc.ActivationRange;
+
 
 public class ServerLevel extends Level implements WorldGenLevel {
 
@@ -190,20 +185,20 @@ public class ServerLevel extends Level implements WorldGenLevel {
     public final ServerChunkCache chunkSource;
     private final MinecraftServer server;
     public final PrimaryLevelData serverLevelData; // CraftBukkit - type
-    final EntityTickList entityTickList;
+    final CopyOnWriteArrayList<Entity> entityTickList;
     //public final PersistentEntitySectionManager<Entity> entityManager; // Paper - rewrite chunk system
     public boolean noSave;
     private final SleepStatus sleepStatus;
-    private int emptyTime;
+    //private int emptyTime;
     private final PortalForcer portalForcer;
     private final LevelTicks<Block> blockTicks;
     private final LevelTicks<Fluid> fluidTicks;
-    final Set<Mob> navigatingMobs;
+    final CopyOnWriteArraySet<Mob> navigatingMobs;
     volatile boolean isUpdatingNavigations;
     protected final Raids raids;
     private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents;
     private final List<BlockEventData> blockEventsToReschedule;
-    private List<GameEvent.Message> gameEventMessages;
+    private AtomicReference<ConcurrentLinkedDeque<GameEvent.Message>> gameEventMessages;
     private boolean handlingTick;
     private final List<CustomSpawner> customSpawners;
     @Nullable
@@ -530,14 +525,14 @@ public class ServerLevel extends Level implements WorldGenLevel {
         this.convertable = convertable_conversionsession;
         this.uuid = WorldUUID.getUUID(convertable_conversionsession.levelDirectory.path().toFile());
         // CraftBukkit end
-        this.players = Lists.newArrayList();
-        this.entityTickList = new EntityTickList();
+        this.players = new CopyOnWriteArrayList<>();
+        this.entityTickList = Lists.newCopyOnWriteArrayList();
         this.blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
         this.fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
-        this.navigatingMobs = new ObjectOpenHashSet();
+        this.navigatingMobs = new CopyOnWriteArraySet<>();
         this.blockEvents = new ObjectLinkedOpenHashSet();
         this.blockEventsToReschedule = new ArrayList(64);
-        this.gameEventMessages = new ArrayList();
+        this.gameEventMessages = new AtomicReference<>(new ConcurrentLinkedDeque<>());
         this.dragonParts = new Int2ObjectOpenHashMap();
         this.tickTime = flag1;
         this.server = minecraftserver;
@@ -623,80 +618,102 @@ public class ServerLevel extends Level implements WorldGenLevel {
         return this.structureManager;
     }
 
+    private final ExecutorService executor = Executors.newFixedThreadPool(8, new ThreadFactoryBuilder().setNameFormat("Server Level - %1$d").build()); // Paper - rewrite chunk system
+
     public void tick(BooleanSupplier shouldKeepTicking) {
-        // Paper start - optimise checkDespawn
-        this.playersAffectingSpawning.clear();
-        for (ServerPlayer player : this.players) {
-            if (net.minecraft.world.entity.EntitySelector.affectsSpawning.test(player)) {
-                this.playersAffectingSpawning.add(player);
+
+       // final Future<?> future = executor.submit(() -> {
+            // Paper start - optimise checkDespawn
+            this.playersAffectingSpawning.clear();
+            for (ServerPlayer player : this.players) {
+                if (EntitySelector.affectsSpawning.test(player)) {
+                    this.playersAffectingSpawning.add(player);
+                }
             }
-        }
-        // Paper end - optimise checkDespawn
-        ProfilerFiller gameprofilerfiller = this.getProfiler();
+            // Paper end - optimise checkDespawn
+            ProfilerFiller gameprofilerfiller = this.getProfiler();
 
-        this.handlingTick = true;
-        gameprofilerfiller.push("world border");
-        this.getWorldBorder().tick();
-        gameprofilerfiller.popPush("weather");
-        this.advanceWeatherCycle();
-        int i = this.getGameRules().getInt(GameRules.RULE_PLAYERS_SLEEPING_PERCENTAGE);
-        long j;
+            this.handlingTick = true;
+            gameprofilerfiller.push("world border");
+            this.getWorldBorder().tick();
+            gameprofilerfiller.popPush("weather");
+            this.advanceWeatherCycle();
+            int i = this.getGameRules().getInt(GameRules.RULE_PLAYERS_SLEEPING_PERCENTAGE);
+            long j;
+
+            if (this.sleepStatus.areEnoughSleeping(i) && this.sleepStatus.areEnoughDeepSleeping(i, this.players)) {
+                // CraftBukkit start
+                j = this.levelData.getDayTime() + 24000L;
+                TimeSkipEvent event = new TimeSkipEvent(this.getWorld(), TimeSkipEvent.SkipReason.NIGHT_SKIP, (j - j % 24000L) - this.getDayTime());
+                if (this.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)) {
+                    getCraftServer().getPluginManager().callEvent(event);
+                    if (!event.isCancelled()) {
+                        this.setDayTime(this.getDayTime() + event.getSkipAmount());
+                    }
+                }
 
-        if (this.sleepStatus.areEnoughSleeping(i) && this.sleepStatus.areEnoughDeepSleeping(i, this.players)) {
-            // CraftBukkit start
-            j = this.levelData.getDayTime() + 24000L;
-            TimeSkipEvent event = new TimeSkipEvent(this.getWorld(), TimeSkipEvent.SkipReason.NIGHT_SKIP, (j - j % 24000L) - this.getDayTime());
-            if (this.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)) {
-                getCraftServer().getPluginManager().callEvent(event);
                 if (!event.isCancelled()) {
-                    this.setDayTime(this.getDayTime() + event.getSkipAmount());
+                    this.wakeUpAllPlayers();
+                }
+                // CraftBukkit end
+                if (this.getGameRules().getBoolean(GameRules.RULE_WEATHER_CYCLE) && this.isRaining()) {
+                    this.resetWeatherCycle();
                 }
             }
 
-            if (!event.isCancelled()) {
-                this.wakeUpAllPlayers();
-            }
-            // CraftBukkit end
-            if (this.getGameRules().getBoolean(GameRules.RULE_WEATHER_CYCLE) && this.isRaining()) {
-                this.resetWeatherCycle();
+            this.updateSkyBrightness();
+            this.tickTime();
+            gameprofilerfiller.popPush("tickPending");
+            timings.scheduledBlocks.startTiming(); // Paper
+            if (!this.isDebug()) {
+                j = this.getGameTime();
+                gameprofilerfiller.push("blockTicks");
+                this.blockTicks.tick(j, 65536, this::tickBlock);
+                gameprofilerfiller.popPush("fluidTicks");
+                this.fluidTicks.tick(j, 65536, this::tickFluid);
+                gameprofilerfiller.pop();
             }
-        }
-
-        this.updateSkyBrightness();
-        this.tickTime();
-        gameprofilerfiller.popPush("tickPending");
-        timings.scheduledBlocks.startTiming(); // Paper
-        if (!this.isDebug()) {
-            j = this.getGameTime();
-            gameprofilerfiller.push("blockTicks");
-            this.blockTicks.tick(j, 65536, this::tickBlock);
-            gameprofilerfiller.popPush("fluidTicks");
-            this.fluidTicks.tick(j, 65536, this::tickFluid);
+            timings.scheduledBlocks.stopTiming(); // Paper
+
+            gameprofilerfiller.popPush("raid");
+            this.timings.raids.startTiming(); // Paper - timings
+            this.raids.tick();
+            this.timings.raids.stopTiming(); // Paper - timings
+            gameprofilerfiller.popPush("chunkSource");
+            this.timings.chunkProviderTick.startTiming(); // Paper - timings
+            this.getChunkSource().tick(shouldKeepTicking, true);
+            this.timings.chunkProviderTick.stopTiming(); // Paper - timings
+            gameprofilerfiller.popPush("blockEvents");
+            timings.doSounds.startTiming(); // Spigot
+            this.runBlockEvents();
+            timings.doSounds.stopTiming(); // Spigot
+            this.handlingTick = false;
             gameprofilerfiller.pop();
-        }
-        timings.scheduledBlocks.stopTiming(); // Paper
-
-        gameprofilerfiller.popPush("raid");
-        this.timings.raids.startTiming(); // Paper - timings
-        this.raids.tick();
-        this.timings.raids.stopTiming(); // Paper - timings
-        gameprofilerfiller.popPush("chunkSource");
-        this.timings.chunkProviderTick.startTiming(); // Paper - timings
-        this.getChunkSource().tick(shouldKeepTicking, true);
-        this.timings.chunkProviderTick.stopTiming(); // Paper - timings
-        gameprofilerfiller.popPush("blockEvents");
-        timings.doSounds.startTiming(); // Spigot
-        this.runBlockEvents();
-        timings.doSounds.stopTiming(); // Spigot
-        this.handlingTick = false;
+
+        tickEntities(gameprofilerfiller);
+
+        //this.entityManager.tick(); // Paper - rewrite chunk system
+        gameprofilerfiller.popPush("gameEvents");
+
+        this.sendGameEvents();
         gameprofilerfiller.pop();
-        boolean flag = true || !this.players.isEmpty() || !this.getForcedChunks().isEmpty(); // CraftBukkit - this prevents entity cleanup, other issues on servers with no players
+        //});
+
+        /*
+        try {
+            future.get();
+            System.out.println("Done");
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        } catch (ExecutionException e) {
+            throw new RuntimeException(e);
+        }*/
+
+    }
 
-        if (flag) {
-            this.resetEmptyTime();
-        }
 
-        if (flag || this.emptyTime++ < 300) {
+    public void tickEntities(final ProfilerFiller gameprofilerfiller) {
+
             gameprofilerfiller.push("entities");
             timings.tickEntities.startTiming(); // Spigot
             if (this.dragonFight != null) {
@@ -705,9 +722,11 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 gameprofilerfiller.pop();
             }
 
-            org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+            ActivationRange.activateEntities(this); // Spigot
             timings.entityTick.startTiming(); // Spigot
-            this.entityTickList.forEach((entity) -> {
+
+
+            entityTickList.parallelStream().forEach((entity) -> {
                 if (!entity.isRemoved()) {
                     if (false && this.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
                         entity.discard();
@@ -727,7 +746,8 @@ public class ServerLevel extends Level implements WorldGenLevel {
                             }
 
                             gameprofilerfiller.push("tick");
-                            this.guardEntityTick(this::tickNonPassenger, entity);
+
+                            tickNonPassenger(entity);
                             gameprofilerfiller.pop();
                         }
                     }
@@ -737,15 +757,13 @@ public class ServerLevel extends Level implements WorldGenLevel {
             timings.tickEntities.stopTiming(); // Spigot
             gameprofilerfiller.pop();
             this.tickBlockEntities();
-        }
 
         gameprofilerfiller.push("entityManagement");
-        //this.entityManager.tick(); // Paper - rewrite chunk system
-        gameprofilerfiller.popPush("gameEvents");
-        this.sendGameEvents();
-        gameprofilerfiller.pop();
     }
 
+
+
+
     @Override
     public boolean shouldTickBlocksAt(long chunkPos) {
         // Paper start - replace player chunk loader system
@@ -1119,9 +1137,11 @@ public class ServerLevel extends Level implements WorldGenLevel {
         // CraftBukkit end
     }
 
+    /*
     public void resetEmptyTime() {
         this.emptyTime = 0;
     }
+    */
 
     private void tickFluid(BlockPos pos, Fluid fluid) {
         FluidState fluid1 = this.getFluidState(pos);
@@ -1624,7 +1644,12 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 if (chunk != null) {
                     for (int j2 = k; j2 <= j1; ++j2) {
                         flag |= chunk.getEventDispatcher(j2).walkListeners(event, emitterPos, emitter, (gameeventlistener, vec3d1) -> {
-                            (gameeventlistener.handleEventsImmediately() ? list : this.gameEventMessages).add(new GameEvent.Message(event, emitterPos, emitter, gameeventlistener, vec3d1));
+                            if (gameeventlistener.handleEventsImmediately()) {
+                                list.add(new GameEvent.Message(event, emitterPos, emitter, gameeventlistener, vec3d1));
+                            }
+                            else {
+                                this.gameEventMessages.get().add(new GameEvent.Message(event, emitterPos, emitter, gameeventlistener, vec3d1));
+                            }
                         });
                     }
                 }
@@ -1642,11 +1667,12 @@ public class ServerLevel extends Level implements WorldGenLevel {
     }
 
     private void sendGameEvents() {
-        if (!this.gameEventMessages.isEmpty()) {
-            List<GameEvent.Message> list = this.gameEventMessages;
 
-            this.gameEventMessages = new ArrayList();
-            this.handleGameEventMessagesInQueue(list);
+        final ConcurrentLinkedDeque<GameEvent.Message> messages = this.gameEventMessages.get();
+
+        if (!messages.isEmpty()) {
+            this.gameEventMessages = new AtomicReference<>(new ConcurrentLinkedDeque<>());
+            this.handleGameEventMessagesInQueue(new ArrayList<>(messages));
         }
     }
 
@@ -1665,11 +1691,14 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     @Override
     public void sendBlockUpdated(BlockPos pos, BlockState oldState, BlockState newState, int flags) {
+
+        /*
         if (this.isUpdatingNavigations) {
             String s = "recursive call to sendBlockUpdated";
 
             Util.logAndPauseIfInIde("recursive call to sendBlockUpdated", new IllegalStateException("recursive call to sendBlockUpdated"));
         }
+        */
 
         this.getChunkSource().blockChanged(pos);
         if(this.paperConfig().misc.updatePathfindingOnBlockUpdate) { // Paper - option to disable pathfinding updates
@@ -1719,7 +1748,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     @Override
     public void updateNeighborsAt(BlockPos pos, Block sourceBlock) {
-        if (captureBlockStates) { return; } // Paper - Cancel all physics during placement
+        if (captureBlockStates.get()) { return; } // Paper - Cancel all physics during placement
         this.neighborUpdater.updateNeighborsAtExceptFromFacing(pos, sourceBlock, null);
     }
 
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index f92c93578bd85511c664b09c80016f385e10e0dd..89ada7bd845dcef51a6d74d933ff25a066b730ac 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -145,6 +145,7 @@ import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.portal.PortalInfo;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.slf4j.Logger;
 import net.minecraft.world.Container;
 import net.minecraft.world.InteractionHand;
@@ -1011,7 +1012,7 @@ public class ServerPlayer extends Player {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.isInvulnerableTo(source)) {
             return false;
         } else {
@@ -1039,7 +1040,7 @@ public class ServerPlayer extends Player {
                 // Paper start - cancellable death events
                 //return super.hurt(source, amount);
                 this.queueHealthUpdatePacket = true;
-                boolean damaged = super.hurt(source, amount);
+                boolean damaged = super.hurt(source, damagerEntity, damagerBlock, amount);
                 this.queueHealthUpdatePacket = false;
                 if (this.queuedHealthUpdatePacket != null) {
                     this.connection.send(this.queuedHealthUpdatePacket);
@@ -2320,7 +2321,7 @@ public class ServerPlayer extends Player {
     }
 
     public boolean shouldFilterMessageTo(ServerPlayer player) {
-        return player == this ? false : this.textFilteringEnabled || player.textFilteringEnabled;
+        return player != this && (this.textFilteringEnabled || player.textFilteringEnabled);
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
index 2fde6d5dbc6229554c42020c80962b163cdee5ba..63c239f39b630438aae21cb9f4f14f80537c74f3 100644
--- a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
+++ b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
@@ -4,6 +4,7 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Queues;
 import com.mojang.logging.LogUtils;
 import java.util.List;
+import java.util.NoSuchElementException;
 import java.util.Queue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
@@ -111,8 +112,7 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     }
 
     public void runAllTasks() {
-        while(this.pollTask()) {
-        }
+        while(this.pollTask()) {}
 
     }
 
@@ -123,12 +123,17 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
         } else if (this.blockingCount == 0 && !this.shouldRun(runnable)) {
             return false;
         } else {
-            this.doRunTask(this.pendingRunnables.remove());
+            try {
+                this.doRunTask(this.pendingRunnables.remove());
+            } catch (NoSuchElementException ex) {
+                return false;
+            }
             return true;
         }
     }
 
     public void managedBlock(BooleanSupplier stopCondition) {
+
         ++this.blockingCount;
 
         try {
diff --git a/src/main/java/net/minecraft/world/damagesource/CombatTracker.java b/src/main/java/net/minecraft/world/damagesource/CombatTracker.java
index ba96589aab8be0a90144f73f7779769146c7a37e..57b7db2799dfcfe81b18ca802cdab3a524a002e8 100644
--- a/src/main/java/net/minecraft/world/damagesource/CombatTracker.java
+++ b/src/main/java/net/minecraft/world/damagesource/CombatTracker.java
@@ -1,9 +1,5 @@
 package net.minecraft.world.damagesource;
 
-import com.google.common.collect.Lists;
-import java.util.List;
-import java.util.Optional;
-import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.network.chat.Component;
 import net.minecraft.tags.BlockTags;
@@ -14,10 +10,15 @@ import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 
+import javax.annotation.Nullable;
+import java.util.List;
+import java.util.Optional;
+import java.util.concurrent.CopyOnWriteArrayList;
+
 public class CombatTracker {
     public static final int RESET_DAMAGE_STATUS_TIME = 100;
     public static final int RESET_COMBAT_STATUS_TIME = 300;
-    private final List<CombatEntry> entries = Lists.newArrayList();
+    private final List<CombatEntry> entries = new CopyOnWriteArrayList<>();
     private final LivingEntity mob;
     private int lastDamageTime;
     private int combatStartTime;
@@ -137,7 +138,7 @@ public class CombatTracker {
             }
         }
 
-        return (LivingEntity)(player != null && g >= f / 3.0F ? player : livingEntity);
+        return player != null && g >= f / 3.0F ? player : livingEntity;
     }
 
     @Nullable
diff --git a/src/main/java/net/minecraft/world/effect/MobEffect.java b/src/main/java/net/minecraft/world/effect/MobEffect.java
index 140aaaad1cbf8ee439a89d423ce64b5fa1fa129e..11b195a4c4977e3edd0c5288997fd3ef8d354311 100644
--- a/src/main/java/net/minecraft/world/effect/MobEffect.java
+++ b/src/main/java/net/minecraft/world/effect/MobEffect.java
@@ -65,10 +65,10 @@ public class MobEffect {
             }
         } else if (this == MobEffects.POISON) {
             if (entity.getHealth() > 1.0F) {
-                entity.hurt(CraftEventFactory.POISON, 1.0F);  // CraftBukkit - DamageSource.MAGIC -> CraftEventFactory.POISON
+                entity.hurt(CraftEventFactory.POISON, null, null, 1.0F);  // CraftBukkit - DamageSource.MAGIC -> CraftEventFactory.POISON
             }
         } else if (this == MobEffects.WITHER) {
-            entity.hurt(DamageSource.WITHER, 1.0F);
+            entity.hurt(DamageSource.WITHER, null, null, 1.0F);
         } else if (this == MobEffects.HUNGER && entity instanceof Player) {
             ((Player) entity).causeFoodExhaustion(0.005F * (float) (amplifier + 1), org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.HUNGER_EFFECT); // CraftBukkit - EntityExhaustionEvent
         } else if (this == MobEffects.SATURATION && entity instanceof Player) {
@@ -88,7 +88,7 @@ public class MobEffect {
             }
         } else if ((this != MobEffects.HEAL || entity.isInvertedHealAndHarm()) && (this != MobEffects.HARM || !entity.isInvertedHealAndHarm())) {
             if (this == MobEffects.HARM && !entity.isInvertedHealAndHarm() || this == MobEffects.HEAL && entity.isInvertedHealAndHarm()) {
-                entity.hurt(DamageSource.MAGIC, (float) (6 << amplifier));
+                entity.hurt(DamageSource.MAGIC, null, null, (float) (6 << amplifier));
             }
         } else {
             entity.heal((float) Math.max(4 << amplifier, 0), RegainReason.MAGIC); // CraftBukkit
@@ -105,9 +105,9 @@ public class MobEffect {
             } else {
                 j = (int) (proximity * (double) (6 << amplifier) + 0.5D);
                 if (source == null) {
-                    target.hurt(DamageSource.MAGIC, (float) j);
+                    target.hurt(DamageSource.MAGIC, null, null, (float) j);
                 } else {
-                    target.hurt(DamageSource.indirectMagic(source, attacker), (float) j);
+                    target.hurt(DamageSource.indirectMagic(source, attacker), attacker, null, (float) j);
                 }
             }
         } else {
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 7ebd2713829554df02590226d3e8207612c362db..80a408f86ef6a25466c9f89b033488b5e2bf85d0 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -19,6 +19,7 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BiConsumer;
 import java.util.function.Predicate;
@@ -45,7 +46,6 @@ import net.minecraft.nbt.FloatTag;
 import net.minecraft.nbt.ListTag;
 import net.minecraft.nbt.StringTag;
 import net.minecraft.network.chat.ChatSender;
-import net.minecraft.network.chat.ClickEvent;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.HoverEvent;
 import net.minecraft.network.chat.MutableComponent;
@@ -125,6 +125,7 @@ import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.scores.PlayerTeam;
 import net.minecraft.world.scores.Team;
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.slf4j.Logger;
 import org.bukkit.Bukkit;
 import org.bukkit.Location;
@@ -476,7 +477,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public int sectionY = Integer.MIN_VALUE;
     public int sectionZ = Integer.MIN_VALUE;
 
-    public boolean updatingSectionStatus = false;
+    public AtomicBoolean updatingSectionStatus = new AtomicBoolean(false);
     // Paper end
     // Paper start - optimise entity tracking
     final org.spigotmc.TrackingRange.TrackingRangeType trackingRangeType = org.spigotmc.TrackingRange.getTrackingRangeType(this);
@@ -821,7 +822,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
                 }
             } else {
                 if (this.remainingFireTicks % 20 == 0 && !this.isInLava()) {
-                    this.hurt(DamageSource.ON_FIRE, 1.0F);
+                    this.hurt(DamageSource.ON_FIRE, null, null, 1.0F);
                 }
 
                 this.setRemainingFireTicks(this.remainingFireTicks - 1);
@@ -902,11 +903,10 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
                 // This will be called every single tick the entity is in lava, so don't throw an event
                 this.setSecondsOnFire(15, false);
             }
-            CraftEventFactory.blockDamage = (this.lastLavaContact) == null ? null : org.bukkit.craftbukkit.block.CraftBlock.at(level, lastLavaContact);
-            if (this.hurt(DamageSource.LAVA, 4.0F)) {
+            final CraftBlock block = (this.lastLavaContact) == null ? null : org.bukkit.craftbukkit.block.CraftBlock.at(level, lastLavaContact);
+            if (this.hurt(DamageSource.LAVA, null, block, 4.0F)) {
                 this.playSound(SoundEvents.GENERIC_BURN, 0.4F, 2.0F + this.random.nextFloat() * 0.4F);
             }
-            CraftEventFactory.blockDamage = null;
             // CraftBukkit end - we also don't throw an event unless the object in lava is living, to save on some event calls
 
         }
@@ -1633,14 +1633,14 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         return this.getType().fireImmune();
     }
 
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
+    public boolean causeFallDamage(float fallDistance, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
         if (this.isVehicle()) {
             Iterator iterator = this.getPassengers().iterator();
 
             while (iterator.hasNext()) {
                 Entity entity = (Entity) iterator.next();
 
-                entity.causeFallDamage(fallDistance, damageMultiplier, damageSource);
+                entity.causeFallDamage(fallDistance, damagerEntity, damagerBlock, damageMultiplier, damageSource);
             }
         }
 
@@ -1977,7 +1977,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         this.hurtMarked = true;
     }
 
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.isInvulnerableTo(source)) {
             return false;
         } else {
@@ -2700,8 +2700,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         }
         // Paper end
         if (entity == this) throw new IllegalArgumentException("Entities cannot become a passenger of themselves"); // Paper - issue 572
-        if (entity.getVehicle() != this) {
-            throw new IllegalStateException("Use x.startRiding(y), not y.addPassenger(x)");
+        if (entity.vehicle != this) {
+            return false;
         } else {
             // CraftBukkit start
             com.google.common.base.Preconditions.checkState(!entity.passengers.contains(this), "Circular entity riding! %s %s", this, entity);
@@ -3157,11 +3157,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         if (this.fireImmune()) {
             return;
         }
-        CraftEventFactory.entityDamage = lightning;
-        if (!this.hurt(DamageSource.LIGHTNING_BOLT, 5.0F)) {
-            CraftEventFactory.entityDamage = null;
-            return;
-        }
+        
+        this.hurt(DamageSource.LIGHTNING_BOLT, lightning, null, 5.0F);
         // CraftBukkit end
     }
 
@@ -3406,8 +3403,6 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
 
                 this.removeAfterChangingDimensions();
                 this.level.getProfiler().pop();
-                ((ServerLevel) this.level).resetEmptyTime();
-                worldserver.resetEmptyTime();
                 this.level.getProfiler().pop();
                 return entity;
             }
@@ -4247,7 +4242,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         // Paper end - block invalid positions
         // Paper end
         // Paper start - rewrite chunk system
-        if (this.updatingSectionStatus) {
+        if (this.updatingSectionStatus.get()) {
             LOGGER.error("Refusing to update position for entity " + this + " to position " + new Vec3(x, y, z) + " since it is processing a section status update", new Throwable());
             return;
         }
@@ -4367,7 +4362,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public final void setRemoved(Entity.RemovalReason reason) {
         // Paper start - rewrite chunk system
         io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot remove entity off-main");
-        if (this.updatingSectionStatus) {
+        if (this.updatingSectionStatus.get()) {
             LOGGER.warn("Entity " + this + " is currently prevented from being added/removed to world since it is processing section status updates", new Throwable());
             return;
         }
diff --git a/src/main/java/net/minecraft/world/entity/ExperienceOrb.java b/src/main/java/net/minecraft/world/entity/ExperienceOrb.java
index b29a355a421acb45bbf02dcd3ede2a43bef1b07b..bf503829500c546455fff7df55bdfae4ad7fa1d3 100644
--- a/src/main/java/net/minecraft/world/entity/ExperienceOrb.java
+++ b/src/main/java/net/minecraft/world/entity/ExperienceOrb.java
@@ -20,9 +20,12 @@ import net.minecraft.world.level.entity.EntityTypeTest;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 // CraftBukkit start
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.entity.EntityTargetLivingEntityEvent;
 import org.bukkit.event.entity.EntityTargetEvent;
+
+import javax.annotation.Nullable;
 // CraftBukkit end
 
 public class ExperienceOrb extends Entity {
@@ -143,21 +146,25 @@ public class ExperienceOrb extends Entity {
 
         // CraftBukkit start
         boolean cancelled = false;
+
+        Player thisTickFollowingPlayer = prevTarget;
+
         if (this.followingPlayer != prevTarget) {
             EntityTargetLivingEntityEvent event = CraftEventFactory.callEntityTargetLivingEvent(this, followingPlayer, (this.followingPlayer != null) ? EntityTargetEvent.TargetReason.CLOSEST_PLAYER : EntityTargetEvent.TargetReason.FORGOT_TARGET);
             LivingEntity target = (event.getTarget() == null) ? null : ((org.bukkit.craftbukkit.entity.CraftLivingEntity) event.getTarget()).getHandle();
             cancelled = event.isCancelled();
 
-            if (cancelled) {
-                this.followingPlayer = prevTarget;
-            } else {
-                this.followingPlayer = (target instanceof Player) ? (Player) target : null;
+            if (!cancelled) {
+               thisTickFollowingPlayer = (target instanceof Player) ? (Player) target : null;
             }
+
+            this.followingPlayer = thisTickFollowingPlayer;
         }
 
-        if (!cancelled) {
+        if (!cancelled && thisTickFollowingPlayer != null) {
+
             // CraftBukkit end
-            Vec3 vec3d = new Vec3(this.followingPlayer.getX() - this.getX(), this.followingPlayer.getY() + (double) this.followingPlayer.getEyeHeight() / 2.0D - this.getY(), this.followingPlayer.getZ() - this.getZ());
+            Vec3 vec3d = new Vec3(thisTickFollowingPlayer.getX() - this.getX(), thisTickFollowingPlayer.getY() + (double) thisTickFollowingPlayer.getEyeHeight() / 2.0D - this.getY(), thisTickFollowingPlayer.getZ() - this.getZ());
             double d0 = vec3d.lengthSqr();
 
             if (d0 < 64.0D) {
@@ -266,7 +273,7 @@ public class ExperienceOrb extends Entity {
     protected void doWaterSplashEffect() {}
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.isInvulnerableTo(source)) {
             return false;
         } else if (this.level.isClientSide) {
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 2444bc2d711cfdce05ff82bf1ceed837b870b455..d808d1764dd1977e24beaac44ba14986219e8140 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -12,6 +12,7 @@ import com.mojang.serialization.DataResult;
 import com.mojang.serialization.Dynamic;
 
 import java.util.*;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
 import net.minecraft.BlockUtil;
@@ -115,6 +116,7 @@ import net.minecraft.world.phys.EntityHitResult;
 import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.scores.PlayerTeam;
+import org.bukkit.block.Block;
 import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 
@@ -135,7 +137,6 @@ import org.bukkit.event.entity.EntityTeleportEvent;
 import org.bukkit.event.player.PlayerItemConsumeEvent;
 // CraftBukkit end
 
-import co.aikar.timings.MinecraftTimings; // Paper
 
 public abstract class LivingEntity extends Entity {
 
@@ -250,7 +251,7 @@ public abstract class LivingEntity extends Entity {
     // CraftBukkit start
     public int expToDrop;
     public boolean forceDrops;
-    public ArrayList<org.bukkit.inventory.ItemStack> drops = new ArrayList<org.bukkit.inventory.ItemStack>();
+    public List<org.bukkit.inventory.ItemStack> drops = new CopyOnWriteArrayList<org.bukkit.inventory.ItemStack>();
     public final org.bukkit.craftbukkit.attribute.CraftAttributeMap craftAttributes;
     public boolean collides = true;
     public Set<UUID> collidableExemptions = new HashSet<>();
@@ -311,7 +312,7 @@ public abstract class LivingEntity extends Entity {
 
     @Override
     public void kill() {
-        this.hurt(DamageSource.OUT_OF_WORLD, Float.MAX_VALUE);
+        this.hurt(DamageSource.OUT_OF_WORLD, null, null, Float.MAX_VALUE);
     }
 
     public boolean canAttackType(EntityType<?> type) {
@@ -393,7 +394,7 @@ public abstract class LivingEntity extends Entity {
             boolean flag = this instanceof net.minecraft.world.entity.player.Player;
 
             if (this.isInWall()) {
-                this.hurt(DamageSource.IN_WALL, 1.0F);
+                this.hurt(DamageSource.IN_WALL, null, null, 1.0F);
             } else if (flag && !this.level.getWorldBorder().isWithinBounds(this.getBoundingBox())) {
                 double d0 = this.level.getWorldBorder().getDistanceToBorder(this) + this.level.getWorldBorder().getDamageSafeZone();
 
@@ -401,7 +402,7 @@ public abstract class LivingEntity extends Entity {
                     double d1 = this.level.getWorldBorder().getDamagePerBlock();
 
                     if (d1 > 0.0D) {
-                        this.hurt(DamageSource.IN_WALL, (float) Math.max(1, Mth.floor(-d0 * d1)));
+                        this.hurt(DamageSource.IN_WALL, null, null, (float) Math.max(1, Mth.floor(-d0 * d1)));
                     }
                 }
             }
@@ -423,7 +424,7 @@ public abstract class LivingEntity extends Entity {
                             this.level.addParticle(ParticleTypes.BUBBLE, this.getX() + d2, this.getY() + d3, this.getZ() + d4, vec3d.x, vec3d.y, vec3d.z);
                         }
 
-                        this.hurt(DamageSource.DROWN, 2.0F);
+                        this.hurt(DamageSource.DROWN, null, null, 2.0F);
                     }
                 }
 
@@ -1307,7 +1308,7 @@ public abstract class LivingEntity extends Entity {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.isInvulnerableTo(source)) {
             return false;
         } else if (this.level.isClientSide) {
@@ -1332,10 +1333,8 @@ public abstract class LivingEntity extends Entity {
                 f2 = amount;
                 amount = 0.0F;
                 if (!source.isProjectile()) {
-                    Entity entity = source.getDirectEntity();
-
-                    if (entity instanceof LivingEntity && entity.distanceToSqr(this) <= (200.0D * 200.0D)) { // Paper
-                        this.blockUsingShield((LivingEntity) entity);
+                    if (damagerEntity instanceof LivingEntity && damagerEntity.distanceToSqr(this) <= (200.0D * 200.0D)) { // Paper
+                        this.blockUsingShield((LivingEntity) damagerEntity);
                     }
                 }
 
@@ -1351,7 +1350,7 @@ public abstract class LivingEntity extends Entity {
                 }
 
                 // CraftBukkit start
-                if (!this.damageEntity0(source, amount - this.lastHurt)) {
+                if (!this.damageEntity0(source, damagerEntity, damagerBlock, amount - this.lastHurt)) {
                     return false;
                 }
                 // CraftBukkit end
@@ -1359,7 +1358,7 @@ public abstract class LivingEntity extends Entity {
                 flag1 = false;
             } else {
                 // CraftBukkit start
-                if (!this.damageEntity0(source, amount)) {
+                if (!this.damageEntity0(source, damagerEntity, damagerBlock, amount)) {
                     return false;
                 }
                 this.lastHurt = amount;
@@ -1906,6 +1905,10 @@ public abstract class LivingEntity extends Entity {
             BlockPos blockposition = this.blockPosition();
             BlockState iblockdata = this.getFeetBlockState();
 
+            if (iblockdata == null) {
+                return false;
+            }
+
             if (iblockdata.is(BlockTags.CLIMBABLE)) {
                 this.lastClimbablePos = Optional.of(blockposition);
                 return true;
@@ -1936,13 +1939,13 @@ public abstract class LivingEntity extends Entity {
     }
 
     @Override
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
-        boolean flag = super.causeFallDamage(fallDistance, damageMultiplier, damageSource);
+    public boolean causeFallDamage(float fallDistance, final @Nullable Entity damagerEntity, final Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
+        boolean flag = super.causeFallDamage(fallDistance, damagerEntity, damagerBlock, damageMultiplier, damageSource);
         int i = this.calculateFallDamage(fallDistance, damageMultiplier);
 
         if (i > 0) {
             // CraftBukkit start
-            if (!this.hurt(damageSource, (float) i)) {
+            if (!this.hurt(damageSource, damagerEntity, damagerBlock, (float) i)) {
                 return true;
             }
             // CraftBukkit end
@@ -2045,7 +2048,7 @@ public abstract class LivingEntity extends Entity {
     }
 
     // CraftBukkit start
-    protected boolean damageEntity0(final DamageSource damagesource, float f) { // void -> boolean, add final
+    protected boolean damageEntity0(final DamageSource damagesource, @Nullable Entity damagerEntity, @Nullable Block damagerBlock, float f) { // void -> boolean, add final
        if (!this.isInvulnerableTo(damagesource)) {
             final boolean human = this instanceof net.minecraft.world.entity.player.Player;
             float originalDamage = f;
@@ -2112,10 +2115,11 @@ public abstract class LivingEntity extends Entity {
             };
             float absorptionModifier = absorption.apply(Double.valueOf(f)).floatValue();
 
-            EntityDamageEvent event = CraftEventFactory.handleLivingEntityDamageEvent(this, damagesource, originalDamage, hardHatModifier, blockingModifier, armorModifier, resistanceModifier, magicModifier, absorptionModifier, hardHat, blocking, armor, resistance, magic, absorption);
-            if (damagesource.getEntity() instanceof net.minecraft.world.entity.player.Player) {
+           EntityDamageEvent event = CraftEventFactory.handleLivingEntityDamageEvent(this, damagerEntity, damagerBlock, damagesource, originalDamage, hardHatModifier, blockingModifier, armorModifier, resistanceModifier, magicModifier, absorptionModifier, hardHat, blocking, armor, resistance, magic, absorption);
+
+            if (damagerEntity instanceof net.minecraft.world.entity.player.Player) {
                 // Paper start - PlayerAttackEntityCooldownResetEvent
-                if (damagesource.getEntity() instanceof ServerPlayer) {
+                if (damagerEntity instanceof ServerPlayer) {
                     ServerPlayer player = (ServerPlayer) damagesource.getEntity();
                     if (new com.destroystokyo.paper.event.player.PlayerAttackEntityCooldownResetEvent(player.getBukkitEntity(), this.getBukkitEntity(), player.getAttackStrengthScale(0F)).callEvent()) {
                         player.resetAttackStrengthTicker();
@@ -2325,7 +2329,7 @@ public abstract class LivingEntity extends Entity {
                     this.playSound(soundeffect, this.getSoundVolume(), (this.random.nextFloat() - this.random.nextFloat()) * 0.2F + 1.0F);
                 }
 
-                this.hurt(DamageSource.GENERIC, 0.0F);
+                this.hurt(DamageSource.GENERIC, null, null, 0.0F);
                 this.lastDamageSource = damagesource;
                 this.lastDamageStamp = this.level.getGameTime();
                 break;
@@ -2456,7 +2460,7 @@ public abstract class LivingEntity extends Entity {
 
     @Override
     protected void outOfWorld() {
-        this.hurt(DamageSource.OUT_OF_WORLD, 4.0F);
+        this.hurt(DamageSource.OUT_OF_WORLD, null, null, 4.0F);
     }
 
     protected void updateSwingTime() {
@@ -2803,7 +2807,7 @@ public abstract class LivingEntity extends Entity {
 
                     if (f3 > 0.0F) {
                         this.playSound(this.getFallDamageSound((int) f3), 1.0F, 1.0F);
-                        this.hurt(DamageSource.FLY_INTO_WALL, f3);
+                        this.hurt(DamageSource.FLY_INTO_WALL, null, null, f3);
                     }
                 }
 
@@ -3363,7 +3367,7 @@ public abstract class LivingEntity extends Entity {
         this.tryAddFrost();
         if (!this.level.isClientSide && this.tickCount % 40 == 0 && this.isFullyFrozen() && this.canFreeze()) {
             i = flag1 ? 5 : 1;
-            this.hurt(DamageSource.FREEZE, (float) i);
+            this.hurt(DamageSource.FREEZE, null, null, (float) i);
         }
 
         this.level.getProfiler().pop();
@@ -3390,7 +3394,7 @@ public abstract class LivingEntity extends Entity {
         }
         // Paper end
         if (!this.level.isClientSide && this.isSensitiveToWater() && this.isInWaterRainOrBubble()) {
-            this.hurt(DamageSource.DROWN, 1.0F);
+            this.hurt(DamageSource.DROWN, null, null, 1.0F);
         }
 
     }
@@ -3459,7 +3463,7 @@ public abstract class LivingEntity extends Entity {
                 }
 
                 if (j > i - 1) {
-                    this.hurt(DamageSource.CRAMMING, 6.0F);
+                    this.hurt(DamageSource.CRAMMING, null, null, 6.0F);
                 }
             }
 
diff --git a/src/main/java/net/minecraft/world/entity/Mob.java b/src/main/java/net/minecraft/world/entity/Mob.java
index 17d5a753b8e79338bb5a4233484e63a5d349511a..23beec7c16968e867c3b0b282afd1bdac1b63ac6 100644
--- a/src/main/java/net/minecraft/world/entity/Mob.java
+++ b/src/main/java/net/minecraft/world/entity/Mob.java
@@ -66,7 +66,6 @@ import net.minecraft.world.item.SpawnEggItem;
 import net.minecraft.world.item.SwordItem;
 import net.minecraft.world.item.enchantment.EnchantmentHelper;
 import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.LevelReader;
@@ -848,7 +847,7 @@ public abstract class Mob extends LivingEntity {
                 this.getJumpControl().tick();
             }
             if (this.isSensitiveToWater() && isInWaterRainOrBubble()) {
-                hurt(DamageSource.DROWN, 1.0F);
+                hurt(DamageSource.DROWN, null, null, 1.0F);
             }
             return;
         }
@@ -1608,7 +1607,7 @@ public abstract class Mob extends LivingEntity {
             // CraftBukkit end
         }
 
-        boolean flag = target.hurt(DamageSource.mobAttack(this), f);
+        boolean flag = target.hurt(DamageSource.mobAttack(this), this, null, f);
 
         if (flag) {
             if (f1 > 0.0F && target instanceof LivingEntity) {
diff --git a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
index 01c3bdac989df14396cfb5bd3e6f7eed6abf07d1..3fc672f0b4ab0c89836a6d20e8802646eee055b2 100644
--- a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
+++ b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
@@ -8,6 +8,7 @@ import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 import net.minecraft.Util;
@@ -19,7 +20,7 @@ import org.slf4j.Logger;
 
 public class AttributeMap {
     private static final Logger LOGGER = LogUtils.getLogger();
-    private final Map<Attribute, AttributeInstance> attributes = Maps.newHashMap();
+    private final Map<Attribute, AttributeInstance> attributes = new ConcurrentHashMap<>();
     private final Set<AttributeInstance> dirtyAttributes = Sets.newHashSet();
     private final AttributeSupplier supplier;
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/RamTarget.java b/src/main/java/net/minecraft/world/entity/ai/behavior/RamTarget.java
index 5665b11084cd668d6414df07b183ff7f43e6aae6..2b082044e1636fa2200bf5c2da2aedbe5e47a898 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/RamTarget.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/RamTarget.java
@@ -22,7 +22,6 @@ import net.minecraft.world.entity.ai.memory.MemoryStatus;
 import net.minecraft.world.entity.ai.memory.WalkTarget;
 import net.minecraft.world.entity.ai.targeting.TargetingConditions;
 import net.minecraft.world.entity.animal.goat.Goat;
-import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.phys.Vec3;
 
 public class RamTarget extends Behavior<Goat> {
@@ -72,7 +71,7 @@ public class RamTarget extends Behavior<Goat> {
         Brain<?> brain = goat.getBrain();
         if (!list.isEmpty()) {
             LivingEntity livingEntity = list.get(0);
-            livingEntity.hurt(DamageSource.mobAttack(goat).setNoAggro(), (float)goat.getAttributeValue(Attributes.ATTACK_DAMAGE));
+            livingEntity.hurt(DamageSource.mobAttack(goat).setNoAggro(), goat, null, (float)goat.getAttributeValue(Attributes.ATTACK_DAMAGE));
             int i = goat.hasEffect(MobEffects.MOVEMENT_SPEED) ? goat.getEffect(MobEffects.MOVEMENT_SPEED).getAmplifier() + 1 : 0;
             int j = goat.hasEffect(MobEffects.MOVEMENT_SLOWDOWN) ? goat.getEffect(MobEffects.MOVEMENT_SLOWDOWN).getAmplifier() + 1 : 0;
             float f = 0.25F * (float)(i - j);
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/warden/SonicBoom.java b/src/main/java/net/minecraft/world/entity/ai/behavior/warden/SonicBoom.java
index 02d635b4a950ca0a5e985d9db9d1a70a479be381..5a7d61de9906269d7fc6f6a356643ce92919b89f 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/warden/SonicBoom.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/warden/SonicBoom.java
@@ -40,8 +40,8 @@ public class SonicBoom extends Behavior<Warden> {
 
     @Override
     protected void start(ServerLevel serverLevel, Warden warden, long l) {
-        warden.getBrain().setMemoryWithExpiry(MemoryModuleType.ATTACK_COOLING_DOWN, true, (long)DURATION);
-        warden.getBrain().setMemoryWithExpiry(MemoryModuleType.SONIC_BOOM_SOUND_DELAY, Unit.INSTANCE, (long)TICKS_BEFORE_PLAYING_SOUND);
+        warden.getBrain().setMemoryWithExpiry(MemoryModuleType.ATTACK_COOLING_DOWN, true, DURATION);
+        warden.getBrain().setMemoryWithExpiry(MemoryModuleType.SONIC_BOOM_SOUND_DELAY, Unit.INSTANCE, TICKS_BEFORE_PLAYING_SOUND);
         serverLevel.broadcastEntityEvent(warden, (byte)62);
         warden.playSound(SoundEvents.WARDEN_SONIC_CHARGE, 3.0F, 1.0F);
     }
@@ -52,21 +52,22 @@ public class SonicBoom extends Behavior<Warden> {
             warden.getLookControl().setLookAt(target.position());
         });
         if (!warden.getBrain().hasMemoryValue(MemoryModuleType.SONIC_BOOM_SOUND_DELAY) && !warden.getBrain().hasMemoryValue(MemoryModuleType.SONIC_BOOM_SOUND_COOLDOWN)) {
-            warden.getBrain().setMemoryWithExpiry(MemoryModuleType.SONIC_BOOM_SOUND_COOLDOWN, Unit.INSTANCE, (long)(DURATION - TICKS_BEFORE_PLAYING_SOUND));
+            warden.getBrain().setMemoryWithExpiry(MemoryModuleType.SONIC_BOOM_SOUND_COOLDOWN, Unit.INSTANCE, DURATION - TICKS_BEFORE_PLAYING_SOUND);
             warden.getBrain().getMemory(MemoryModuleType.ATTACK_TARGET).filter(warden::canTargetEntity).filter((target) -> {
                 return warden.closerThan(target, 15.0D, 20.0D);
             }).ifPresent((target) -> {
-                Vec3 vec3 = warden.position().add(0.0D, (double)1.6F, 0.0D);
+                Vec3 vec3 = warden.position().add(0.0D, 1.6F, 0.0D);
                 Vec3 vec32 = target.getEyePosition().subtract(vec3);
                 Vec3 vec33 = vec32.normalize();
 
-                for(int i = 1; i < Mth.floor(vec32.length()) + 7; ++i) {
-                    Vec3 vec34 = vec3.add(vec33.scale((double)i));
+                final int floor = Mth.floor(vec32.length());
+                for(int i = 1; i < floor + 7; ++i) {
+                    Vec3 vec34 = vec3.add(vec33.scale(i));
                     serverLevel.sendParticles(ParticleTypes.SONIC_BOOM, vec34.x, vec34.y, vec34.z, 1, 0.0D, 0.0D, 0.0D, 0.0D);
                 }
 
                 warden.playSound(SoundEvents.WARDEN_SONIC_BOOM, 3.0F, 1.0F);
-                target.hurt(DamageSource.sonicBoom(warden), 10.0F);
+                target.hurt(DamageSource.sonicBoom(warden), warden, null, 10.0F);
                 double d = 0.5D * (1.0D - target.getAttributeValue(Attributes.KNOCKBACK_RESISTANCE));
                 double e = 2.5D * (1.0D - target.getAttributeValue(Attributes.KNOCKBACK_RESISTANCE));
                 target.push(vec33.x() * e, vec33.y() * d, vec33.z() * e);
@@ -80,6 +81,6 @@ public class SonicBoom extends Behavior<Warden> {
     }
 
     public static void setCooldown(LivingEntity warden, int cooldown) {
-        warden.getBrain().setMemoryWithExpiry(MemoryModuleType.SONIC_BOOM_COOLDOWN, Unit.INSTANCE, (long)cooldown);
+        warden.getBrain().setMemoryWithExpiry(MemoryModuleType.SONIC_BOOM_COOLDOWN, Unit.INSTANCE, cooldown);
     }
 }
diff --git a/src/main/java/net/minecraft/world/entity/ai/control/LookControl.java b/src/main/java/net/minecraft/world/entity/ai/control/LookControl.java
index 5dca627ec70047bb2ac772a427e5ea1c994b07d1..44a397a3dc46d1789e8548fb2a184f0053ac12da 100644
--- a/src/main/java/net/minecraft/world/entity/ai/control/LookControl.java
+++ b/src/main/java/net/minecraft/world/entity/ai/control/LookControl.java
@@ -1,20 +1,24 @@
 package net.minecraft.world.entity.ai.control;
 
 import java.util.Optional;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import com.google.common.util.concurrent.AtomicDouble;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.monster.Zombie;
 import net.minecraft.world.phys.Vec3;
 
 public class LookControl implements Control {
     protected final Mob mob;
-    protected float yMaxRotSpeed;
-    protected float xMaxRotAngle;
-    protected int lookAtCooldown;
-    protected double wantedX;
-    protected double wantedY;
-    protected double wantedZ;
+    protected AtomicDouble yMaxRotSpeed;
+    protected AtomicDouble xMaxRotAngle;
+    protected AtomicInteger lookAtCooldown;
+    protected AtomicDouble wantedX;
+    protected AtomicDouble wantedY;
+    protected AtomicDouble wantedZ;
 
     public LookControl(Mob entity) {
         this.mob = entity;
@@ -29,6 +33,8 @@ public class LookControl implements Control {
     }
 
     public void setLookAt(Entity entity, float maxYawChange, float maxPitchChange) {
+        //System.out.println();
+        //System.out.println("entity: " + entity);
         this.setLookAt(entity.getX(), getWantedY(entity), entity.getZ(), maxYawChange, maxPitchChange);
     }
 
@@ -37,12 +43,25 @@ public class LookControl implements Control {
     }
 
     public void setLookAt(double x, double y, double z, float maxYawChange, float maxPitchChange) {
-        this.wantedX = x;
-        this.wantedY = y;
-        this.wantedZ = z;
-        this.yMaxRotSpeed = maxYawChange;
-        this.xMaxRotAngle = maxPitchChange;
-        this.lookAtCooldown = 2;
+
+        if (mob instanceof Zombie) {
+            //System.out.println("[4] LookControl.setLookAt: " + x + ", " + y + ", " + z + ", " + maxYawChange + ", " + maxPitchChange);
+            //System.out.println("wantedX = " + wantedX);
+
+
+            /*
+            StackTraceElement[] thing = Thread.currentThread().getStackTrace();
+            for (int i = 0; i < thing.length; i++) {
+                System.out.println("  " + thing[i]);
+            }*/
+        }
+
+        this.wantedX = new AtomicDouble(x);
+        this.wantedY = new AtomicDouble(y);
+        this.wantedZ = new AtomicDouble(z);
+        this.yMaxRotSpeed = new AtomicDouble(maxYawChange);
+        this.xMaxRotAngle = new AtomicDouble(maxPitchChange);
+        this.lookAtCooldown = new AtomicInteger(2);
     }
 
     public void tick() {
@@ -50,13 +69,13 @@ public class LookControl implements Control {
             this.mob.setXRot(0.0F);
         }
 
-        if (this.lookAtCooldown > 0) {
-            --this.lookAtCooldown;
+        if (this.lookAtCooldown != null && this.lookAtCooldown.get() > 0) {
+            this.lookAtCooldown.decrementAndGet();
             this.getYRotD().ifPresent((yaw) -> {
-                this.mob.yHeadRot = this.rotateTowards(this.mob.yHeadRot, yaw, this.yMaxRotSpeed);
+                this.mob.yHeadRot = this.rotateTowards(this.mob.yHeadRot, yaw, (float) this.yMaxRotSpeed.get());
             });
             this.getXRotD().ifPresent((pitch) -> {
-                this.mob.setXRot(this.rotateTowards(this.mob.getXRot(), pitch, this.xMaxRotAngle));
+                this.mob.setXRot(this.rotateTowards(this.mob.getXRot(), pitch, (float) this.xMaxRotAngle.get()));
             });
         } else {
             this.mob.yHeadRot = this.rotateTowards(this.mob.yHeadRot, this.mob.yBodyRot, 10.0F);
@@ -77,32 +96,32 @@ public class LookControl implements Control {
     }
 
     public boolean isLookingAtTarget() {
-        return this.lookAtCooldown > 0;
+        return this.lookAtCooldown.get() > 0;
     }
 
     public double getWantedX() {
-        return this.wantedX;
+        return this.wantedX.get();
     }
 
     public double getWantedY() {
-        return this.wantedY;
+        return this.wantedY.get();
     }
 
     public double getWantedZ() {
-        return this.wantedZ;
+        return this.wantedZ.get();
     }
 
     protected Optional<Float> getXRotD() {
-        double d = this.wantedX - this.mob.getX();
-        double e = this.wantedY - this.mob.getEyeY();
-        double f = this.wantedZ - this.mob.getZ();
+        double d = this.wantedX.get() - this.mob.getX();
+        double e = this.wantedY.get() - this.mob.getEyeY();
+        double f = this.wantedZ.get() - this.mob.getZ();
         double g = Math.sqrt(d * d + f * f);
         return !(Math.abs(e) > (double)1.0E-5F) && !(Math.abs(g) > (double)1.0E-5F) ? Optional.empty() : Optional.of((float)(-(Mth.atan2(e, g) * (double)(180F / (float)Math.PI))));
     }
 
     protected Optional<Float> getYRotD() {
-        double d = this.wantedX - this.mob.getX();
-        double e = this.wantedZ - this.mob.getZ();
+        double d = this.wantedX.get() - this.mob.getX();
+        double e = this.wantedZ.get() - this.mob.getZ();
         return !(Math.abs(e) > (double)1.0E-5F) && !(Math.abs(d) > (double)1.0E-5F) ? Optional.empty() : Optional.of((float)(Mth.atan2(e, d) * (double)(180F / (float)Math.PI)) - 90.0F);
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/control/SmoothSwimmingLookControl.java b/src/main/java/net/minecraft/world/entity/ai/control/SmoothSwimmingLookControl.java
index 7df56705a4a0de2dc4ff7ab133fc26612c219162..4da0a3f346e29a7a443a9cacb186f6f38dd475b6 100644
--- a/src/main/java/net/minecraft/world/entity/ai/control/SmoothSwimmingLookControl.java
+++ b/src/main/java/net/minecraft/world/entity/ai/control/SmoothSwimmingLookControl.java
@@ -15,20 +15,20 @@ public class SmoothSwimmingLookControl extends LookControl {
 
     @Override
     public void tick() {
-        if (this.lookAtCooldown > 0) {
-            --this.lookAtCooldown;
+        if (this.lookAtCooldown.get() > 0) {
+            this.lookAtCooldown.decrementAndGet();
             this.getYRotD().ifPresent((yaw) -> {
-                this.mob.yHeadRot = this.rotateTowards(this.mob.yHeadRot, yaw + 20.0F, this.yMaxRotSpeed);
+                this.mob.yHeadRot = this.rotateTowards(this.mob.yHeadRot, yaw + 20.0F, (float) this.yMaxRotSpeed.get());
             });
             this.getXRotD().ifPresent((pitch) -> {
-                this.mob.setXRot(this.rotateTowards(this.mob.getXRot(), pitch + 10.0F, this.xMaxRotAngle));
+                this.mob.setXRot(this.rotateTowards(this.mob.getXRot(), pitch + 10.0F, (float) this.xMaxRotAngle.get()));
             });
         } else {
             if (this.mob.getNavigation().isDone()) {
                 this.mob.setXRot(this.rotateTowards(this.mob.getXRot(), 0.0F, 5.0F));
             }
 
-            this.mob.yHeadRot = this.rotateTowards(this.mob.yHeadRot, this.mob.yBodyRot, this.yMaxRotSpeed);
+            this.mob.yHeadRot = this.rotateTowards(this.mob.yHeadRot, this.mob.yBodyRot, (float) this.yMaxRotSpeed.get());
         }
 
         float f = Mth.wrapDegrees(this.mob.yHeadRot - this.mob.yBodyRot);
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
index a910189177da0c1134c954b3d81b9e9bc4bc1420..abad022b5b4f64314fea60f36bf4ae104ee33094 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
@@ -3,11 +3,9 @@ package net.minecraft.world.entity.ai.goal;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.Sets;
 import com.mojang.logging.LogUtils;
-import java.util.EnumMap;
-import java.util.EnumSet;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Set;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
 import net.minecraft.util.profiling.ProfilerFiller;
@@ -27,7 +25,7 @@ public class GoalSelector {
         }
     };
     private final Map<Goal.Flag, WrappedGoal> lockedFlags = new EnumMap<>(Goal.Flag.class);
-    public final Set<WrappedGoal> availableGoals = Sets.newLinkedHashSet();
+    public final Queue<WrappedGoal> availableGoals = new ConcurrentLinkedQueue();
     private final Supplier<ProfilerFiller> profiler;
     private final EnumSet<Goal.Flag> disabledFlags = EnumSet.noneOf(Goal.Flag.class); // Paper unused, but dummy to prevent plugins from crashing as hard. Theyll need to support paper in a special case if this is super important, but really doesn't seem like it would be.
     private final com.destroystokyo.paper.util.set.OptimizedSmallEnumSet<net.minecraft.world.entity.ai.goal.Goal.Flag> goalTypes = new com.destroystokyo.paper.util.set.OptimizedSmallEnumSet<>(Goal.Flag.class); // Paper - remove streams from pathfindergoalselector
@@ -155,7 +153,7 @@ public class GoalSelector {
         profilerFiller.pop();
     }
 
-    public Set<WrappedGoal> getAvailableGoals() {
+    public Queue<WrappedGoal> getAvailableGoals() {
         return this.availableGoals;
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/MeleeAttackGoal.java b/src/main/java/net/minecraft/world/entity/ai/goal/MeleeAttackGoal.java
index e6cf828a267f694d3f23e578b62c8f8146f22afb..3c874838b5e87b37efb84d1035d182e3b72210c4 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/MeleeAttackGoal.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/MeleeAttackGoal.java
@@ -43,6 +43,7 @@ public class MeleeAttackGoal extends Goal {
                 return false;
             } else {
                 this.path = this.mob.getNavigation().createPath(livingEntity, 0);
+                System.out.println("Here: " + path);
                 if (this.path != null) {
                     return true;
                 } else {
@@ -70,6 +71,7 @@ public class MeleeAttackGoal extends Goal {
 
     @Override
     public void start() {
+        System.out.println("Started");
         this.mob.getNavigation().moveTo(this.path, this.speedModifier);
         this.mob.setAggressive(true);
         this.ticksUntilNextPathRecalculation = 0;
@@ -78,6 +80,8 @@ public class MeleeAttackGoal extends Goal {
 
     @Override
     public void stop() {
+        System.out.println("Stopped");
+
         LivingEntity livingEntity = this.mob.getTarget();
         if (!EntitySelector.NO_CREATIVE_OR_SPECTATOR.test(livingEntity)) {
             this.mob.setTarget((LivingEntity)null);
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/target/NearestAttackableTargetGoal.java b/src/main/java/net/minecraft/world/entity/ai/goal/target/NearestAttackableTargetGoal.java
index 2f26adea26eaa058b2e4724734c75d884fa68d33..fa14aebe4fc53669f6c6193944fa9819b83ad3b8 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/target/NearestAttackableTargetGoal.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/target/NearestAttackableTargetGoal.java
@@ -1,6 +1,7 @@
 package net.minecraft.world.entity.ai.goal.target;
 
 import java.util.EnumSet;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
 import net.minecraft.server.level.ServerPlayer;
@@ -10,14 +11,17 @@ import net.minecraft.world.entity.ai.goal.Goal;
 import net.minecraft.world.entity.ai.targeting.TargetingConditions;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.phys.AABB;
+import org.jetbrains.annotations.NotNull;
+
 
 public class NearestAttackableTargetGoal<T extends LivingEntity> extends TargetGoal {
 
     private static final int DEFAULT_RANDOM_INTERVAL = 10;
     protected final Class<T> targetType;
     protected final int randomInterval;
-    @Nullable
-    protected LivingEntity target;
+
+    @NotNull
+    protected AtomicReference<LivingEntity> target = new AtomicReference<LivingEntity>(null);
     protected TargetingConditions targetConditions;
 
     public NearestAttackableTargetGoal(Mob mob, Class<T> targetClass, boolean checkVisibility) {
@@ -47,7 +51,7 @@ public class NearestAttackableTargetGoal<T extends LivingEntity> extends TargetG
             return false;
         } else {
             this.findTarget();
-            return this.target != null;
+            return this.target.get() != null;
         }
     }
 
@@ -57,22 +61,23 @@ public class NearestAttackableTargetGoal<T extends LivingEntity> extends TargetG
 
     protected void findTarget() {
         if (this.targetType != Player.class && this.targetType != ServerPlayer.class) {
-            this.target = this.mob.level.getNearestEntity(this.mob.level.getEntitiesOfClass(this.targetType, this.getTargetSearchArea(this.getFollowDistance()), (entityliving) -> {
+            this.target.set(this.mob.level.getNearestEntity(this.mob.level.getEntitiesOfClass(this.targetType, this.getTargetSearchArea(this.getFollowDistance()), (entityliving) -> {
                 return true;
-            }), this.targetConditions, this.mob, this.mob.getX(), this.mob.getEyeY(), this.mob.getZ());
+            }), this.targetConditions, this.mob, this.mob.getX(), this.mob.getEyeY(), this.mob.getZ()));
         } else {
-            this.target = this.mob.level.getNearestPlayer(this.targetConditions, this.mob, this.mob.getX(), this.mob.getEyeY(), this.mob.getZ());
+            this.target.set(this.mob.level.getNearestPlayer(this.targetConditions, this.mob, this.mob.getX(), this.mob.getEyeY(), this.mob.getZ()));
         }
 
     }
 
     @Override
     public void start() {
-        this.mob.setTarget(this.target, this.target instanceof ServerPlayer ? org.bukkit.event.entity.EntityTargetEvent.TargetReason.CLOSEST_PLAYER : org.bukkit.event.entity.EntityTargetEvent.TargetReason.CLOSEST_ENTITY, true); // CraftBukkit - reason
+        final LivingEntity target = this.target.get();
+        this.mob.setTarget(target, target instanceof ServerPlayer ? org.bukkit.event.entity.EntityTargetEvent.TargetReason.CLOSEST_PLAYER : org.bukkit.event.entity.EntityTargetEvent.TargetReason.CLOSEST_ENTITY, true); // CraftBukkit - reason
         super.start();
     }
 
     public void setTarget(@Nullable LivingEntity targetEntity) {
-        this.target = targetEntity;
+        this.target.set(targetEntity);
     }
 }
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/target/NearestHealableRaiderTargetGoal.java b/src/main/java/net/minecraft/world/entity/ai/goal/target/NearestHealableRaiderTargetGoal.java
index 8df2dab08f9f7811b8afc8c3c27dea63bacf11e6..a77b79c58e83cbeba9713a7ceb92a02f15849a7b 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/target/NearestHealableRaiderTargetGoal.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/target/NearestHealableRaiderTargetGoal.java
@@ -28,7 +28,7 @@ public class NearestHealableRaiderTargetGoal<T extends LivingEntity> extends Nea
                 return false;
             } else {
                 this.findTarget();
-                return this.target != null;
+                return this.target.get() != null;
             }
         } else {
             return false;
diff --git a/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java b/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
index d0ea77854b0a0c250a347ba469c69e3011ad574a..2a37c3cf780c301b2c6b562d561457dd7c3a175e 100644
--- a/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
+++ b/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
@@ -5,6 +5,8 @@ import java.util.Set;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import kotlin.jvm.Volatile;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Vec3i;
@@ -25,13 +27,18 @@ import net.minecraft.world.level.pathfinder.PathFinder;
 import net.minecraft.world.level.pathfinder.WalkNodeEvaluator;
 import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.World;
+import org.jetbrains.annotations.NotNull;
+
 
 public abstract class PathNavigation {
     private static final int MAX_TIME_RECOMPUTE = 20;
+    @NotNull
     protected final Mob mob;
+    @NotNull
     protected final Level level;
     @Nullable
-    protected Path path;
+    protected volatile Path path;
     protected double speedModifier;
     protected int tick;
     protected int lastStuckCheck;
@@ -52,6 +59,14 @@ public abstract class PathNavigation {
     private boolean isStuck;
 
     public PathNavigation(Mob entity, Level world) {
+
+        if (entity == null) {
+            throw new IllegalArgumentException("Entity must not be null");
+        }
+        if (world == null) {
+            throw new IllegalArgumentException("World must not be null");
+        }
+
         this.mob = entity;
         this.level = world;
         int i = Mth.floor(entity.getAttributeValue(Attributes.FOLLOW_RANGE) * 16.0D);
@@ -144,9 +159,10 @@ public abstract class PathNavigation {
 
     @Nullable protected Path createPath(Set<BlockPos> positions, @Nullable Entity target, int range, boolean useHeadPos, int distance, float followRange) {
         // Paper end
+
         if (positions.isEmpty()) {
             return null;
-        } else if (this.mob.getY() < (double)this.level.getMinBuildHeight()) {
+        } else if (mob.getY() < (double)level.getMinBuildHeight()) {
             return null;
         } else if (!this.canUpdatePath()) {
             return null;
@@ -156,7 +172,7 @@ public abstract class PathNavigation {
             // Paper start - Pathfind event
             boolean copiedSet = false;
             for (BlockPos possibleTarget : positions) {
-                if (!this.mob.getCommandSenderWorld().getWorldBorder().isWithinBounds(possibleTarget) || !new com.destroystokyo.paper.event.entity.EntityPathfindEvent(this.mob.getBukkitEntity(), // Paper - don't path out of world border
+                if (!this.mob.getCommandSenderWorld().getWorldBorder().isWithinBounds(possibleTarget) || !new com.destroystokyo.paper.event.entity.EntityPathfindEvent(mob.getBukkitEntity(), // Paper - don't path out of world border
                     io.papermc.paper.util.MCUtil.toLocation(this.mob.level, possibleTarget), target == null ? null : target.getBukkitEntity()).callEvent()) {
                     if (!copiedSet) {
                         copiedSet = true;
@@ -170,12 +186,12 @@ public abstract class PathNavigation {
                 }
             }
             // Paper end
-            this.level.getProfiler().push("pathfind");
-            BlockPos blockPos = useHeadPos ? this.mob.blockPosition().above() : this.mob.blockPosition();
+            level.getProfiler().push("pathfind");
+            BlockPos blockPos = useHeadPos ? mob.blockPosition().above() : mob.blockPosition();
             int i = (int)(followRange + (float)range);
-            PathNavigationRegion pathNavigationRegion = new PathNavigationRegion(this.level, blockPos.offset(-i, -i, -i), blockPos.offset(i, i, i));
-            Path path = this.pathFinder.findPath(pathNavigationRegion, this.mob, positions, followRange, distance, this.maxVisitedNodesMultiplier);
-            this.level.getProfiler().pop();
+            PathNavigationRegion pathNavigationRegion = new PathNavigationRegion(level, blockPos.offset(-i, -i, -i), blockPos.offset(i, i, i));
+            Path path = this.pathFinder.findPath(pathNavigationRegion, mob, positions, followRange, distance, this.maxVisitedNodesMultiplier);
+            level.getProfiler().pop();
             if (path != null && path.getTarget() != null) {
                 this.targetPos = path.getTarget();
                 this.reachRange = distance;
@@ -374,15 +390,16 @@ public abstract class PathNavigation {
     }
 
     protected void trimPath() {
-        if (this.path != null) {
-            for(int i = 0; i < this.path.getNodeCount(); ++i) {
-                Node node = this.path.getNode(i);
-                Node node2 = i + 1 < this.path.getNodeCount() ? this.path.getNode(i + 1) : null;
-                BlockState blockState = this.level.getBlockState(new BlockPos(node.x, node.y, node.z));
+
+        if (level != null && path != null) {
+            for(int i = 0; i < path.getNodeCount(); ++i) {
+                Node node = path.getNode(i);
+                Node node2 = i + 1 < path.getNodeCount() ? path.getNode(i + 1) : null;
+                BlockState blockState = level.getBlockState(new BlockPos(node.x, node.y, node.z));
                 if (blockState.is(BlockTags.CAULDRONS)) {
-                    this.path.replaceNode(i, node.cloneAndMove(node.x, node.y + 1, node.z));
+                    path.replaceNode(i, node.cloneAndMove(node.x, node.y + 1, node.z));
                     if (node2 != null && node.y >= node2.y) {
-                        this.path.replaceNode(i + 1, node.cloneAndMove(node2.x, node.y + 1, node2.z));
+                        path.replaceNode(i + 1, node.cloneAndMove(node2.x, node.y + 1, node2.z));
                     }
                 }
             }
@@ -417,12 +434,19 @@ public abstract class PathNavigation {
     }
 
     public boolean shouldRecomputePath(BlockPos pos) {
+
+        final Path path = this.path;
+
+        if (path == null) {
+            return false;
+        }
+
         if (this.hasDelayedRecomputation) {
             return false;
-        } else if (this.path != null && !this.path.isDone() && this.path.getNodeCount() != 0) {
-            Node node = this.path.getEndNode();
-            Vec3 vec3 = new Vec3(((double)node.x + this.mob.getX()) / 2.0D, ((double)node.y + this.mob.getY()) / 2.0D, ((double)node.z + this.mob.getZ()) / 2.0D);
-            return pos.closerToCenterThan(vec3, this.path.getNodeCount() - this.path.getNextNodeIndex());
+        } else if (path != null && !this.path.isDone() && this.path.getNodeCount() != 0) {
+            Node node = path.getEndNode();
+            Vec3 vec3 = new Vec3(((double)node.x + mob.getX()) / 2.0D, ((double)node.y + mob.getY()) / 2.0D, ((double)node.z + mob.getZ()) / 2.0D);
+            return pos.closerToCenterThan(vec3, path.getNodeCount() - path.getNextNodeIndex());
         } else {
             return false;
         }
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/NearestLivingEntitySensor.java b/src/main/java/net/minecraft/world/entity/ai/sensing/NearestLivingEntitySensor.java
index d8cf99a3014a4b8152ae819fa663c2fdf34dce57..87dfb27e69afa9738e4df2280109bee2d042e6c8 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/NearestLivingEntitySensor.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/NearestLivingEntitySensor.java
@@ -1,24 +1,43 @@
 package net.minecraft.world.entity.ai.sensing;
 
 import com.google.common.collect.ImmutableSet;
-import java.util.Comparator;
-import java.util.List;
-import java.util.Set;
+
+import java.util.*;
+import java.util.function.ToDoubleFunction;
+
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.ai.Brain;
 import net.minecraft.world.entity.ai.memory.MemoryModuleType;
 import net.minecraft.world.entity.ai.memory.NearestVisibleLivingEntities;
 import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
+
 
 public class NearestLivingEntitySensor<T extends LivingEntity> extends Sensor<T> {
     @Override
     protected void doTick(ServerLevel world, T entity) {
-        AABB aABB = entity.getBoundingBox().inflate((double)this.radiusXZ(), (double)this.radiusY(), (double)this.radiusXZ());
+
+        if (entity == null) {
+            return;
+        }
+
+        AABB aABB = entity.getBoundingBox().inflate(this.radiusXZ(), this.radiusY(), this.radiusXZ());
         List<LivingEntity> list = world.getEntitiesOfClass(LivingEntity.class, aABB, (e) -> {
             return e != entity && e.isAlive();
         });
-        list.sort(Comparator.comparingDouble(entity::distanceToSqr));
+
+
+        final Map<Integer, Vec3> entityVectorByID = new HashMap<>(list.size());
+
+        list.forEach((e) -> {
+            entityVectorByID.put(e.getId(), e.position());
+        });
+
+        final Vec3 entityPosition = entity.position();
+
+        list.sort(Comparator.comparingDouble(new DistanceComparison(entityPosition, entityVectorByID)));
+
         Brain<?> brain = entity.getBrain();
         brain.setMemory(MemoryModuleType.NEAREST_LIVING_ENTITIES, list);
         brain.setMemory(MemoryModuleType.NEAREST_VISIBLE_LIVING_ENTITIES, new NearestVisibleLivingEntities(entity, list));
@@ -36,4 +55,13 @@ public class NearestLivingEntitySensor<T extends LivingEntity> extends Sensor<T>
     public Set<MemoryModuleType<?>> requires() {
         return ImmutableSet.of(MemoryModuleType.NEAREST_LIVING_ENTITIES, MemoryModuleType.NEAREST_VISIBLE_LIVING_ENTITIES);
     }
+
+    private record DistanceComparison(Vec3 entityPosition, Map<Integer, Vec3> entityVectorByID) implements ToDoubleFunction<LivingEntity> {
+
+        @Override
+        public double applyAsDouble(final LivingEntity value) {
+            return entityPosition.distanceToSqr(entityVectorByID.get(value.getId()));
+        }
+
+    }
 }
diff --git a/src/main/java/net/minecraft/world/entity/ambient/Bat.java b/src/main/java/net/minecraft/world/entity/ambient/Bat.java
index 7d4662392b030999ad65ee0291d9839f2efcea42..4fa022bc7f2c91967562bded3779e48614842268 100644
--- a/src/main/java/net/minecraft/world/entity/ambient/Bat.java
+++ b/src/main/java/net/minecraft/world/entity/ambient/Bat.java
@@ -22,11 +22,11 @@ import net.minecraft.world.entity.Pose;
 import net.minecraft.world.entity.ai.attributes.AttributeSupplier;
 import net.minecraft.world.entity.ai.attributes.Attributes;
 import net.minecraft.world.entity.ai.targeting.TargetingConditions;
-import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.block.Block;
 import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
 public class Bat extends AmbientCreature {
@@ -195,7 +195,7 @@ public class Bat extends AmbientCreature {
     }
 
     @Override
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
+    public boolean causeFallDamage(float fallDistance, final @Nullable Entity damagerEntity, final Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
         return false;
     }
 
@@ -208,7 +208,7 @@ public class Bat extends AmbientCreature {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.isInvulnerableTo(source)) {
             return false;
         } else {
@@ -220,7 +220,7 @@ public class Bat extends AmbientCreature {
                 // CraftBukkit End - Call BatToggleSleepEvent
             }
 
-            return super.hurt(source, amount);
+            return super.hurt(source, damagerEntity, damagerBlock, amount);
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/animal/Bee.java b/src/main/java/net/minecraft/world/entity/animal/Bee.java
index b1c49723571e5c45ef3863e65cc2436933b73cc5..bac43df9fb8748b8c2920cb6e38c56f10e52ba3a 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Bee.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Bee.java
@@ -5,7 +5,6 @@ import java.util.Comparator;
 import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Objects;
 import java.util.Optional;
 import java.util.UUID;
 import java.util.function.Predicate;
@@ -91,6 +90,7 @@ import net.minecraft.world.level.pathfinder.BlockPathTypes;
 import net.minecraft.world.level.pathfinder.Path;
 import net.minecraft.world.phys.Vec3;
 
+
 public class Bee extends Animal implements NeutralMob, FlyingAnimal {
 
     public static final float FLAP_DEGREES_PER_TICK = 120.32113F;
@@ -243,7 +243,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
 
     @Override
     public boolean doHurtTarget(Entity target) {
-        boolean flag = target.hurt(DamageSource.sting(this), (float) ((int) this.getAttributeValue(Attributes.ATTACK_DAMAGE)));
+        boolean flag = target.hurt(DamageSource.sting(this), this, null, (float) ((int) this.getAttributeValue(Attributes.ATTACK_DAMAGE)));
 
         if (flag) {
             this.doEnchantDamageEffects(this, target);
@@ -381,13 +381,13 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
         }
 
         if (this.underWaterTicks > 20) {
-            this.hurt(DamageSource.DROWN, 1.0F);
+            this.hurt(DamageSource.DROWN, null, null, 1.0F);
         }
 
         if (flag) {
             ++this.timeSinceSting;
             if (this.timeSinceSting % 5 == 0 && this.random.nextInt(Mth.clamp(1200 - this.timeSinceSting, 1, 1200)) == 0) {
-                this.hurt(DamageSource.GENERIC, this.getHealth());
+                this.hurt(DamageSource.GENERIC, null, null, this.getHealth());
             }
         }
 
@@ -636,7 +636,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
     }
 
     @Override
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
+    public boolean causeFallDamage(float fallDistance, final @Nullable Entity damagerEntity, final org.bukkit.block.Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
         return false;
     }
 
@@ -659,12 +659,12 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @org.jetbrains.annotations.Nullable Entity damagerEntity, @org.jetbrains.annotations.Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.isInvulnerableTo(source)) {
             return false;
         } else {
             // CraftBukkit start
-            boolean result = super.hurt(source, amount);
+            boolean result = super.hurt(source, damagerEntity, damagerBlock, amount);
 
             if (result && !this.level.isClientSide) {
                 this.beePollinateGoal.stopPollinating();
diff --git a/src/main/java/net/minecraft/world/entity/animal/Cat.java b/src/main/java/net/minecraft/world/entity/animal/Cat.java
index e0a269ffacc9d2ede4e0fdf47b1941667fa1ed45..32063016e50b3e8aa37f11922a4c5852d9d2c6c1 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Cat.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Cat.java
@@ -2,7 +2,6 @@ package net.minecraft.world.entity.animal;
 
 import java.util.Iterator;
 import java.util.List;
-import java.util.Objects;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
@@ -70,6 +69,8 @@ import net.minecraft.world.level.storage.loot.LootTable;
 import net.minecraft.world.level.storage.loot.parameters.LootContextParamSets;
 import net.minecraft.world.level.storage.loot.parameters.LootContextParams;
 import net.minecraft.world.phys.AABB;
+import org.bukkit.block.Block;
+
 
 public class Cat extends TamableAnimal {
 
@@ -233,7 +234,7 @@ public class Cat extends TamableAnimal {
     }
 
     @Override
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
+    public boolean causeFallDamage(float fallDistance, final @Nullable Entity damagerEntity, final Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
         return false;
     }
 
@@ -252,7 +253,7 @@ public class Cat extends TamableAnimal {
 
     @Override
     public boolean doHurtTarget(Entity target) {
-        return target.hurt(DamageSource.mobAttack(this), this.getAttackDamage());
+        return target.hurt(DamageSource.mobAttack(this), this, null, this.getAttackDamage());
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/animal/Chicken.java b/src/main/java/net/minecraft/world/entity/animal/Chicken.java
index f01e508451217ee3bd7eaf9c322b2833c020514c..1965ac5b0766b42555d1095cc1152b389ddb22a9 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Chicken.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Chicken.java
@@ -28,12 +28,15 @@ import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.item.crafting.Ingredient;
-import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.pathfinder.BlockPathTypes;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.block.Block;
+
+import javax.annotation.Nullable;
+
 
 public class Chicken extends Animal {
 
@@ -115,7 +118,7 @@ public class Chicken extends Animal {
     }
 
     @Override
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
+    public boolean causeFallDamage(float fallDistance, final @Nullable Entity damagerEntity, final Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
         return false;
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/animal/Dolphin.java b/src/main/java/net/minecraft/world/entity/animal/Dolphin.java
index b6b2416f60fa7c18d84cfe98c08198b3867269ff..5b14b34fdbdc8c45424995ef6c7571fea0d570e5 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Dolphin.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Dolphin.java
@@ -184,7 +184,7 @@ public class Dolphin extends WaterAnimal {
 
     @Override
     public boolean doHurtTarget(Entity target) {
-        boolean flag = target.hurt(DamageSource.mobAttack(this), (float) ((int) this.getAttributeValue(Attributes.ATTACK_DAMAGE)));
+        boolean flag = target.hurt(DamageSource.mobAttack(this), this, null, (float) ((int) this.getAttributeValue(Attributes.ATTACK_DAMAGE)));
 
         if (flag) {
             this.doEnchantDamageEffects(this, target);
@@ -264,7 +264,7 @@ public class Dolphin extends WaterAnimal {
             } else {
                 this.setMoisntessLevel(this.getMoistnessLevel() - 1);
                 if (this.getMoistnessLevel() <= 0) {
-                    this.hurt(DamageSource.DRY_OUT, 1.0F);
+                    this.hurt(DamageSource.DRY_OUT, null, null, 1.0F);
                 }
 
                 if (this.onGround) {
diff --git a/src/main/java/net/minecraft/world/entity/animal/Fox.java b/src/main/java/net/minecraft/world/entity/animal/Fox.java
index c93e79f6dfd3270439b79a8b8bcadaef6940ccf3..a2ae1de4fe6dfb11913093742dfcdddb9e14bb26 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Fox.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Fox.java
@@ -1505,7 +1505,7 @@ public class Fox extends Animal {
         @Override
         public void start() {
             this.setTarget(this.trustedLastHurtBy);
-            this.target = this.trustedLastHurtBy;
+            this.target.set(this.trustedLastHurtBy);
             if (this.trustedLastHurt != null) {
                 this.timestamp = this.trustedLastHurt.getLastHurtByMobTimestamp();
             }
diff --git a/src/main/java/net/minecraft/world/entity/animal/IronGolem.java b/src/main/java/net/minecraft/world/entity/animal/IronGolem.java
index 52d4a41485d532b190499ae7d4e42cf44e2ca0a8..55cfd355ab17280288cd27efdb4fd30317775e33 100644
--- a/src/main/java/net/minecraft/world/entity/animal/IronGolem.java
+++ b/src/main/java/net/minecraft/world/entity/animal/IronGolem.java
@@ -52,6 +52,8 @@ import net.minecraft.world.level.NaturalSpawner;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.craftbukkit.block.CraftBlock;
+
 
 public class IronGolem extends AbstractGolem implements NeutralMob {
 
@@ -194,7 +196,7 @@ public class IronGolem extends AbstractGolem implements NeutralMob {
         this.level.broadcastEntityEvent(this, (byte) 4);
         float f = this.getAttackDamage();
         float f1 = (int) f > 0 ? f / 2.0F + (float) this.random.nextInt((int) f) : f;
-        boolean flag = target.hurt(DamageSource.mobAttack(this), f1);
+        boolean flag = target.hurt(DamageSource.mobAttack(this), this, null, f1);
 
         if (flag) {
             double d0;
@@ -219,9 +221,9 @@ public class IronGolem extends AbstractGolem implements NeutralMob {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         IronGolem.Crackiness entityirongolem_cracklevel = this.getCrackiness();
-        boolean flag = super.hurt(source, amount);
+        boolean flag = super.hurt(source, damagerEntity, damagerBlock, amount);
 
         if (flag && this.getCrackiness() != entityirongolem_cracklevel) {
             this.playSound(SoundEvents.IRON_GOLEM_DAMAGE, 1.0F, 1.0F);
diff --git a/src/main/java/net/minecraft/world/entity/animal/Ocelot.java b/src/main/java/net/minecraft/world/entity/animal/Ocelot.java
index 0db51f286f15336badbb79f5c4463dda8ed101cf..7ca5c190d0c0b140d7201969003a2835e9ad4d35 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Ocelot.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Ocelot.java
@@ -48,6 +48,8 @@ import net.minecraft.world.level.ServerLevelAccessor;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.block.Block;
+
 
 public class Ocelot extends Animal {
 
@@ -139,7 +141,7 @@ public class Ocelot extends Animal {
     }
 
     @Override
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
+    public boolean causeFallDamage(float fallDistance, final @Nullable Entity damagerEntity, final Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
         return false;
     }
 
@@ -170,7 +172,7 @@ public class Ocelot extends Animal {
 
     @Override
     public boolean doHurtTarget(Entity target) {
-        return target.hurt(DamageSource.mobAttack(this), this.getAttackDamage());
+        return target.hurt(DamageSource.mobAttack(this), this, null, this.getAttackDamage());
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/animal/Panda.java b/src/main/java/net/minecraft/world/entity/animal/Panda.java
index b1d71aa6e6d2c1d3278f49b36a84f9c7e391821b..7e03c0504bddcb849f622bfab189dd8d2b994d3c 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Panda.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Panda.java
@@ -55,13 +55,13 @@ import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.item.crafting.Ingredient;
 import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.ServerLevelAccessor;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.event.entity.EntityTargetEvent; // CraftBukkit
 
 public class Panda extends Animal {
@@ -544,12 +544,12 @@ public class Panda extends Animal {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (!this.level.isClientSide) {
             this.sit(false);
         }
 
-        return super.hurt(source, amount);
+        return super.hurt(source, damagerEntity, damagerBlock, amount);
     }
 
     @Nullable
diff --git a/src/main/java/net/minecraft/world/entity/animal/Parrot.java b/src/main/java/net/minecraft/world/entity/animal/Parrot.java
index 3805bea6ec2ea1da274e07bfc81d138b7083b962..b50305649d44db8ee12bde89382c4dd7c5c59a23 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Parrot.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Parrot.java
@@ -65,6 +65,8 @@ import net.minecraft.world.level.block.LeavesBlock;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.pathfinder.BlockPathTypes;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.block.Block;
+
 
 public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
 
@@ -273,7 +275,7 @@ public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
 
             this.addEffect(new MobEffectInstance(MobEffects.POISON, 900), org.bukkit.event.entity.EntityPotionEffectEvent.Cause.FOOD); // CraftBukkit
             if (player.isCreative() || !this.isInvulnerable()) {
-                this.hurt(DamageSource.playerAttack(player), Float.MAX_VALUE);
+                this.hurt(DamageSource.playerAttack(player), player, null, Float.MAX_VALUE);
             }
 
             return InteractionResult.sidedSuccess(this.level.isClientSide);
@@ -298,7 +300,7 @@ public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
     }
 
     @Override
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
+    public boolean causeFallDamage(float fallDistance, final @Nullable Entity damagerEntity, final Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
         return false;
     }
 
@@ -318,7 +320,7 @@ public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
 
     @Override
     public boolean doHurtTarget(Entity target) {
-        return target.hurt(DamageSource.mobAttack(this), 3.0F);
+        return target.hurt(DamageSource.mobAttack(this), this, null, 3.0F);
     }
 
     @Nullable
@@ -394,7 +396,7 @@ public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.isInvulnerableTo(source)) {
             return false;
         } else {
@@ -402,7 +404,7 @@ public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
                 // this.setOrderedToSit(false); // CraftBukkit - moved into EntityLiving.damageEntity(DamageSource, float)
             }
 
-            return super.hurt(source, amount);
+            return super.hurt(source, damagerEntity, damagerBlock, amount);
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/animal/PolarBear.java b/src/main/java/net/minecraft/world/entity/animal/PolarBear.java
index b1e05acfb0f0d6517682c12e1ba06a685f0280db..15fb3fe37463c64ccf7831e17fe385b4a2a7c643 100644
--- a/src/main/java/net/minecraft/world/entity/animal/PolarBear.java
+++ b/src/main/java/net/minecraft/world/entity/animal/PolarBear.java
@@ -216,7 +216,7 @@ public class PolarBear extends Animal implements NeutralMob {
 
     @Override
     public boolean doHurtTarget(Entity target) {
-        boolean bl = target.hurt(DamageSource.mobAttack(this), (float)((int)this.getAttributeValue(Attributes.ATTACK_DAMAGE)));
+        boolean bl = target.hurt(DamageSource.mobAttack(this), this, null, ((int)this.getAttributeValue(Attributes.ATTACK_DAMAGE)));
         if (bl) {
             this.doEnchantDamageEffects(this, target);
         }
diff --git a/src/main/java/net/minecraft/world/entity/animal/Pufferfish.java b/src/main/java/net/minecraft/world/entity/animal/Pufferfish.java
index 32422c39bfc7132bcf328b08c306e921936aaffe..bdb0df11d04f33017aae0c7ec7d810d9c6f86b28 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Pufferfish.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Pufferfish.java
@@ -157,7 +157,7 @@ public class Pufferfish extends AbstractFish {
     private void touch(Mob mob) {
         int i = this.getPuffState();
 
-        if (mob.hurt(DamageSource.mobAttack(this), (float) (1 + i))) {
+        if (mob.hurt(DamageSource.mobAttack(this), this, null, (float) (1 + i))) {
             mob.addEffect(new MobEffectInstance(MobEffects.POISON, 60 * i, 0), this, org.bukkit.event.entity.EntityPotionEffectEvent.Cause.ATTACK); // CraftBukkit
             this.playSound(SoundEvents.PUFFER_FISH_STING, 1.0F, 1.0F);
         }
@@ -168,7 +168,7 @@ public class Pufferfish extends AbstractFish {
     public void playerTouch(Player player) {
         int i = this.getPuffState();
 
-        if (player instanceof ServerPlayer && i > 0 && player.hurt(DamageSource.mobAttack(this), (float) (1 + i))) {
+        if (player instanceof ServerPlayer && i > 0 && player.hurt(DamageSource.mobAttack(this), this, null, (float) (1 + i))) {
             if (!this.isSilent()) {
                 ((ServerPlayer) player).connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.PUFFER_FISH_STING, 0.0F));
             }
diff --git a/src/main/java/net/minecraft/world/entity/animal/Rabbit.java b/src/main/java/net/minecraft/world/entity/animal/Rabbit.java
index 68ad42e5853470e28353536163da0be27527c349..1f063defac26d7d4a6dab9952c9912a6372ae6ed 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Rabbit.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Rabbit.java
@@ -319,9 +319,9 @@ public class Rabbit extends Animal {
     public boolean doHurtTarget(Entity target) {
         if (this.getRabbitType() == 99) {
             this.playSound(SoundEvents.RABBIT_ATTACK, 1.0F, (this.random.nextFloat() - this.random.nextFloat()) * 0.2F + 1.0F);
-            return target.hurt(DamageSource.mobAttack(this), 8.0F);
+            return target.hurt(DamageSource.mobAttack(this), this, null, 8.0F);
         } else {
-            return target.hurt(DamageSource.mobAttack(this), 3.0F);
+            return target.hurt(DamageSource.mobAttack(this), this, null, 3.0F);
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/animal/SnowGolem.java b/src/main/java/net/minecraft/world/entity/animal/SnowGolem.java
index cac118f1f11e374ab5147c7b646842b44b0fa507..9a6fb4bf61f94d79765a54dfbc80bc57a164820d 100644
--- a/src/main/java/net/minecraft/world/entity/animal/SnowGolem.java
+++ b/src/main/java/net/minecraft/world/entity/animal/SnowGolem.java
@@ -13,7 +13,6 @@ import net.minecraft.util.Mth;
 import net.minecraft.world.InteractionHand;
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.damagesource.DamageSource;
-import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityDimensions;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.LivingEntity;
@@ -106,7 +105,7 @@ public class SnowGolem extends AbstractGolem implements Shearable, RangedAttackM
             Biome biomebase = this.level.getBiome(blockposition).value();
 
             if (biomebase.shouldSnowGolemBurn(blockposition)) {
-                this.hurt(CraftEventFactory.MELTING, 1.0F); // CraftBukkit - DamageSource.BURN -> CraftEventFactory.MELTING
+                this.hurt(CraftEventFactory.MELTING, null, null, 1.0F); // CraftBukkit - DamageSource.BURN -> CraftEventFactory.MELTING
             }
 
             if (!this.level.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)) {
diff --git a/src/main/java/net/minecraft/world/entity/animal/Squid.java b/src/main/java/net/minecraft/world/entity/animal/Squid.java
index a0440542935bd39e6e6d087f1a57a318baccd477..8029f981d919678d6e1f3594e6bb13ee6358fc71 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Squid.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Squid.java
@@ -26,6 +26,7 @@ import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.jetbrains.annotations.Nullable;
 
 
@@ -170,8 +171,8 @@ public class Squid extends WaterAnimal {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
-        if (super.hurt(source, amount) && this.getLastHurtByMob() != null) {
+    public boolean hurt(DamageSource source, @javax.annotation.Nullable Entity damagerEntity, @javax.annotation.Nullable final org.bukkit.block.Block damagerBlock, float amount) {
+        if (super.hurt(source, damagerEntity, damagerBlock, amount) && this.getLastHurtByMob() != null) {
             if (!this.level.isClientSide) {
                 this.spawnInk();
             }
diff --git a/src/main/java/net/minecraft/world/entity/animal/Turtle.java b/src/main/java/net/minecraft/world/entity/animal/Turtle.java
index 73526ba0228633185f6f4628bf5b22e4497aea33..f5542b76d560834e5d42428ff67defd11fba6bc1 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Turtle.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Turtle.java
@@ -336,9 +336,7 @@ public class Turtle extends Animal {
 
     @Override
     public void thunderHit(ServerLevel world, LightningBolt lightning) {
-        org.bukkit.craftbukkit.event.CraftEventFactory.entityDamage = lightning; // CraftBukkit
-        this.hurt(DamageSource.LIGHTNING_BOLT, Float.MAX_VALUE);
-        org.bukkit.craftbukkit.event.CraftEventFactory.entityDamage = null; // CraftBukkit
+        this.hurt(DamageSource.LIGHTNING_BOLT, lightning, null, Float.MAX_VALUE);
     }
 
     private static class TurtleMoveControl extends MoveControl {
diff --git a/src/main/java/net/minecraft/world/entity/animal/WaterAnimal.java b/src/main/java/net/minecraft/world/entity/animal/WaterAnimal.java
index 18389f46902bb9879ac6d734723e9a720724dc48..adf92c9c02db3617be6b8c397c1d7085ea246838 100644
--- a/src/main/java/net/minecraft/world/entity/animal/WaterAnimal.java
+++ b/src/main/java/net/minecraft/world/entity/animal/WaterAnimal.java
@@ -51,7 +51,7 @@ public abstract class WaterAnimal extends PathfinderMob {
             this.setAirSupply(air - 1);
             if (this.getAirSupply() == -20) {
                 this.setAirSupply(0);
-                this.hurt(DamageSource.DROWN, 2.0F);
+                this.hurt(DamageSource.DROWN, null, null, 2.0F);
             }
         } else {
             this.setAirSupply(300);
diff --git a/src/main/java/net/minecraft/world/entity/animal/Wolf.java b/src/main/java/net/minecraft/world/entity/animal/Wolf.java
index 636566ac5ebf47913795fc74daeba83334a311f2..510c43da24e077edde4ea5a17369d3237b5f44c0 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Wolf.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Wolf.java
@@ -69,6 +69,7 @@ import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.pathfinder.BlockPathTypes;
 import net.minecraft.world.phys.Vec3;
 // CraftBukkit start
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.entity.EntityTargetEvent.TargetReason;
 // CraftBukkit end
@@ -313,7 +314,7 @@ public class Wolf extends TamableAnimal implements NeutralMob {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.isInvulnerableTo(source)) {
             return false;
         } else {
@@ -327,13 +328,13 @@ public class Wolf extends TamableAnimal implements NeutralMob {
                 amount = (amount + 1.0F) / 2.0F;
             }
 
-            return super.hurt(source, amount);
+            return super.hurt(source, damagerEntity, damagerBlock, amount);
         }
     }
 
     @Override
     public boolean doHurtTarget(Entity target) {
-        boolean flag = target.hurt(DamageSource.mobAttack(this), (float) ((int) this.getAttributeValue(Attributes.ATTACK_DAMAGE)));
+        boolean flag = target.hurt(DamageSource.mobAttack(this), this, null, (float) ((int) this.getAttributeValue(Attributes.ATTACK_DAMAGE)));
 
         if (flag) {
             this.doEnchantDamageEffects(this, target);
diff --git a/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java b/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java
index e9e73ec92655c3e4aa38526f5762e9d3aa4a6cf5..15e80e7d1f38c812c8a0a84f1d23931278b8b109 100644
--- a/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java
+++ b/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java
@@ -68,6 +68,7 @@ import net.minecraft.world.level.gameevent.PositionSource;
 import net.minecraft.world.level.gameevent.vibrations.VibrationListener;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.block.Block;
 import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 
@@ -182,12 +183,12 @@ public class Allay extends PathfinderMob implements InventoryCarrier {
     }
 
     @Override
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
+    public boolean causeFallDamage(float fallDistance, final @javax.annotation.Nullable Entity damagerEntity, final Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
         return false;
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         Entity entity = source.getEntity();
 
         if (entity instanceof Player) {
@@ -199,7 +200,7 @@ public class Allay extends PathfinderMob implements InventoryCarrier {
             }
         }
 
-        return super.hurt(source, amount);
+        return super.hurt(source, damagerEntity, damagerBlock, amount);
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/animal/axolotl/Axolotl.java b/src/main/java/net/minecraft/world/entity/animal/axolotl/Axolotl.java
index ff06e6075c3dd6bb6c40b256a3d7ffbe8dd6ef7d..9324986c0c260beb1195877bc4e5d494536c5a76 100644
--- a/src/main/java/net/minecraft/world/entity/animal/axolotl/Axolotl.java
+++ b/src/main/java/net/minecraft/world/entity/animal/axolotl/Axolotl.java
@@ -62,6 +62,7 @@ import net.minecraft.world.level.LevelReader;
 import net.minecraft.world.level.ServerLevelAccessor;
 import net.minecraft.world.level.pathfinder.BlockPathTypes;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.slf4j.Logger;
 
 public class Axolotl extends Animal implements LerpingModel, Bucketable {
@@ -178,7 +179,7 @@ public class Axolotl extends Animal implements LerpingModel, Bucketable {
             this.setAirSupply(air - 1);
             if (this.getAirSupply() == -20) {
                 this.setAirSupply(0);
-                this.hurt(DamageSource.DRY_OUT, 2.0F);
+                this.hurt(DamageSource.DRY_OUT, null, null, 2.0F);
             }
         } else {
             this.setAirSupply(this.getMaxAirSupply());
@@ -310,7 +311,7 @@ public class Axolotl extends Animal implements LerpingModel, Bucketable {
 
     @Override
     public boolean doHurtTarget(Entity target) {
-        boolean flag = target.hurt(DamageSource.mobAttack(this), (float) ((int) this.getAttributeValue(Attributes.ATTACK_DAMAGE)));
+        boolean flag = target.hurt(DamageSource.mobAttack(this), this, null, (float) ((int) this.getAttributeValue(Attributes.ATTACK_DAMAGE)));
 
         if (flag) {
             this.doEnchantDamageEffects(this, target);
@@ -321,14 +322,14 @@ public class Axolotl extends Animal implements LerpingModel, Bucketable {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @org.jetbrains.annotations.Nullable Entity damagerEntity, @org.jetbrains.annotations.Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         float f1 = this.getHealth();
 
         if (!this.level.isClientSide && !this.isNoAi() && this.level.random.nextInt(3) == 0 && ((float) this.level.random.nextInt(3) < amount || f1 / this.getMaxHealth() < 0.5F) && amount < f1 && this.isInWater() && (source.getEntity() != null || source.getDirectEntity() != null) && !this.isPlayingDead()) {
             this.brain.setMemory(MemoryModuleType.PLAY_DEAD_TICKS, Integer.valueOf(200));
         }
 
-        return super.hurt(source, amount);
+        return super.hurt(source, damagerEntity, damagerBlock, amount);
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/animal/horse/AbstractHorse.java b/src/main/java/net/minecraft/world/entity/animal/horse/AbstractHorse.java
index fa6f33f67b7b479141b55998543bb7eb430f95ba..fd2e15af61be8b1606d7de22fa86d1a6e1e3cbae 100644
--- a/src/main/java/net/minecraft/world/entity/animal/horse/AbstractHorse.java
+++ b/src/main/java/net/minecraft/world/entity/animal/horse/AbstractHorse.java
@@ -71,6 +71,7 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.block.Block;
 import org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason; // CraftBukkit
 
 public abstract class AbstractHorse extends Animal implements ContainerListener, HasCustomInventoryScreen, PlayerRideableJumping, Saddleable {
@@ -260,7 +261,7 @@ public abstract class AbstractHorse extends Animal implements ContainerListener,
     }
 
     @Override
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
+    public boolean causeFallDamage(float fallDistance, final @Nullable Entity damagerEntity, final Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
         if (fallDistance > 1.0F) {
             this.playSound(SoundEvents.HORSE_LAND, 0.4F, 1.0F);
         }
@@ -270,14 +271,14 @@ public abstract class AbstractHorse extends Animal implements ContainerListener,
         if (i <= 0) {
             return false;
         } else {
-            this.hurt(damageSource, (float) i);
+            this.hurt(damageSource, null, null, (float) i);
             if (this.isVehicle()) {
                 Iterator iterator = this.getIndirectPassengers().iterator();
 
                 while (iterator.hasNext()) {
                     Entity entity = (Entity) iterator.next();
 
-                    entity.hurt(damageSource, (float) i);
+                    entity.hurt(damageSource, null, null, (float) i);
                 }
             }
 
diff --git a/src/main/java/net/minecraft/world/entity/animal/horse/Llama.java b/src/main/java/net/minecraft/world/entity/animal/horse/Llama.java
index 016c8b3152ad1006476f23801ec61f4a87d094ef..4e5ecf0eda582b2a3b02898e3b62ac5a8856b988 100644
--- a/src/main/java/net/minecraft/world/entity/animal/horse/Llama.java
+++ b/src/main/java/net/minecraft/world/entity/animal/horse/Llama.java
@@ -428,21 +428,21 @@ public class Llama extends AbstractChestedHorse implements RangedAttackMob {
     }
 
     @Override
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
+    public boolean causeFallDamage(float fallDistance, final @Nullable Entity damagerEntity, final org.bukkit.block.Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
         int i = this.calculateFallDamage(fallDistance, damageMultiplier);
 
         if (i <= 0) {
             return false;
         } else {
             if (fallDistance >= 6.0F) {
-                this.hurt(damageSource, (float) i);
+                this.hurt(damageSource, null, null, (float) i);
                 if (this.isVehicle()) {
                     Iterator iterator = this.getIndirectPassengers().iterator();
 
                     while (iterator.hasNext()) {
                         Entity entity = (Entity) iterator.next();
 
-                        entity.hurt(damageSource, (float) i);
+                        entity.hurt(damageSource, null, null, (float) i);
                     }
                 }
             }
diff --git a/src/main/java/net/minecraft/world/entity/boss/EnderDragonPart.java b/src/main/java/net/minecraft/world/entity/boss/EnderDragonPart.java
index 305a891e4b51d1031d9e9238ff00e2ea7de8d954..7a8d10e66332bf6315011921c0e9d2f0842d49cd 100644
--- a/src/main/java/net/minecraft/world/entity/boss/EnderDragonPart.java
+++ b/src/main/java/net/minecraft/world/entity/boss/EnderDragonPart.java
@@ -8,6 +8,9 @@ import net.minecraft.world.entity.EntityDimensions;
 import net.minecraft.world.entity.Pose;
 import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
 
+import javax.annotation.Nullable;
+
+
 public class EnderDragonPart extends Entity {
     public final EnderDragon parentMob;
     public final String name;
@@ -39,8 +42,8 @@ public class EnderDragonPart extends Entity {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
-        return this.isInvulnerableTo(source) ? false : this.parentMob.hurt(this, source, amount);
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
+        return !this.isInvulnerableTo(source) && this.parentMob.hurt(this, damagerEntity, damagerBlock, source, amount);
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java
index b417eb4f5508dec3804d5c046886b6332117be30..b2305f96a295060cc5d09ce2cb62b5bc1bff8689 100644
--- a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java
+++ b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java
@@ -21,6 +21,7 @@ import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.BaseFireBlock;
 import net.minecraft.world.level.dimension.end.EndDragonFight;
 // CraftBukkit start
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.entity.ExplosionPrimeEvent;
 // CraftBukkit end
@@ -111,7 +112,7 @@ public class EndCrystal extends Entity {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.isInvulnerableTo(source)) {
             return false;
         } else if (source.getEntity() instanceof EnderDragon) {
@@ -119,7 +120,7 @@ public class EndCrystal extends Entity {
         } else {
             if (!this.isRemoved() && !this.level.isClientSide) {
                 // CraftBukkit start - All non-living entities need this
-                if (CraftEventFactory.handleNonLivingEntityDamageEvent(this, source, amount, false)) {
+                if (CraftEventFactory.handleNonLivingEntityDamageEvent(this, damagerEntity, damagerBlock, source, amount, false)) {
                     return false;
                 }
                 // CraftBukkit end
diff --git a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
index 4a4efbdeae999c4ea2ded35259dd4af94b6282cc..e69bd19cd55c425686f6f748b9cbf8dde4d0a86d 100644
--- a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
+++ b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
@@ -451,7 +451,7 @@ public class EnderDragon extends Mob implements Enemy {
 
                 entity.push(d2 / d4 * 4.0D, 0.20000000298023224D, d3 / d4 * 4.0D);
                 if (!this.phaseManager.getCurrentPhase().isSitting() && ((LivingEntity) entity).getLastHurtByMobTimestamp() < entity.tickCount - 2) {
-                    entity.hurt(DamageSource.mobAttack(this), 5.0F);
+                    entity.hurt(DamageSource.mobAttack(this), this, null, 5.0F);
                     this.doEnchantDamageEffects(this, entity);
                 }
             }
@@ -466,7 +466,7 @@ public class EnderDragon extends Mob implements Enemy {
             Entity entity = (Entity) iterator.next();
 
             if (entity instanceof LivingEntity) {
-                entity.hurt(DamageSource.mobAttack(this), 10.0F);
+                entity.hurt(DamageSource.mobAttack(this), this, null, 10.0F);
                 this.doEnchantDamageEffects(this, entity);
             }
         }
@@ -570,7 +570,7 @@ public class EnderDragon extends Mob implements Enemy {
         return flag;
     }
 
-    public boolean hurt(EnderDragonPart part, DamageSource source, float amount) {
+    public boolean hurt(EnderDragonPart part, @org.jetbrains.annotations.Nullable Entity damagerEntity, @org.jetbrains.annotations.Nullable final org.bukkit.block.Block damagerBlock, DamageSource source, float amount) {
         if (this.phaseManager.getCurrentPhase().getPhase() == EnderDragonPhase.DYING) {
             return false;
         } else {
@@ -585,7 +585,7 @@ public class EnderDragon extends Mob implements Enemy {
                 if (source.getEntity() instanceof Player || source.isExplosion()) {
                     float f1 = this.getHealth();
 
-                    this.reallyHurt(source, amount);
+                    this.reallyHurt(source, damagerEntity, damagerBlock, amount);
                     if (this.isDeadOrDying() && !this.phaseManager.getCurrentPhase().isSitting()) {
                         this.setHealth(1.0F);
                         this.phaseManager.setPhase(EnderDragonPhase.DYING);
@@ -606,12 +606,12 @@ public class EnderDragon extends Mob implements Enemy {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
-        return !this.level.isClientSide ? this.hurt(this.body, source, amount) : false;
+    public boolean hurt(DamageSource source, @org.jetbrains.annotations.Nullable Entity damagerEntity, @org.jetbrains.annotations.Nullable final org.bukkit.block.Block damagerBlock, float amount) {
+        return !this.level.isClientSide && this.hurt(this.body, damagerEntity, damagerBlock, source, amount);
     }
 
-    protected boolean reallyHurt(DamageSource source, float amount) {
-        return super.hurt(source, amount);
+    protected boolean reallyHurt(DamageSource source, final @org.jetbrains.annotations.Nullable Entity damagerEntity, final org.bukkit.block.@org.jetbrains.annotations.Nullable Block damagerBlock, float amount) {
+        return super.hurt(source, damagerEntity, damagerBlock, amount);
     }
 
     @Override
@@ -1038,7 +1038,7 @@ public class EnderDragon extends Mob implements Enemy {
         }
 
         if (crystal == this.nearestCrystal) {
-            this.hurt(this.head, DamageSource.explosion(entityhuman), 10.0F);
+            this.hurt(this.head, entityhuman, null, DamageSource.explosion(entityhuman), 10.0F);
         }
 
         this.phaseManager.getCurrentPhase().onCrystalDestroyed(crystal, pos, source, entityhuman);
diff --git a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
index a73ba369b2a8950c20b2de6405a52d9cdc136fd8..6a367c6c1eb25da7779f67b105a9a4aa96b7d432 100644
--- a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
+++ b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
@@ -37,7 +37,6 @@ import net.minecraft.world.entity.projectile.WitherSkull;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.level.Explosion;
 import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.particles.ParticleTypes;
@@ -47,7 +46,6 @@ import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.network.syncher.EntityDataSerializers;
 import net.minecraft.network.syncher.SynchedEntityData;
-import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerBossEvent;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
@@ -58,6 +56,7 @@ import net.minecraft.util.Mth;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.block.Block;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.entity.EntityRegainHealthEvent;
 import org.bukkit.event.entity.EntityTargetEvent;
@@ -495,7 +494,7 @@ public class WitherBoss extends Monster implements PowerableMob, RangedAttackMob
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.isInvulnerableTo(source)) {
             return false;
         } else if (source != DamageSource.DROWN && !(source.getEntity() instanceof WitherBoss)) {
@@ -523,7 +522,7 @@ public class WitherBoss extends Monster implements PowerableMob, RangedAttackMob
                         this.idleHeadUpdates[i] += 3;
                     }
 
-                    return super.hurt(source, amount);
+                    return super.hurt(source, damagerEntity, damagerBlock, amount);
                 }
             }
         } else {
@@ -552,7 +551,7 @@ public class WitherBoss extends Monster implements PowerableMob, RangedAttackMob
     }
 
     @Override
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
+    public boolean causeFallDamage(float fallDistance, final @Nullable Entity damagerEntity, final Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
         return false;
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/decoration/ArmorStand.java b/src/main/java/net/minecraft/world/entity/decoration/ArmorStand.java
index 6966f68f1f2c880082596de32a4f68d42480cac0..9b872f47e523a5b31e7d79b93358ebefdbb71a66 100644
--- a/src/main/java/net/minecraft/world/entity/decoration/ArmorStand.java
+++ b/src/main/java/net/minecraft/world/entity/decoration/ArmorStand.java
@@ -34,13 +34,13 @@ import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LightLayer;
-import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.material.PushReaction;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 // CraftBukkit start
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.inventory.EquipmentSlot;
 import org.bukkit.craftbukkit.CraftEquipmentSlot;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
@@ -479,11 +479,11 @@ public class ArmorStand extends LivingEntity {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (!this.level.isClientSide && !this.isRemoved()) {
             if (DamageSource.OUT_OF_WORLD.equals(source)) {
                 // CraftBukkit start
-                if (org.bukkit.craftbukkit.event.CraftEventFactory.handleNonLivingEntityDamageEvent(this, source, amount)) {
+                if (org.bukkit.craftbukkit.event.CraftEventFactory.handleNonLivingEntityDamageEvent(this, damagerEntity, damagerBlock, source, amount)) {
                     return false;
                 }
                 // CraftBukkit end
@@ -491,7 +491,7 @@ public class ArmorStand extends LivingEntity {
                 return false;
             } else if (!this.isInvulnerableTo(source) && (true || !this.invisible) && !this.isMarker()) { // CraftBukkit
                 // CraftBukkit start
-                if (org.bukkit.craftbukkit.event.CraftEventFactory.handleNonLivingEntityDamageEvent(this, source, amount, true, this.invisible)) {
+                if (org.bukkit.craftbukkit.event.CraftEventFactory.handleNonLivingEntityDamageEvent(this, damagerEntity, damagerBlock, source, amount, true, this.invisible)) {
                     return false;
                 }
                 // CraftBukkit end
diff --git a/src/main/java/net/minecraft/world/entity/decoration/HangingEntity.java b/src/main/java/net/minecraft/world/entity/decoration/HangingEntity.java
index 84ef22e77af60014df5eda1116eabf6cf1e7cce8..ba7de57958011333c85d9b4652bcb284491f30fc 100644
--- a/src/main/java/net/minecraft/world/entity/decoration/HangingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/decoration/HangingEntity.java
@@ -18,6 +18,7 @@ import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
 import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.slf4j.Logger;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.DiodeBlock;
@@ -185,7 +186,7 @@ public abstract class HangingEntity extends Entity {
         if (attacker instanceof Player) {
             Player entityhuman = (Player) attacker;
 
-            return !this.level.mayInteract(entityhuman, this.pos) ? true : this.hurt(DamageSource.playerAttack(entityhuman), 0.0F);
+            return !this.level.mayInteract(entityhuman, this.pos) ? true : this.hurt(DamageSource.playerAttack(entityhuman), entityhuman, null, 0.0F);
         } else {
             return false;
         }
@@ -197,7 +198,7 @@ public abstract class HangingEntity extends Entity {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.isInvulnerableTo(source)) {
             return false;
         } else {
diff --git a/src/main/java/net/minecraft/world/entity/decoration/ItemFrame.java b/src/main/java/net/minecraft/world/entity/decoration/ItemFrame.java
index 3174542c1725447c33e2773d63633ffe4d766253..6ff861dde33c0bb30bb02a69252ad8a0c3996673 100644
--- a/src/main/java/net/minecraft/world/entity/decoration/ItemFrame.java
+++ b/src/main/java/net/minecraft/world/entity/decoration/ItemFrame.java
@@ -37,6 +37,7 @@ import net.minecraft.world.level.saveddata.maps.MapItemSavedData;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.slf4j.Logger;
 
 public class ItemFrame extends HangingEntity {
@@ -176,15 +177,15 @@ public class ItemFrame extends HangingEntity {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.fixed) {
-            return source != DamageSource.OUT_OF_WORLD && !source.isCreativePlayer() ? false : super.hurt(source, amount);
+            return source != DamageSource.OUT_OF_WORLD && !source.isCreativePlayer() ? false : super.hurt(source, damagerEntity, damagerBlock, amount);
         } else if (this.isInvulnerableTo(source)) {
             return false;
         } else if (!source.isExplosion() && !this.getItem().isEmpty()) {
             if (!this.level.isClientSide) {
                 // CraftBukkit start - fire EntityDamageEvent
-                if (org.bukkit.craftbukkit.event.CraftEventFactory.handleNonLivingEntityDamageEvent(this, source, amount, false) || this.isRemoved()) {
+                if (org.bukkit.craftbukkit.event.CraftEventFactory.handleNonLivingEntityDamageEvent(this, damagerEntity, damagerBlock, source, amount, false) || this.isRemoved()) {
                     return true;
                 }
                 // CraftBukkit end
@@ -201,7 +202,7 @@ public class ItemFrame extends HangingEntity {
 
             return true;
         } else {
-            return super.hurt(source, amount);
+            return super.hurt(source, damagerEntity, damagerBlock, amount);
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
index 4cfcf8f033835479078e52ecbe246f32d38b5875..680885de92d7a2cb991426a6be4287daa8e324d3 100644
--- a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
+++ b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
@@ -25,11 +25,9 @@ import net.minecraft.world.entity.EntitySelector;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.MoverType;
 import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.item.context.BlockPlaceContext;
 import net.minecraft.world.item.context.DirectionalPlaceContext;
 import net.minecraft.world.level.ClipContext;
 import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.AnvilBlock;
 import net.minecraft.world.level.block.Block;
@@ -265,7 +263,7 @@ public class FallingBlockEntity extends Entity {
     }
 
     @Override
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
+    public boolean causeFallDamage(float fallDistance, final @Nullable Entity damagerEntity, final org.bukkit.block.Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
         if (!this.hurtEntities) {
             return false;
         } else {
@@ -290,9 +288,7 @@ public class FallingBlockEntity extends Entity {
                 float f2 = (float) Math.min(Mth.floor((float) i * this.fallDamagePerDistance), this.fallDamageMax);
 
                 this.level.getEntities(this, this.getBoundingBox(), predicate).forEach((entity) -> {
-                    CraftEventFactory.entityDamage = this; // CraftBukkit
-                    entity.hurt(damagesource1, f2);
-                    CraftEventFactory.entityDamage = null; // CraftBukkit
+                    entity.hurt(damagesource1, this, null, f2);
                 });
                 boolean flag = this.blockState.is(BlockTags.ANVIL);
 
diff --git a/src/main/java/net/minecraft/world/entity/item/ItemEntity.java b/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
index abb7dc09ab498ca39aa1f7c22dc14af83fb9a138..e5b6f7a0f322171d2b3d9878356ca16bc02a468a 100644
--- a/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
+++ b/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
@@ -33,6 +33,7 @@ import net.minecraft.stats.Stats;
 import net.minecraft.tags.FluidTags;
 import net.minecraft.tags.ItemTags;
 import net.minecraft.util.Mth;
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.event.entity.EntityPickupItemEvent;
 import org.bukkit.event.player.PlayerPickupItemEvent;
 // CraftBukkit end
@@ -324,7 +325,7 @@ public class ItemEntity extends Entity {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.isInvulnerableTo(source)) {
             return false;
         } else if (!this.getItem().isEmpty() && this.getItem().is(Items.NETHER_STAR) && source.isExplosion()) {
@@ -335,7 +336,7 @@ public class ItemEntity extends Entity {
             return true;
         } else {
             // CraftBukkit start
-            if (org.bukkit.craftbukkit.event.CraftEventFactory.handleNonLivingEntityDamageEvent(this, source, amount)) {
+            if (org.bukkit.craftbukkit.event.CraftEventFactory.handleNonLivingEntityDamageEvent(this, damagerEntity, damagerBlock, source, amount)) {
                 return false;
             }
             // CraftBukkit end
diff --git a/src/main/java/net/minecraft/world/entity/monster/Blaze.java b/src/main/java/net/minecraft/world/entity/monster/Blaze.java
index 4595b734abb88df7da6dddf7b24c6c5ffcf6556a..7d68f61f58c16de2b324d70273c29a44302dfdac 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Blaze.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Blaze.java
@@ -8,6 +8,7 @@ import net.minecraft.network.syncher.SynchedEntityData;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.ai.attributes.AttributeSupplier;
@@ -25,6 +26,9 @@ import net.minecraft.world.level.Level;
 import net.minecraft.world.level.pathfinder.BlockPathTypes;
 import net.minecraft.world.phys.Vec3;
 
+import javax.annotation.Nullable;
+
+
 public class Blaze extends Monster {
     private float allowedHeightOffset = 0.5F;
     private int nextHeightOffsetChangeTick;
@@ -123,7 +127,7 @@ public class Blaze extends Monster {
     }
 
     @Override
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
+    public boolean causeFallDamage(float fallDistance, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
         return false;
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/monster/Creeper.java b/src/main/java/net/minecraft/world/entity/monster/Creeper.java
index b0fd15d8e0d454e16b34755c1d16130be7123499..4ae76a8886d465fff46d7ddf4d2679abc81659b2 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Creeper.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Creeper.java
@@ -40,11 +40,11 @@ import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.level.Explosion;
 import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.gameevent.GameEvent;
 
 // CraftBukkit start
+import org.bukkit.block.Block;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.entity.CreatureSpawnEvent;
 import org.bukkit.event.entity.ExplosionPrimeEvent;
@@ -89,8 +89,8 @@ public class Creeper extends Monster implements PowerableMob {
     }
 
     @Override
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
-        boolean flag = super.causeFallDamage(fallDistance, damageMultiplier, damageSource);
+    public boolean causeFallDamage(float fallDistance, final @Nullable Entity damagerEntity, final Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
+        boolean flag = super.causeFallDamage(fallDistance, damagerEntity, damagerBlock, damageMultiplier, damageSource);
 
         this.swell += (int) (fallDistance * 1.5F);
         if (this.swell > this.maxSwell - 5) {
diff --git a/src/main/java/net/minecraft/world/entity/monster/EnderMan.java b/src/main/java/net/minecraft/world/entity/monster/EnderMan.java
index a0c6869488f1de1be1ea029c0d1073fc2ed4fc2c..cb0e11ba8439f4faa09a59971ff831916c222fd6 100644
--- a/src/main/java/net/minecraft/world/entity/monster/EnderMan.java
+++ b/src/main/java/net/minecraft/world/entity/monster/EnderMan.java
@@ -54,7 +54,6 @@ import net.minecraft.world.item.alchemy.PotionUtils;
 import net.minecraft.world.item.alchemy.Potions;
 import net.minecraft.world.level.ClipContext;
 import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
@@ -64,6 +63,8 @@ import net.minecraft.world.level.pathfinder.BlockPathTypes;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.craftbukkit.block.CraftBlock;
+
 
 public class EnderMan extends Monster implements NeutralMob {
 
@@ -379,7 +380,7 @@ public class EnderMan extends Monster implements NeutralMob {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.isInvulnerableTo(source)) {
             return false;
         } else if (source instanceof IndirectEntityDamageSource) {
@@ -387,7 +388,7 @@ public class EnderMan extends Monster implements NeutralMob {
             boolean flag;
 
             if (entity instanceof ThrownPotion) {
-                flag = this.hurtWithCleanWater(source, (ThrownPotion) entity, amount);
+                flag = this.hurtWithCleanWater(source, damagerEntity, damagerBlock, (ThrownPotion) entity, amount);
             } else {
                 flag = false;
             }
@@ -402,7 +403,7 @@ public class EnderMan extends Monster implements NeutralMob {
 
             return flag;
         } else {
-            boolean flag1 = super.hurt(source, amount);
+            boolean flag1 = super.hurt(source, damagerEntity, damagerBlock, amount);
 
             if (!this.level.isClientSide() && !(source.getEntity() instanceof LivingEntity) && this.random.nextInt(10) != 0 && this.tryEscape(source == DamageSource.DROWN ? com.destroystokyo.paper.event.entity.EndermanEscapeEvent.Reason.DROWN : com.destroystokyo.paper.event.entity.EndermanEscapeEvent.Reason.INDIRECT)) { // Paper - use to be critical hits as else, but mojang removed critical hits in 1.16.2 due to MC-185684
                 this.teleport();
@@ -412,13 +413,13 @@ public class EnderMan extends Monster implements NeutralMob {
         }
     }
 
-    private boolean hurtWithCleanWater(DamageSource source, ThrownPotion potion, float amount) {
+    private boolean hurtWithCleanWater(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, ThrownPotion potion, float amount) {
         ItemStack itemstack = potion.getItem();
         Potion potionregistry = PotionUtils.getPotion(itemstack);
         List<MobEffectInstance> list = PotionUtils.getMobEffects(itemstack);
         boolean flag = potionregistry == Potions.WATER && list.isEmpty();
 
-        return flag ? super.hurt(source, amount) : false;
+        return flag && super.hurt(source, damagerEntity, damagerBlock, amount);
     }
 
     public boolean isCreepy() {
@@ -617,7 +618,7 @@ public class EnderMan extends Monster implements NeutralMob {
                     return true;
                 }
             } else {
-                return this.target != null && this.continueAggroTargetConditions.test(this.enderman, this.target) ? true : super.canContinueToUse();
+                return this.target.get() != null && this.continueAggroTargetConditions.test(this.enderman, this.target.get()) || super.canContinueToUse();
             }
         }
 
@@ -629,19 +630,20 @@ public class EnderMan extends Monster implements NeutralMob {
 
             if (this.pendingTarget != null) {
                 if (--this.aggroTime <= 0) {
-                    this.target = this.pendingTarget;
+                    this.target.set(this.pendingTarget);
                     this.pendingTarget = null;
                     super.start();
                 }
             } else {
-                if (this.target != null && !this.enderman.isPassenger()) {
-                    if (this.enderman.isLookingAtMe((Player) this.target)) {
-                        if (this.target.distanceToSqr(this.enderman) < 16.0D && this.enderman.tryEscape(com.destroystokyo.paper.event.entity.EndermanEscapeEvent.Reason.STARE)) { // Paper
+                final LivingEntity target = this.target.get();
+                if (target != null && !this.enderman.isPassenger()) {
+                    if (this.enderman.isLookingAtMe((Player) target)) {
+                        if (target.distanceToSqr(this.enderman) < 16.0D && this.enderman.tryEscape(com.destroystokyo.paper.event.entity.EndermanEscapeEvent.Reason.STARE)) { // Paper
                             this.enderman.teleport();
                         }
 
                         this.teleportTime = 0;
-                    } else if (this.target.distanceToSqr(this.enderman) > 256.0D && this.teleportTime++ >= this.adjustedTickDelay(30) && this.enderman.teleportTowards(this.target)) {
+                    } else if (target.distanceToSqr(this.enderman) > 256.0D && this.teleportTime++ >= this.adjustedTickDelay(30) && this.enderman.teleportTowards(target)) {
                         this.teleportTime = 0;
                     }
                 }
diff --git a/src/main/java/net/minecraft/world/entity/monster/Ghast.java b/src/main/java/net/minecraft/world/entity/monster/Ghast.java
index f20dba357bdefbcc535f075d8d9a745fcefac4c3..d151b07db1d26c6600fb3e15771162ee3cf095ca 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Ghast.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Ghast.java
@@ -13,14 +13,7 @@ import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.Difficulty;
 import net.minecraft.world.damagesource.DamageSource;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.EntityDimensions;
-import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.FlyingMob;
-import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.Mob;
-import net.minecraft.world.entity.MobSpawnType;
-import net.minecraft.world.entity.Pose;
+import net.minecraft.world.entity.*;
 import net.minecraft.world.entity.ai.attributes.AttributeSupplier;
 import net.minecraft.world.entity.ai.attributes.Attributes;
 import net.minecraft.world.entity.ai.control.MoveControl;
@@ -32,6 +25,10 @@ import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.craftbukkit.block.CraftBlock;
+
+import javax.annotation.Nullable;
+
 
 public class Ghast extends FlyingMob implements Enemy {
 
@@ -87,12 +84,12 @@ public class Ghast extends FlyingMob implements Enemy {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (Ghast.isReflectedFireball(source)) {
-            super.hurt(source, 1000.0F);
+            super.hurt(source, damagerEntity, damagerBlock, 1000.0F);
             return true;
         } else {
-            return this.isInvulnerableTo(source) ? false : super.hurt(source, amount);
+            return this.isInvulnerableTo(source) ? false : super.hurt(source, damagerEntity, damagerBlock, amount);
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/monster/Guardian.java b/src/main/java/net/minecraft/world/entity/monster/Guardian.java
index 2f43700c01a0f0a4749f56d3f6294cf648b10f51..be2d20f9898ea192678152ce840cf6350f252eed 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Guardian.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Guardian.java
@@ -307,11 +307,11 @@ public class Guardian extends Monster {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (!this.isMoving() && !source.isMagic() && source.getDirectEntity() instanceof LivingEntity) {
             LivingEntity livingEntity = (LivingEntity)source.getDirectEntity();
             if (!source.isExplosion()) {
-                livingEntity.hurt(DamageSource.thorns(this), 2.0F);
+                livingEntity.hurt(DamageSource.thorns(this), damagerEntity, damagerBlock, 2.0F);
             }
         }
 
@@ -319,7 +319,7 @@ public class Guardian extends Monster {
             this.randomStrollGoal.trigger();
         }
 
-        return super.hurt(source, amount);
+        return super.hurt(source, damagerEntity, damagerBlock, amount);
     }
 
     @Override
@@ -413,8 +413,8 @@ public class Guardian extends Monster {
                             f += 2.0F;
                         }
 
-                        livingEntity.hurt(DamageSource.indirectMagic(this.guardian, this.guardian), f);
-                        livingEntity.hurt(DamageSource.mobAttack(this.guardian), (float)this.guardian.getAttributeValue(Attributes.ATTACK_DAMAGE));
+                        livingEntity.hurt(DamageSource.indirectMagic(this.guardian, this.guardian), this.guardian, null, f);
+                        livingEntity.hurt(DamageSource.mobAttack(this.guardian), this.guardian, null, (float)this.guardian.getAttributeValue(Attributes.ATTACK_DAMAGE));
                         this.guardian.setTarget((LivingEntity)null);
                     }
 
diff --git a/src/main/java/net/minecraft/world/entity/monster/MagmaCube.java b/src/main/java/net/minecraft/world/entity/monster/MagmaCube.java
index ea4fa9eba301e462c159cdb970079f6d87d25f4d..455a6168e667c7b5b28f50f2a7f95c3b078e0534 100644
--- a/src/main/java/net/minecraft/world/entity/monster/MagmaCube.java
+++ b/src/main/java/net/minecraft/world/entity/monster/MagmaCube.java
@@ -10,6 +10,7 @@ import net.minecraft.tags.TagKey;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.Difficulty;
 import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.MobSpawnType;
 import net.minecraft.world.entity.ai.attributes.AttributeSupplier;
@@ -20,13 +21,16 @@ import net.minecraft.world.level.LevelReader;
 import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.phys.Vec3;
 
+import javax.annotation.Nullable;
+
+
 public class MagmaCube extends Slime {
     public MagmaCube(EntityType<? extends MagmaCube> type, Level world) {
         super(type, world);
     }
 
     public static AttributeSupplier.Builder createAttributes() {
-        return Monster.createMonsterAttributes().add(Attributes.MOVEMENT_SPEED, (double)0.2F);
+        return Monster.createMonsterAttributes().add(Attributes.MOVEMENT_SPEED, 0.2F);
     }
 
     public static boolean checkMagmaCubeSpawnRules(EntityType<MagmaCube> type, LevelAccessor world, MobSpawnType spawnReason, BlockPos pos, RandomSource random) {
@@ -41,7 +45,7 @@ public class MagmaCube extends Slime {
     @Override
     public void setSize(int size, boolean heal) {
         super.setSize(size, heal);
-        this.getAttribute(Attributes.ARMOR).setBaseValue((double)(size * 3));
+        this.getAttribute(Attributes.ARMOR).setBaseValue(size * 3);
     }
 
     @Override
@@ -72,7 +76,7 @@ public class MagmaCube extends Slime {
     @Override
     protected void jumpFromGround() {
         Vec3 vec3 = this.getDeltaMovement();
-        this.setDeltaMovement(vec3.x, (double)(this.getJumpPower() + (float)this.getSize() * 0.1F), vec3.z);
+        this.setDeltaMovement(vec3.x, this.getJumpPower() + (float)this.getSize() * 0.1F, vec3.z);
         this.hasImpulse = true;
     }
 
@@ -80,7 +84,7 @@ public class MagmaCube extends Slime {
     protected void jumpInLiquid(TagKey<Fluid> fluid) {
         if (fluid == FluidTags.LAVA) {
             Vec3 vec3 = this.getDeltaMovement();
-            this.setDeltaMovement(vec3.x, (double)(0.22F + (float)this.getSize() * 0.05F), vec3.z);
+            this.setDeltaMovement(vec3.x, 0.22F + (float)this.getSize() * 0.05F, vec3.z);
             this.hasImpulse = true;
         } else {
             super.jumpInLiquid(fluid);
@@ -89,7 +93,7 @@ public class MagmaCube extends Slime {
     }
 
     @Override
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
+    public boolean causeFallDamage(float fallDistance, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
         return false;
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/monster/Ravager.java b/src/main/java/net/minecraft/world/entity/monster/Ravager.java
index f697c43da2ec7e449d31f879c65f96cc27a877b6..eab652ca8ad2c1ff8c58cdd4e182d386ba0c54a1 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Ravager.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Ravager.java
@@ -253,7 +253,7 @@ public class Ravager extends Raider {
             for (Iterator iterator = list.iterator(); iterator.hasNext(); this.strongKnockback(entityliving)) {
                 entityliving = (LivingEntity) iterator.next();
                 if (!(entityliving instanceof AbstractIllager)) {
-                    entityliving.hurt(DamageSource.mobAttack(this), 6.0F);
+                    entityliving.hurt(DamageSource.mobAttack(this), this, null, 6.0F);
                 }
             }
 
diff --git a/src/main/java/net/minecraft/world/entity/monster/Shulker.java b/src/main/java/net/minecraft/world/entity/monster/Shulker.java
index bf75d961be50ebffb9df364c3362ebcae78f7cfa..c16e89e3df40704d4eafcc35782e2e74f39fd84f 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Shulker.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Shulker.java
@@ -57,6 +57,7 @@ import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 import org.bukkit.Location;
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.event.entity.EntityTeleportEvent;
 // CraftBukkit end
 
@@ -444,7 +445,7 @@ public class Shulker extends AbstractGolem implements Enemy {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         Entity entity;
 
         if (this.isClosed()) {
@@ -454,7 +455,7 @@ public class Shulker extends AbstractGolem implements Enemy {
             }
         }
 
-        if (!super.hurt(source, amount)) {
+        if (!super.hurt(source, damagerEntity, damagerBlock, amount)) {
             return false;
         } else {
             if ((double) this.getHealth() < (double) this.getMaxHealth() * 0.5D && this.random.nextInt(4) == 0) {
@@ -618,9 +619,9 @@ public class Shulker extends AbstractGolem implements Enemy {
             Vector3f vector3fa1 = new Vector3f((float) baseblockposition.getX(), (float) baseblockposition.getY(), (float) baseblockposition.getZ());
 
             vector3fa1.cross(vector3fa);
-            double d0 = this.wantedX - this.mob.getX();
-            double d1 = this.wantedY - this.mob.getEyeY();
-            double d2 = this.wantedZ - this.mob.getZ();
+            double d0 = this.wantedX.get() - this.mob.getX();
+            double d1 = this.wantedY.get() - this.mob.getEyeY();
+            double d2 = this.wantedZ.get() - this.mob.getZ();
             Vector3f vector3fa2 = new Vector3f((float) d0, (float) d1, (float) d2);
             float f = vector3fa1.dot(vector3fa2);
             float f1 = vector3fa.dot(vector3fa2);
diff --git a/src/main/java/net/minecraft/world/entity/monster/Silverfish.java b/src/main/java/net/minecraft/world/entity/monster/Silverfish.java
index f8d0f42369fe8e745e72eaaadada6761c83ee2e8..ba2aae7356248ec9122e0441dce722ffc9b886bf 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Silverfish.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Silverfish.java
@@ -32,6 +32,8 @@ import net.minecraft.world.level.LevelReader;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.InfestedBlock;
 import net.minecraft.world.level.block.state.BlockState;
+import org.bukkit.craftbukkit.block.CraftBlock;
+
 
 public class Silverfish extends Monster {
 
@@ -94,7 +96,7 @@ public class Silverfish extends Monster {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.isInvulnerableTo(source)) {
             return false;
         } else {
@@ -102,7 +104,7 @@ public class Silverfish extends Monster {
                 this.friendsGoal.notifyHurt();
             }
 
-            return super.hurt(source, amount);
+            return super.hurt(source, damagerEntity, damagerBlock, amount);
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/monster/Slime.java b/src/main/java/net/minecraft/world/entity/monster/Slime.java
index 47a04aec1fd4cf9f453796820bfc9d464e731c6e..e1dacc26b07b9fae6da2f9ee23ee1236ba66b788 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Slime.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Slime.java
@@ -283,7 +283,7 @@ public class Slime extends Mob implements Enemy {
         if (this.isAlive()) {
             int i = this.getSize();
 
-            if (this.distanceToSqr(target) < 0.6D * (double) i * 0.6D * (double) i && this.hasLineOfSight(target) && target.hurt(DamageSource.mobAttack(this), this.getAttackDamage())) {
+            if (this.distanceToSqr(target) < 0.6D * (double) i * 0.6D * (double) i && this.hasLineOfSight(target) && target.hurt(DamageSource.mobAttack(this), this, null, this.getAttackDamage())) {
                 this.playSound(SoundEvents.SLIME_ATTACK, 1.0F, (this.random.nextFloat() - this.random.nextFloat()) * 0.2F + 1.0F);
                 this.doEnchantDamageEffects(this, target);
             }
diff --git a/src/main/java/net/minecraft/world/entity/monster/Vex.java b/src/main/java/net/minecraft/world/entity/monster/Vex.java
index c25e6dfd8b7a42104e293caed9f8e370900b52c8..7782cef6138282e3d86957fa55c842bea77f8d33 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Vex.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Vex.java
@@ -13,7 +13,6 @@ import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.damagesource.DamageSource;
-import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.EquipmentSlot;
 import net.minecraft.world.entity.LivingEntity;
@@ -78,7 +77,7 @@ public class Vex extends Monster {
         this.setNoGravity(true);
         if (this.hasLimitedLife && --this.limitedLifeTicks <= 0) {
             this.limitedLifeTicks = 20;
-            this.hurt(DamageSource.STARVE, 1.0F);
+            this.hurt(DamageSource.STARVE, null, null, 1.0F);
         }
 
     }
diff --git a/src/main/java/net/minecraft/world/entity/monster/Zoglin.java b/src/main/java/net/minecraft/world/entity/monster/Zoglin.java
index 056e4c2f7f632dadc0015710c032a0b718d46ff9..6b75ef1885d320f6150829c62317ec2399a18b1a 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Zoglin.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Zoglin.java
@@ -23,20 +23,7 @@ import net.minecraft.world.entity.MobType;
 import net.minecraft.world.entity.ai.Brain;
 import net.minecraft.world.entity.ai.attributes.AttributeSupplier;
 import net.minecraft.world.entity.ai.attributes.Attributes;
-import net.minecraft.world.entity.ai.behavior.BehaviorUtils;
-import net.minecraft.world.entity.ai.behavior.DoNothing;
-import net.minecraft.world.entity.ai.behavior.LookAtTargetSink;
-import net.minecraft.world.entity.ai.behavior.MeleeAttack;
-import net.minecraft.world.entity.ai.behavior.MoveToTargetSink;
-import net.minecraft.world.entity.ai.behavior.RandomStroll;
-import net.minecraft.world.entity.ai.behavior.RunIf;
-import net.minecraft.world.entity.ai.behavior.RunOne;
-import net.minecraft.world.entity.ai.behavior.RunSometimes;
-import net.minecraft.world.entity.ai.behavior.SetEntityLookTarget;
-import net.minecraft.world.entity.ai.behavior.SetWalkTargetFromAttackTargetIfTargetOutOfReach;
-import net.minecraft.world.entity.ai.behavior.SetWalkTargetFromLookTarget;
-import net.minecraft.world.entity.ai.behavior.StartAttacking;
-import net.minecraft.world.entity.ai.behavior.StopAttackingIfTargetInvalid;
+import net.minecraft.world.entity.ai.behavior.*;
 import net.minecraft.world.entity.ai.memory.MemoryModuleType;
 import net.minecraft.world.entity.ai.memory.NearestVisibleLivingEntities;
 import net.minecraft.world.entity.ai.sensing.Sensor;
@@ -47,6 +34,9 @@ import net.minecraft.world.entity.schedule.Activity;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.state.BlockState;
 
+import javax.annotation.Nullable;
+
+
 public class Zoglin extends Monster implements Enemy, HoglinBase {
     private static final EntityDataAccessor<Boolean> DATA_BABY_ID = SynchedEntityData.defineId(Zoglin.class, EntityDataSerializers.BOOLEAN);
     private static final int MAX_HEALTH = 40;
@@ -90,11 +80,11 @@ public class Zoglin extends Monster implements Enemy, HoglinBase {
     }
 
     private static void initIdleActivity(Brain<Zoglin> brain) {
-        brain.addActivity(Activity.IDLE, 10, ImmutableList.of(new StartAttacking<>(Zoglin::findNearestValidAttackTarget), new RunSometimes(new SetEntityLookTarget(8.0F), UniformInt.of(30, 60)), new RunOne(ImmutableList.of(Pair.of(new RandomStroll(0.4F), 2), Pair.of(new SetWalkTargetFromLookTarget(0.4F, 3), 2), Pair.of(new DoNothing(30, 60), 1)))));
+        brain.addActivity(Activity.IDLE, 10, ImmutableList.of(new StartAttacking<Zoglin>(Zoglin::findNearestValidAttackTarget), new RunSometimes<Zoglin>(new SetEntityLookTarget(8.0F), UniformInt.of(30, 60)), new RunOne<Zoglin>(ImmutableList.of(Pair.of(new RandomStroll(0.4F), 2), Pair.of(new SetWalkTargetFromLookTarget(0.4F, 3), 2), Pair.of(new DoNothing(30, 60), 1)))));
     }
 
     private static void initFightActivity(Brain<Zoglin> brain) {
-        brain.addActivityAndRemoveMemoryWhenStopped(Activity.FIGHT, 10, ImmutableList.of(new SetWalkTargetFromAttackTargetIfTargetOutOfReach(1.0F), new RunIf<>(Zoglin::isAdult, new MeleeAttack(40)), new RunIf<>(Zoglin::isBaby, new MeleeAttack(15)), new StopAttackingIfTargetInvalid()), MemoryModuleType.ATTACK_TARGET);
+        brain.addActivityAndRemoveMemoryWhenStopped(Activity.FIGHT, 10, ImmutableList.of(new SetWalkTargetFromAttackTargetIfTargetOutOfReach(1.0F), new RunIf<Zoglin>(Zoglin::isAdult, new MeleeAttack(40)), new RunIf<Zoglin>(Zoglin::isBaby, new MeleeAttack(15)), new StopAttackingIfTargetInvalid<Zoglin>()), MemoryModuleType.ATTACK_TARGET);
     }
 
     private Optional<? extends LivingEntity> findNearestValidAttackTarget() {
@@ -160,8 +150,8 @@ public class Zoglin extends Monster implements Enemy, HoglinBase {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
-        boolean bl = super.hurt(source, amount);
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
+        boolean bl = super.hurt(source, damagerEntity, damagerBlock, amount);
         if (this.level.isClientSide) {
             return false;
         } else if (bl && source.getEntity() instanceof LivingEntity) {
@@ -183,7 +173,7 @@ public class Zoglin extends Monster implements Enemy, HoglinBase {
 
     @Override
     public Brain<Zoglin> getBrain() {
-        return super.getBrain();
+        return (Brain<Zoglin>) super.getBrain();
     }
 
     protected void updateActivity() {
diff --git a/src/main/java/net/minecraft/world/entity/monster/Zombie.java b/src/main/java/net/minecraft/world/entity/monster/Zombie.java
index 9e0de1995c183aacdf604a93c08fb840804280c3..0b1dedbe6158c1a610399f79a71ddb494f319bf0 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Zombie.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Zombie.java
@@ -56,7 +56,6 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.core.BlockPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtOps;
-import net.minecraft.nbt.Tag;
 import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.network.syncher.EntityDataSerializers;
 import net.minecraft.network.syncher.SynchedEntityData;
@@ -67,6 +66,7 @@ import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.sounds.SoundSource;
 import net.minecraft.tags.FluidTags;
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.event.entity.CreatureSpawnEvent;
 import org.bukkit.event.entity.EntityCombustByEntityEvent;
 import org.bukkit.event.entity.EntityTargetEvent;
@@ -108,20 +108,20 @@ public class Zombie extends Monster {
     @Override
     protected void registerGoals() {
         if (level.paperConfig().entities.behavior.zombiesTargetTurtleEggs) this.goalSelector.addGoal(4, new Zombie.ZombieAttackTurtleEggGoal(this, 1.0D, 3)); // Paper
-        this.goalSelector.addGoal(8, new LookAtPlayerGoal(this, Player.class, 8.0F));
-        this.goalSelector.addGoal(8, new RandomLookAroundGoal(this));
+        //this.goalSelector.addGoal(8, new LookAtPlayerGoal(this, Player.class, 8.0F));
+        //this.goalSelector.addGoal(8, new RandomLookAroundGoal(this));
         this.addBehaviourGoals();
     }
 
     protected void addBehaviourGoals() {
         this.goalSelector.addGoal(2, new ZombieAttackGoal(this, 1.0D, false));
-        this.goalSelector.addGoal(6, new MoveThroughVillageGoal(this, 1.0D, true, 4, this::canBreakDoors));
-        this.goalSelector.addGoal(7, new WaterAvoidingRandomStrollGoal(this, 1.0D));
-        this.targetSelector.addGoal(1, (new HurtByTargetGoal(this)).setAlertOthers(ZombifiedPiglin.class));
+       // this.goalSelector.addGoal(6, new MoveThroughVillageGoal(this, 1.0D, true, 4, this::canBreakDoors));
+        //this.goalSelector.addGoal(7, new WaterAvoidingRandomStrollGoal(this, 1.0D));
+        //this.targetSelector.addGoal(1, (new HurtByTargetGoal(this)).setAlertOthers(ZombifiedPiglin.class));
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true));
-        if ( level.spigotConfig.zombieAggressiveTowardsVillager ) this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false)); // Spigot
-        this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, IronGolem.class, true));
-        this.targetSelector.addGoal(5, new NearestAttackableTargetGoal<>(this, Turtle.class, 10, true, false, Turtle.BABY_ON_LAND_SELECTOR));
+        //if ( level.spigotConfig.zombieAggressiveTowardsVillager ) this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false)); // Spigot
+        //this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, IronGolem.class, true));
+        //this.targetSelector.addGoal(5, new NearestAttackableTargetGoal<>(this, Turtle.class, 10, true, false, Turtle.BABY_ON_LAND_SELECTOR));
     }
 
     public static AttributeSupplier.Builder createAttributes() {
@@ -313,8 +313,8 @@ public class Zombie extends Monster {
     // Paper end
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
-        if (!super.hurt(source, amount)) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
+        if (!super.hurt(source, damagerEntity, damagerBlock, amount)) {
             return false;
         } else if (!(this.level instanceof ServerLevel)) {
             return false;
diff --git a/src/main/java/net/minecraft/world/entity/monster/hoglin/Hoglin.java b/src/main/java/net/minecraft/world/entity/monster/hoglin/Hoglin.java
index 1d751fe27c8c508d978f3801c188ee30022db026..48984002d34118a2bf7730bc420bbe8931b1a267 100644
--- a/src/main/java/net/minecraft/world/entity/monster/hoglin/Hoglin.java
+++ b/src/main/java/net/minecraft/world/entity/monster/hoglin/Hoglin.java
@@ -45,6 +45,8 @@ import net.minecraft.world.level.LevelReader;
 import net.minecraft.world.level.ServerLevelAccessor;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
+import org.bukkit.craftbukkit.block.CraftBlock;
+
 
 public class Hoglin extends Animal implements Enemy, HoglinBase {
     private static final EntityDataAccessor<Boolean> DATA_IMMUNE_TO_ZOMBIFICATION = SynchedEntityData.defineId(Hoglin.class, EntityDataSerializers.BOOLEAN);
@@ -98,8 +100,8 @@ public class Hoglin extends Animal implements Enemy, HoglinBase {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
-        boolean bl = super.hurt(source, amount);
+    public boolean hurt(DamageSource source,  @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
+        boolean bl = super.hurt(source, damagerEntity, damagerBlock, amount);
         if (this.level.isClientSide) {
             return false;
         } else {
diff --git a/src/main/java/net/minecraft/world/entity/monster/hoglin/HoglinAi.java b/src/main/java/net/minecraft/world/entity/monster/hoglin/HoglinAi.java
index 32dd3e712141c719e85be1038737ad2fa4ce01ba..acc64c776b1ab0ce87736fcb00339715d8ad4cc9 100644
--- a/src/main/java/net/minecraft/world/entity/monster/hoglin/HoglinAi.java
+++ b/src/main/java/net/minecraft/world/entity/monster/hoglin/HoglinAi.java
@@ -14,25 +14,7 @@ import net.minecraft.world.entity.AgeableMob;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.ai.Brain;
-import net.minecraft.world.entity.ai.behavior.AnimalMakeLove;
-import net.minecraft.world.entity.ai.behavior.BabyFollowAdult;
-import net.minecraft.world.entity.ai.behavior.BecomePassiveIfMemoryPresent;
-import net.minecraft.world.entity.ai.behavior.BehaviorUtils;
-import net.minecraft.world.entity.ai.behavior.DoNothing;
-import net.minecraft.world.entity.ai.behavior.EraseMemoryIf;
-import net.minecraft.world.entity.ai.behavior.LookAtTargetSink;
-import net.minecraft.world.entity.ai.behavior.MeleeAttack;
-import net.minecraft.world.entity.ai.behavior.MoveToTargetSink;
-import net.minecraft.world.entity.ai.behavior.RandomStroll;
-import net.minecraft.world.entity.ai.behavior.RunIf;
-import net.minecraft.world.entity.ai.behavior.RunOne;
-import net.minecraft.world.entity.ai.behavior.RunSometimes;
-import net.minecraft.world.entity.ai.behavior.SetEntityLookTarget;
-import net.minecraft.world.entity.ai.behavior.SetWalkTargetAwayFrom;
-import net.minecraft.world.entity.ai.behavior.SetWalkTargetFromAttackTargetIfTargetOutOfReach;
-import net.minecraft.world.entity.ai.behavior.SetWalkTargetFromLookTarget;
-import net.minecraft.world.entity.ai.behavior.StartAttacking;
-import net.minecraft.world.entity.ai.behavior.StopAttackingIfTargetInvalid;
+import net.minecraft.world.entity.ai.behavior.*;
 import net.minecraft.world.entity.ai.memory.MemoryModuleType;
 import net.minecraft.world.entity.ai.sensing.Sensor;
 import net.minecraft.world.entity.schedule.Activity;
@@ -70,11 +52,11 @@ public class HoglinAi {
     }
 
     private static void initIdleActivity(Brain<Hoglin> brain) {
-        brain.addActivity(Activity.IDLE, 10, ImmutableList.of(new BecomePassiveIfMemoryPresent(MemoryModuleType.NEAREST_REPELLENT, 200), new AnimalMakeLove(EntityType.HOGLIN, 0.6F), SetWalkTargetAwayFrom.pos(MemoryModuleType.NEAREST_REPELLENT, 1.0F, 8, true), new StartAttacking<Hoglin>(HoglinAi::findNearestValidAttackTarget), new RunIf<Hoglin>(Hoglin::isAdult, SetWalkTargetAwayFrom.entity(MemoryModuleType.NEAREST_VISIBLE_ADULT_PIGLIN, 0.4F, 8, false)), new RunSometimes<LivingEntity>(new SetEntityLookTarget(8.0F), UniformInt.of(30, 60)), new BabyFollowAdult(ADULT_FOLLOW_RANGE, 0.6F), createIdleMovementBehaviors()));
+        brain.addActivity(Activity.IDLE, 10, ImmutableList.of(new BecomePassiveIfMemoryPresent(MemoryModuleType.NEAREST_REPELLENT, 200), new AnimalMakeLove(EntityType.HOGLIN, 0.6F), SetWalkTargetAwayFrom.pos(MemoryModuleType.NEAREST_REPELLENT, 1.0F, 8, true), new StartAttacking<Hoglin>(HoglinAi::findNearestValidAttackTarget), new RunIf<Hoglin>(Hoglin::isAdult, SetWalkTargetAwayFrom.entity(MemoryModuleType.NEAREST_VISIBLE_ADULT_PIGLIN, 0.4F, 8, false)), new RunSometimes<Hoglin>(new SetEntityLookTarget(8.0F), UniformInt.of(30, 60)), new BabyFollowAdult<Hoglin>(ADULT_FOLLOW_RANGE, 0.6F), createIdleMovementBehaviors()));
     }
 
     private static void initFightActivity(Brain<Hoglin> brain) {
-        brain.addActivityAndRemoveMemoryWhenStopped(Activity.FIGHT, 10, ImmutableList.of(new BecomePassiveIfMemoryPresent(MemoryModuleType.NEAREST_REPELLENT, 200), new AnimalMakeLove(EntityType.HOGLIN, 0.6F), new SetWalkTargetFromAttackTargetIfTargetOutOfReach(1.0F), new RunIf<>(Hoglin::isAdult, new MeleeAttack(40)), new RunIf<>(AgeableMob::isBaby, new MeleeAttack(15)), new StopAttackingIfTargetInvalid(), new EraseMemoryIf(HoglinAi::isBreeding, MemoryModuleType.ATTACK_TARGET)), MemoryModuleType.ATTACK_TARGET);
+        brain.addActivityAndRemoveMemoryWhenStopped(Activity.FIGHT, 10, ImmutableList.of(new BecomePassiveIfMemoryPresent(MemoryModuleType.NEAREST_REPELLENT, 200), new AnimalMakeLove(EntityType.HOGLIN, 0.6F), new SetWalkTargetFromAttackTargetIfTargetOutOfReach(1.0F), new RunIf<Hoglin>(Hoglin::isAdult, new MeleeAttack(40)), new RunIf<Hoglin>(AgeableMob::isBaby, new MeleeAttack(15)), new StopAttackingIfTargetInvalid<Hoglin>(), new EraseMemoryIf<Hoglin>(HoglinAi::isBreeding, MemoryModuleType.ATTACK_TARGET)), MemoryModuleType.ATTACK_TARGET);
     }
 
     private static void initRetreatActivity(Brain<Hoglin> brain) {
@@ -221,8 +203,8 @@ public class HoglinAi {
         return hoglin.getBrain().hasMemoryValue(MemoryModuleType.NEAREST_REPELLENT);
     }
 
-    private static boolean isBreeding(Hoglin hoglin) {
-        return hoglin.getBrain().hasMemoryValue(MemoryModuleType.BREED_TARGET);
+    private static boolean isBreeding(Object hoglin) {
+        return ((Hoglin) hoglin).getBrain().hasMemoryValue(MemoryModuleType.BREED_TARGET);
     }
 
     protected static boolean isPacified(Hoglin hoglin) {
diff --git a/src/main/java/net/minecraft/world/entity/monster/hoglin/HoglinBase.java b/src/main/java/net/minecraft/world/entity/monster/hoglin/HoglinBase.java
index 127948e7c8620de1f4fabce0d654fbb502510156..20ebb6f7fe06a9a3f540f90670296b916efbe889 100644
--- a/src/main/java/net/minecraft/world/entity/monster/hoglin/HoglinBase.java
+++ b/src/main/java/net/minecraft/world/entity/monster/hoglin/HoglinBase.java
@@ -19,7 +19,7 @@ public interface HoglinBase {
             g = f;
         }
 
-        boolean bl = target.hurt(DamageSource.mobAttack(attacker), g);
+        boolean bl = target.hurt(DamageSource.mobAttack(attacker), attacker, null, g);
         if (bl) {
             attacker.doEnchantDamageEffects(attacker, target);
             if (!attacker.isBaby()) {
diff --git a/src/main/java/net/minecraft/world/entity/monster/piglin/Piglin.java b/src/main/java/net/minecraft/world/entity/monster/piglin/Piglin.java
index 3de35e1dfbb3dfa807a5723f9ae53841c468fba6..08ccf2cc214cad6e5c5c88e1ffe7a51b6b99822f 100644
--- a/src/main/java/net/minecraft/world/entity/monster/piglin/Piglin.java
+++ b/src/main/java/net/minecraft/world/entity/monster/piglin/Piglin.java
@@ -63,6 +63,7 @@ import java.util.stream.Collectors;
 import java.util.HashSet;
 import java.util.Set;
 import net.minecraft.world.item.Item;
+import org.bukkit.craftbukkit.block.CraftBlock;
 // CraftBukkit end
 
 public class Piglin extends AbstractPiglin implements CrossbowAttackMob, InventoryCarrier {
@@ -344,8 +345,8 @@ public class Piglin extends AbstractPiglin implements CrossbowAttackMob, Invento
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
-        boolean flag = super.hurt(source, amount);
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
+        boolean flag = super.hurt(source, damagerEntity, damagerBlock, amount);
 
         if (this.level.isClientSide) {
             return false;
diff --git a/src/main/java/net/minecraft/world/entity/monster/piglin/PiglinBrute.java b/src/main/java/net/minecraft/world/entity/monster/piglin/PiglinBrute.java
index ac75c54e897565e340b66823caeed92ba1d1641a..ff13a498be0bffe9ceba408e33ff8decbc781836 100644
--- a/src/main/java/net/minecraft/world/entity/monster/piglin/PiglinBrute.java
+++ b/src/main/java/net/minecraft/world/entity/monster/piglin/PiglinBrute.java
@@ -11,11 +11,7 @@ import net.minecraft.sounds.SoundEvents;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.damagesource.DamageSource;
-import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.EquipmentSlot;
-import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.MobSpawnType;
-import net.minecraft.world.entity.SpawnGroupData;
+import net.minecraft.world.entity.*;
 import net.minecraft.world.entity.ai.Brain;
 import net.minecraft.world.entity.ai.attributes.AttributeSupplier;
 import net.minecraft.world.entity.ai.attributes.Attributes;
@@ -70,7 +66,7 @@ public class PiglinBrute extends AbstractPiglin {
 
     @Override
     public Brain<PiglinBrute> getBrain() {
-        return super.getBrain();
+        return (Brain<PiglinBrute>) super.getBrain();
     }
 
     @Override
@@ -99,8 +95,8 @@ public class PiglinBrute extends AbstractPiglin {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
-        boolean bl = super.hurt(source, amount);
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
+        boolean bl = super.hurt(source, damagerEntity, damagerBlock, amount);
         if (this.level.isClientSide) {
             return false;
         } else {
diff --git a/src/main/java/net/minecraft/world/entity/monster/warden/AngerManagement.java b/src/main/java/net/minecraft/world/entity/monster/warden/AngerManagement.java
index 5d7116cdbaf8df93260222eec38c8e72465071eb..2ea1147b191579595da1ce44066fe12ee76c9b04 100644
--- a/src/main/java/net/minecraft/world/entity/monster/warden/AngerManagement.java
+++ b/src/main/java/net/minecraft/world/entity/monster/warden/AngerManagement.java
@@ -14,6 +14,8 @@ import java.util.Comparator;
 import java.util.List;
 import java.util.Optional;
 import java.util.UUID;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CopyOnWriteArraySet;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
@@ -38,7 +40,7 @@ public class AngerManagement {
     });
     private final Predicate<Entity> filter;
     @VisibleForTesting
-    protected final ArrayList<Entity> suspects;
+    protected final CopyOnWriteArrayList<Entity> suspects;
     private final AngerManagement.Sorter suspectSorter;
     @VisibleForTesting
     protected final Object2IntMap<Entity> angerBySuspect;
@@ -55,7 +57,7 @@ public class AngerManagement {
 
     public AngerManagement(Predicate<Entity> suspectPredicate, List<Pair<UUID, Integer>> suspectUuidsToAngerLevel) {
         this.filter = suspectPredicate;
-        this.suspects = new ArrayList<>();
+        this.suspects = new CopyOnWriteArrayList<>();
         this.suspectSorter = new AngerManagement.Sorter(this);
         this.angerBySuspect = new Object2IntOpenHashMap<>();
         this.angerByUuid = new Object2IntOpenHashMap<>(suspectUuidsToAngerLevel.size());
diff --git a/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java b/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
index 7f21bc1942fd2c7efc910e6cc4cd5482cf205319..5ff109da755ddc65507f4e8b2129e22b638aa009 100644
--- a/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
+++ b/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
@@ -68,6 +68,7 @@ import net.minecraft.world.level.pathfinder.Node;
 import net.minecraft.world.level.pathfinder.PathFinder;
 import net.minecraft.world.level.pathfinder.WalkNodeEvaluator;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.jetbrains.annotations.Contract;
 import org.slf4j.Logger;
 
@@ -548,8 +549,8 @@ public class Warden extends Monster implements VibrationListener.VibrationListen
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
-        boolean flag = super.hurt(source, amount);
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
+        boolean flag = super.hurt(source, damagerEntity, damagerBlock, amount);
 
         if (!this.level.isClientSide && !this.isNoAi() && !this.isDiggingOrEmerging()) {
             Entity entity = source.getEntity();
diff --git a/src/main/java/net/minecraft/world/entity/monster/warden/WardenAi.java b/src/main/java/net/minecraft/world/entity/monster/warden/WardenAi.java
index f916b519cfde814386b5369c8bfda94208f1159e..259d8332a1035f0b47110a10a05374a09c7dcccc 100644
--- a/src/main/java/net/minecraft/world/entity/monster/warden/WardenAi.java
+++ b/src/main/java/net/minecraft/world/entity/monster/warden/WardenAi.java
@@ -96,15 +96,15 @@ public class WardenAi {
     }
 
     private static void initIdleActivity(Brain<Warden> brain) {
-        brain.addActivity(Activity.IDLE, 10, ImmutableList.of(new SetRoarTarget<>(Warden::getEntityAngryAt), new TryToSniff(), new RunOne(ImmutableMap.of(MemoryModuleType.IS_SNIFFING, MemoryStatus.VALUE_ABSENT), ImmutableList.of(Pair.of(new RandomStroll(0.5F), 2), Pair.of(new DoNothing(30, 60), 1)))));
+        brain.addActivity(Activity.IDLE, 10, ImmutableList.of(new SetRoarTarget<Warden>(Warden::getEntityAngryAt), new TryToSniff(), new RunOne<Warden>(ImmutableMap.of(MemoryModuleType.IS_SNIFFING, MemoryStatus.VALUE_ABSENT), ImmutableList.of(Pair.of(new RandomStroll(0.5F), 2), Pair.of(new DoNothing(30, 60), 1)))));
     }
 
     private static void initInvestigateActivity(Brain<Warden> brain) {
-        brain.addActivityAndRemoveMemoryWhenStopped(Activity.INVESTIGATE, 5, ImmutableList.of(new SetRoarTarget<>(Warden::getEntityAngryAt), new GoToTargetLocation(MemoryModuleType.DISTURBANCE_LOCATION, 2, 0.7F)), MemoryModuleType.DISTURBANCE_LOCATION);
+        brain.addActivityAndRemoveMemoryWhenStopped(Activity.INVESTIGATE, 5, ImmutableList.of(new SetRoarTarget<Warden>(Warden::getEntityAngryAt), new GoToTargetLocation<Warden>(MemoryModuleType.DISTURBANCE_LOCATION, 2, 0.7F)), MemoryModuleType.DISTURBANCE_LOCATION);
     }
 
     private static void initSniffingActivity(Brain<Warden> brain) {
-        brain.addActivityAndRemoveMemoryWhenStopped(Activity.SNIFF, 5, ImmutableList.of(new SetRoarTarget<>(Warden::getEntityAngryAt), new Sniffing(SNIFFING_DURATION)), MemoryModuleType.IS_SNIFFING);
+        brain.addActivityAndRemoveMemoryWhenStopped(Activity.SNIFF, 5, ImmutableList.of(new SetRoarTarget<Warden>(Warden::getEntityAngryAt), new Sniffing<Warden>(SNIFFING_DURATION)), MemoryModuleType.IS_SNIFFING);
     }
 
     private static void initRoarActivity(Brain<Warden> brain) {
diff --git a/src/main/java/net/minecraft/world/entity/player/Inventory.java b/src/main/java/net/minecraft/world/entity/player/Inventory.java
index 8bfba53268a10e55bba2f68987c2b39cd3620c38..61ba949cee8c74771bc9f914f39b416d28f3b3e6 100644
--- a/src/main/java/net/minecraft/world/entity/player/Inventory.java
+++ b/src/main/java/net/minecraft/world/entity/player/Inventory.java
@@ -673,7 +673,7 @@ public class Inventory implements Container, Nameable {
 
     @Override
     public boolean stillValid(Player player) {
-        return this.player.isRemoved() ? false : player.distanceToSqr(this.player) <= 64.0D;
+        return !this.player.isRemoved() && player.distanceToSqr(this.player) <= 64.0D;
     }
 
     public boolean contains(ItemStack stack) {
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index 1f4d82c79f66da51d8f751066d959f472df2899f..7a05e6896f261ac46fc7b7490c788c502c5e647a 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -950,7 +950,7 @@ public abstract class Player extends LivingEntity {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable org.bukkit.block.Block damagerBlock, float amount) {
         if (this.isInvulnerableTo(source)) {
             return false;
         } else if (this.abilities.invulnerable && !source.isBypassInvul()) {
@@ -979,7 +979,7 @@ public abstract class Player extends LivingEntity {
                 }
 
                 // CraftBukkit start - Don't filter out 0 damage
-                boolean damaged = super.hurt(source, amount);
+                boolean damaged = super.hurt(source, damagerEntity, damagerBlock, amount);
                 if (damaged) {
                     this.removeEntitiesOnShoulder();
                 }
@@ -1070,9 +1070,9 @@ public abstract class Player extends LivingEntity {
 
     // CraftBukkit start
     @Override
-    protected boolean damageEntity0(DamageSource damagesource, float f) { // void -> boolean
+    protected boolean damageEntity0(DamageSource damagesource, @Nullable Entity damagerEntity, @Nullable org.bukkit.block.Block damagerBlock, float f) { // void -> boolean
         if (true) {
-            return super.damageEntity0(damagesource, f);
+            return super.damageEntity0(damagesource, damagerEntity, damagerBlock, f);
         }
         // CraftBukkit end
         if (!this.isInvulnerableTo(damagesource)) {
@@ -1328,7 +1328,7 @@ public abstract class Player extends LivingEntity {
                     }
 
                     Vec3 vec3d = target.getDeltaMovement();
-                    boolean flag5 = target.hurt(DamageSource.playerAttack(this).critical(flag2), f); // Paper - add critical damage API
+                    boolean flag5 = target.hurt(DamageSource.playerAttack(this).critical(flag2), this, null, f); // Paper - add critical damage API
 
                     if (flag5) {
                         if (i > 0) {
@@ -1356,7 +1356,7 @@ public abstract class Player extends LivingEntity {
 
                                 if (entityliving != this && entityliving != target && !this.isAlliedTo(entityliving) && (!(entityliving instanceof ArmorStand) || !((ArmorStand) entityliving).isMarker()) && this.distanceToSqr(entityliving) < 9.0D) {
                                     // CraftBukkit start - Only apply knockback if the damage hits
-                                    if (entityliving.hurt(DamageSource.playerAttack(this).sweep().critical(flag2), f4)) { // Paper - add critical damage API
+                                    if (entityliving.hurt(DamageSource.playerAttack(this).sweep().critical(flag2), this, null, f4)) { // Paper - add critical damage API
                                     entityliving.knockback(0.4000000059604645D, Mth.sin(this.getYRot() * 0.017453292F), -Mth.cos(this.getYRot() * 0.017453292F), this); // Paper
                                     }
                                     // CraftBukkit end
@@ -1775,7 +1775,7 @@ public abstract class Player extends LivingEntity {
     }
 
     @Override
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
+    public boolean causeFallDamage(float fallDistance, final @Nullable Entity damagerEntity, final org.bukkit.block.Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
         if (this.abilities.mayfly) {
             return false;
         } else {
@@ -1783,7 +1783,7 @@ public abstract class Player extends LivingEntity {
                 this.awardStat(Stats.FALL_ONE_CM, (int) Math.round((double) fallDistance * 100.0D));
             }
 
-            return super.causeFallDamage(fallDistance, damageMultiplier, damageSource);
+            return super.causeFallDamage(fallDistance, damagerEntity, damagerBlock, damageMultiplier, damageSource);
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java b/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
index 05f0d33309ebda9e4af9bda5c5af2f32a8a74fdc..2a77206f5fdd42cc86746c711260bbb8f1ae40af 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
@@ -2,8 +2,7 @@ package net.minecraft.world.entity.projectile;
 
 import com.google.common.collect.Lists;
 import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
-import java.util.Arrays;
-import java.util.Collection;
+
 import java.util.Iterator;
 import java.util.List;
 import javax.annotation.Nullable;
@@ -409,7 +408,7 @@ public abstract class AbstractArrow extends Projectile {
             // CraftBukkit end
         }
 
-        if (entity.hurt(damagesource, (float) i)) {
+        if (entity.hurt(damagesource, entity1 == null ? this : entity1, null, (float) i)) {
             if (flag) {
                 return;
             }
diff --git a/src/main/java/net/minecraft/world/entity/projectile/AbstractHurtingProjectile.java b/src/main/java/net/minecraft/world/entity/projectile/AbstractHurtingProjectile.java
index 4ae276de36470479fcc60458a1d968246705c0c2..110358915553aa48c54506868d7b916d4b592bd9 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/AbstractHurtingProjectile.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/AbstractHurtingProjectile.java
@@ -14,7 +14,10 @@ import net.minecraft.world.level.Level;
 import net.minecraft.world.phys.EntityHitResult;
 import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
+import org.jetbrains.annotations.Nullable;
+
 
 public abstract class AbstractHurtingProjectile extends Projectile {
 
@@ -176,7 +179,7 @@ public abstract class AbstractHurtingProjectile extends Projectile {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.isInvulnerableTo(source)) {
             return false;
         } else {
@@ -186,7 +189,7 @@ public abstract class AbstractHurtingProjectile extends Projectile {
             if (entity != null) {
                 if (!this.level.isClientSide) {
                     // CraftBukkit start
-                    if (CraftEventFactory.handleNonLivingEntityDamageEvent(this, source, amount, false)) {
+                    if (CraftEventFactory.handleNonLivingEntityDamageEvent(this, damagerEntity, damagerBlock, source, amount, false)) {
                         return false;
                     }
                     // CraftBukkit end
diff --git a/src/main/java/net/minecraft/world/entity/projectile/DragonFireball.java b/src/main/java/net/minecraft/world/entity/projectile/DragonFireball.java
index c72ab3c9f7cb20f22b051981fe1fc41965d2b2af..1575dcfea2bcc1a31af5d3cc635d1218936b5f03 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/DragonFireball.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/DragonFireball.java
@@ -13,6 +13,10 @@ import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.phys.EntityHitResult;
 import net.minecraft.world.phys.HitResult;
+import org.bukkit.craftbukkit.block.CraftBlock;
+
+import javax.annotation.Nullable;
+
 
 public class DragonFireball extends AbstractHurtingProjectile {
     public static final float SPLASH_RANGE = 4.0F;
@@ -68,7 +72,7 @@ public class DragonFireball extends AbstractHurtingProjectile {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         return false;
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/projectile/EvokerFangs.java b/src/main/java/net/minecraft/world/entity/projectile/EvokerFangs.java
index 74a8464d64e96eb2117488b7acc526e7a8385b23..56591b1ce8eb63a8608de4f926771d56856f764e 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/EvokerFangs.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/EvokerFangs.java
@@ -130,15 +130,13 @@ public class EvokerFangs extends Entity {
 
         if (target.isAlive() && !target.isInvulnerable() && target != entityliving1) {
             if (entityliving1 == null) {
-                org.bukkit.craftbukkit.event.CraftEventFactory.entityDamage = this; // CraftBukkit
-                target.hurt(DamageSource.MAGIC, 6.0F);
-                org.bukkit.craftbukkit.event.CraftEventFactory.entityDamage = null; // CraftBukkit
+                target.hurt(DamageSource.MAGIC, this, null, 6.0F);
             } else {
                 if (entityliving1.isAlliedTo(target)) {
                     return;
                 }
 
-                target.hurt(DamageSource.indirectMagic(this, entityliving1), 6.0F);
+                target.hurt(DamageSource.indirectMagic(this, entityliving1), entityliving1, null, 6.0F);
             }
 
         }
diff --git a/src/main/java/net/minecraft/world/entity/projectile/FireworkRocketEntity.java b/src/main/java/net/minecraft/world/entity/projectile/FireworkRocketEntity.java
index 5fd59b1a30a61bc1e799aafeb7ea34cb09581046..0d8b5c45a90e1fd619c276defdcf1d2c602dc249 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/FireworkRocketEntity.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/FireworkRocketEntity.java
@@ -18,7 +18,6 @@ import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.MoverType;
-import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.level.ClipContext;
@@ -241,9 +240,7 @@ public class FireworkRocketEntity extends Projectile implements ItemSupplier {
 
         if (f > 0.0F) {
             if (this.attachedToEntity != null) {
-                CraftEventFactory.entityDamage = this; // CraftBukkit
-                this.attachedToEntity.hurt(DamageSource.fireworks(this, this.getOwner()), 5.0F + (float) (nbttaglist.size() * 2));
-                CraftEventFactory.entityDamage = null; // CraftBukkit
+                this.attachedToEntity.hurt(DamageSource.fireworks(this, this.getOwner()), this, null, 5.0F + (float) (nbttaglist.size() * 2));
             }
 
             double d0 = 5.0D;
@@ -269,10 +266,7 @@ public class FireworkRocketEntity extends Projectile implements ItemSupplier {
 
                     if (flag) {
                         float f1 = f * (float) Math.sqrt((5.0D - (double) this.distanceTo(entityliving)) / 5.0D);
-
-                        CraftEventFactory.entityDamage = this; // CraftBukkit
-                        entityliving.hurt(DamageSource.fireworks(this, this.getOwner()), f1);
-                        CraftEventFactory.entityDamage = null; // CraftBukkit
+                        entityliving.hurt(DamageSource.fireworks(this, this.getOwner()), this, null, f1);
                     }
                 }
             }
diff --git a/src/main/java/net/minecraft/world/entity/projectile/LargeFireball.java b/src/main/java/net/minecraft/world/entity/projectile/LargeFireball.java
index 5237b699e000b4fed99be39b0a7e2daab9c8bf42..599196ba4b73c3a58a07beb8a8e5a8bab7db1b4a 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/LargeFireball.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/LargeFireball.java
@@ -54,7 +54,7 @@ public class LargeFireball extends Fireball {
             Entity entity = entityHitResult.getEntity();
             Entity entity1 = this.getOwner();
 
-            entity.hurt(DamageSource.fireball(this, entity1), 6.0F);
+            entity.hurt(DamageSource.fireball(this, entity1), entity1, null, 6.0F);
             if (entity1 instanceof LivingEntity) {
                 this.doEnchantDamageEffects((LivingEntity) entity1, entity);
             }
diff --git a/src/main/java/net/minecraft/world/entity/projectile/LlamaSpit.java b/src/main/java/net/minecraft/world/entity/projectile/LlamaSpit.java
index 4132c1113f5437a776e5e3c1cb306904775aed88..d8c52d05b91b8371a10c9d268dd99adfcac3a835 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/LlamaSpit.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/LlamaSpit.java
@@ -62,7 +62,7 @@ public class LlamaSpit extends Projectile {
         Entity entity = this.getOwner();
 
         if (entity instanceof LivingEntity) {
-            entityHitResult.getEntity().hurt(DamageSource.indirectMobAttack(this, (LivingEntity) entity).setProjectile(), 1.0F);
+            entityHitResult.getEntity().hurt(DamageSource.indirectMobAttack(this, (LivingEntity) entity).setProjectile(), entity, null, 1.0F);
         }
 
     }
diff --git a/src/main/java/net/minecraft/world/entity/projectile/ShulkerBullet.java b/src/main/java/net/minecraft/world/entity/projectile/ShulkerBullet.java
index e764197e4a4bd6256551b3b8fa289bc31068d8cf..2c712a2ed8ac318a8c8bd0f3db58805fefb2f60e 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/ShulkerBullet.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/ShulkerBullet.java
@@ -27,6 +27,8 @@ import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.EntityHitResult;
 import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.craftbukkit.block.CraftBlock;
+
 
 public class ShulkerBullet extends Projectile {
 
@@ -299,7 +301,7 @@ public class ShulkerBullet extends Projectile {
         Entity entity = entityHitResult.getEntity();
         Entity entity1 = this.getOwner();
         LivingEntity entityliving = entity1 instanceof LivingEntity ? (LivingEntity) entity1 : null;
-        boolean flag = entity.hurt(DamageSource.indirectMobAttack(this, entityliving).setProjectile(), 4.0F);
+        boolean flag = entity.hurt(DamageSource.indirectMobAttack(this, entityliving).setProjectile(), entityliving, null, 4.0F);
 
         if (flag) {
             this.doEnchantDamageEffects(entityliving, entity);
@@ -329,9 +331,9 @@ public class ShulkerBullet extends Projectile {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         // CraftBukkit start
-        if (org.bukkit.craftbukkit.event.CraftEventFactory.handleNonLivingEntityDamageEvent(this, source, amount, false)) {
+        if (org.bukkit.craftbukkit.event.CraftEventFactory.handleNonLivingEntityDamageEvent(this, damagerEntity, damagerBlock, source, amount, false)) {
             return false;
         }
         // CraftBukkit end
diff --git a/src/main/java/net/minecraft/world/entity/projectile/SmallFireball.java b/src/main/java/net/minecraft/world/entity/projectile/SmallFireball.java
index 815f1e659db4afde450f5e69d66750fa77bdef22..c78bfe018159b47254232d50a8438a930a6bc361 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/SmallFireball.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/SmallFireball.java
@@ -12,8 +12,12 @@ import net.minecraft.world.level.block.BaseFireBlock;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.EntityHitResult;
 import net.minecraft.world.phys.HitResult;
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.event.entity.EntityCombustByEntityEvent; // CraftBukkit
 
+import javax.annotation.Nullable;
+
+
 public class SmallFireball extends Fireball {
 
     public SmallFireball(EntityType<? extends SmallFireball> type, Level world) {
@@ -49,7 +53,7 @@ public class SmallFireball extends Fireball {
                 entity.setSecondsOnFire(event.getDuration(), false);
             }
             // CraftBukkit end
-            if (!entity.hurt(DamageSource.fireball(this, entity1), 5.0F)) {
+            if (!entity.hurt(DamageSource.fireball(this, entity1), entity1, null, 5.0F)) {
                 entity.setRemainingFireTicks(i);
             } else if (entity1 instanceof LivingEntity) {
                 this.doEnchantDamageEffects((LivingEntity) entity1, entity);
@@ -90,7 +94,7 @@ public class SmallFireball extends Fireball {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         return false;
     }
 }
diff --git a/src/main/java/net/minecraft/world/entity/projectile/Snowball.java b/src/main/java/net/minecraft/world/entity/projectile/Snowball.java
index a725851060f13e734dbd2fbf8c83c9e1af57a8b7..6a61f782ba68fd79d464530888b568a2d7463694 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/Snowball.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/Snowball.java
@@ -35,7 +35,7 @@ public class Snowball extends ThrowableItemProjectile {
 
     private ParticleOptions getParticle() {
         ItemStack itemStack = this.getItemRaw();
-        return (ParticleOptions)(itemStack.isEmpty() ? ParticleTypes.ITEM_SNOWBALL : new ItemParticleOption(ParticleTypes.ITEM, itemStack));
+        return itemStack.isEmpty() ? ParticleTypes.ITEM_SNOWBALL : new ItemParticleOption(ParticleTypes.ITEM, itemStack);
     }
 
     @Override
@@ -55,7 +55,7 @@ public class Snowball extends ThrowableItemProjectile {
         super.onHitEntity(entityHitResult);
         Entity entity = entityHitResult.getEntity();
         int i = entity instanceof Blaze ? 3 : 0;
-        entity.hurt(DamageSource.thrown(this, this.getOwner()), (float)i);
+        entity.hurt(DamageSource.thrown(this, this.getOwner()), this.getOwner(), null, (float)i);
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/projectile/ThrownEgg.java b/src/main/java/net/minecraft/world/entity/projectile/ThrownEgg.java
index 77941e3981e49cf5662b3e3c86a9c419080b17c8..00976d17c8caefbb5ecfd8e13d53867b08b32088 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/ThrownEgg.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/ThrownEgg.java
@@ -46,7 +46,7 @@ public class ThrownEgg extends ThrowableItemProjectile {
     @Override
     protected void onHitEntity(EntityHitResult entityHitResult) {
         super.onHitEntity(entityHitResult);
-        entityHitResult.getEntity().hurt(DamageSource.thrown(this, this.getOwner()), 0.0F);
+        entityHitResult.getEntity().hurt(DamageSource.thrown(this, this.getOwner()), this.getOwner(), null, 0.0F);
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/projectile/ThrownEnderpearl.java b/src/main/java/net/minecraft/world/entity/projectile/ThrownEnderpearl.java
index 17ef2786aeb21bcdc0cb77abcbfd2a46346a5b8c..bc4d2311a1a5b539036d2c3222577cc26b1f41bd 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/ThrownEnderpearl.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/ThrownEnderpearl.java
@@ -41,7 +41,7 @@ public class ThrownEnderpearl extends ThrowableItemProjectile {
     @Override
     protected void onHitEntity(EntityHitResult entityHitResult) {
         super.onHitEntity(entityHitResult);
-        entityHitResult.getEntity().hurt(DamageSource.thrown(this, this.getOwner()), 0.0F);
+        entityHitResult.getEntity().hurt(DamageSource.thrown(this, this.getOwner()), this.getOwner(), null, 0.0F);
     }
 
     @Override
@@ -82,9 +82,7 @@ public class ThrownEnderpearl extends ThrowableItemProjectile {
 
                         entityplayer.connection.teleport(teleEvent.getTo());
                         entity.resetFallDistance();
-                        CraftEventFactory.entityDamage = this;
-                        entity.hurt(DamageSource.FALL, 5.0F);
-                        CraftEventFactory.entityDamage = null;
+                        entity.hurt(DamageSource.FALL, this, null, 5.0F);
                     }
                     // CraftBukkit end
                 }
diff --git a/src/main/java/net/minecraft/world/entity/projectile/ThrownPotion.java b/src/main/java/net/minecraft/world/entity/projectile/ThrownPotion.java
index c5fcc1743098230b7fb36bf5ccef81041bcd2ab9..f039b333e092e8d3af6c8c1ed59ff53bd5511ac9 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/ThrownPotion.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/ThrownPotion.java
@@ -16,7 +16,6 @@ import net.minecraft.world.entity.AreaEffectCloud;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.animal.axolotl.Axolotl;
-import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
@@ -163,7 +162,7 @@ public class ThrownPotion extends ThrowableItemProjectile implements ItemSupplie
                 if (entityliving instanceof Axolotl axolotl && event.getIntensity(affectedEntity) > 0) {
                     axolotl.rehydrate();
                 } else {
-                    entityliving.hurt(DamageSource.indirectMagic(this, this.getOwner()), 1.0F);
+                    entityliving.hurt(DamageSource.indirectMagic(this, this.getOwner()), this.getOwner(), null, 1.0F);
                 }
             }
             // Paper end
diff --git a/src/main/java/net/minecraft/world/entity/projectile/ThrownTrident.java b/src/main/java/net/minecraft/world/entity/projectile/ThrownTrident.java
index 89b7d9456b1937de3ccd5aaa34c6c13e10e86092..9fdc1c96cbb06dfc94d8dfa6382d051066179e1a 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/ThrownTrident.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/ThrownTrident.java
@@ -137,12 +137,13 @@ public class ThrownTrident extends AbstractArrow {
         }
 
         Entity entity1 = this.getOwner();
-        DamageSource damagesource = DamageSource.trident(this, entity1 == null ? this : entity1);
+        final Entity attacker = entity1 == null ? this : entity1;
+        DamageSource damagesource = DamageSource.trident(this, attacker);
 
         this.dealtDamage = true;
         SoundEvent soundeffect = SoundEvents.TRIDENT_HIT;
 
-        if (entity.hurt(damagesource, f)) {
+        if (entity.hurt(damagesource, attacker, null, f)) {
             if (entity.getType() == EntityType.ENDERMAN) {
                 return;
             }
diff --git a/src/main/java/net/minecraft/world/entity/projectile/WitherSkull.java b/src/main/java/net/minecraft/world/entity/projectile/WitherSkull.java
index 1762ea33cc5c69635933fc9dfa7b2a9c93d2e234..0df3ded3b7072cd3737a689201f2a41c702e660f 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/WitherSkull.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/WitherSkull.java
@@ -20,8 +20,12 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.phys.EntityHitResult;
 import net.minecraft.world.phys.HitResult;
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.event.entity.ExplosionPrimeEvent; // CraftBukkit
 
+import javax.annotation.Nullable;
+
+
 public class WitherSkull extends AbstractHurtingProjectile {
 
     private static final EntityDataAccessor<Boolean> DATA_DANGEROUS = SynchedEntityData.defineId(WitherSkull.class, EntityDataSerializers.BOOLEAN);
@@ -60,7 +64,7 @@ public class WitherSkull extends AbstractHurtingProjectile {
             if (entity1 instanceof LivingEntity) {
                 LivingEntity entityliving = (LivingEntity) entity1;
 
-                flag = entity.hurt(DamageSource.witherSkull(this, entityliving), 8.0F);
+                flag = entity.hurt(DamageSource.witherSkull(this, entityliving), entityliving, null, 8.0F);
                 if (flag) {
                     if (entity.isAlive()) {
                         this.doEnchantDamageEffects(entityliving, entity);
@@ -69,7 +73,7 @@ public class WitherSkull extends AbstractHurtingProjectile {
                     }
                 }
             } else {
-                flag = entity.hurt(DamageSource.MAGIC, 5.0F);
+                flag = entity.hurt(DamageSource.MAGIC, null, null, 5.0F);
             }
 
             if (flag && entity instanceof LivingEntity) {
@@ -115,7 +119,7 @@ public class WitherSkull extends AbstractHurtingProjectile {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         return false;
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/raid/Raider.java b/src/main/java/net/minecraft/world/entity/raid/Raider.java
index ffa0b6fe36f490f02d61a0c9bfc8f76b4cce5a0c..9ce3c2316bf0570451dd6705a1d6a03f37fa6a3c 100644
--- a/src/main/java/net/minecraft/world/entity/raid/Raider.java
+++ b/src/main/java/net/minecraft/world/entity/raid/Raider.java
@@ -42,6 +42,8 @@ import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.ServerLevelAccessor;
 import net.minecraft.world.phys.Vec3;
+import org.bukkit.craftbukkit.block.CraftBlock;
+
 
 public abstract class Raider extends PatrollingMonster {
 
@@ -291,12 +293,12 @@ public abstract class Raider extends PatrollingMonster {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.hasActiveRaid()) {
             this.getCurrentRaid().updateBossbar();
         }
 
-        return super.hurt(source, amount);
+        return super.hurt(source, damagerEntity, damagerBlock, amount);
     }
 
     @Nullable
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecart.java b/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecart.java
index 0133ffe5bf5245013cd440c5614983f11bbfce13..c5df9ec903e177dd5b482642d57280c78ef16aba 100644
--- a/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecart.java
+++ b/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecart.java
@@ -49,6 +49,7 @@ import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 // CraftBukkit start
 import org.bukkit.Location;
+import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.entity.Vehicle;
 import org.bukkit.event.vehicle.VehicleDamageEvent;
 import org.bukkit.event.vehicle.VehicleDestroyEvent;
@@ -238,7 +239,7 @@ public abstract class AbstractMinecart extends Entity {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, final @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (!this.level.isClientSide && !this.isRemoved()) {
             if (this.isInvulnerableTo(source)) {
                 return false;
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/Boat.java b/src/main/java/net/minecraft/world/entity/vehicle/Boat.java
index 73c869db7e0808d09619d7ba866c08c0c81dc1eb..96744a11cdef85ab77d1a6377be834ddac2a1362 100644
--- a/src/main/java/net/minecraft/world/entity/vehicle/Boat.java
+++ b/src/main/java/net/minecraft/world/entity/vehicle/Boat.java
@@ -37,7 +37,6 @@ import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
@@ -172,7 +171,7 @@ public class Boat extends Entity {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         if (this.isInvulnerableTo(source)) {
             return false;
         } else if (!this.level.isClientSide && !this.isRemoved()) {
@@ -883,7 +882,7 @@ public class Boat extends Entity {
                         return;
                     }
 
-                    this.causeFallDamage(this.fallDistance, 1.0F, DamageSource.FALL);
+                    this.causeFallDamage(this.fallDistance, null, null, 1.0F, DamageSource.FALL);
                     if (!this.level.isClientSide && !this.isRemoved()) {
                     // CraftBukkit start
                     Vehicle vehicle = (Vehicle) this.getBukkitEntity();
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/MinecartTNT.java b/src/main/java/net/minecraft/world/entity/vehicle/MinecartTNT.java
index 6fb127db8de6975e0f81583f1f593aab0c1467e3..9a92b45beea1236a696a4d7635494f8421d58176 100644
--- a/src/main/java/net/minecraft/world/entity/vehicle/MinecartTNT.java
+++ b/src/main/java/net/minecraft/world/entity/vehicle/MinecartTNT.java
@@ -9,7 +9,6 @@ import net.minecraft.tags.BlockTags;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.entity.projectile.AbstractArrow;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.Items;
@@ -19,6 +18,10 @@ import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.material.FluidState;
+import org.bukkit.block.Block;
+
+import javax.annotation.Nullable;
+
 
 public class MinecartTNT extends AbstractMinecart {
     private static final byte EVENT_PRIME = 10;
@@ -68,7 +71,7 @@ public class MinecartTNT extends AbstractMinecart {
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
+    public boolean hurt(DamageSource source, @Nullable Entity damagerEntity, @Nullable final org.bukkit.block.Block damagerBlock, float amount) {
         Entity entity = source.getDirectEntity();
         if (entity instanceof AbstractArrow abstractArrow) {
             if (abstractArrow.isOnFire()) {
@@ -76,7 +79,7 @@ public class MinecartTNT extends AbstractMinecart {
             }
         }
 
-        return super.hurt(source, amount);
+        return super.hurt(source, damagerEntity, damagerBlock, amount);
     }
 
     @Override
@@ -112,13 +115,13 @@ public class MinecartTNT extends AbstractMinecart {
     }
 
     @Override
-    public boolean causeFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource) {
+    public boolean causeFallDamage(float fallDistance, final @Nullable Entity damagerEntity, final Block damagerBlock, float damageMultiplier, DamageSource damageSource) {
         if (fallDistance >= 3.0F) {
             float f = fallDistance / 10.0F;
             this.explode(f * f);
         }
 
-        return super.causeFallDamage(fallDistance, damageMultiplier, damageSource);
+        return super.causeFallDamage(fallDistance, damagerEntity, damagerBlock, damageMultiplier, damageSource);
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/food/FoodData.java b/src/main/java/net/minecraft/world/food/FoodData.java
index 347621de1b7ab881ea392c3d6f0354e8d86be793..7445d1fcece35b29f6f22397c2e071ede20eaeaa 100644
--- a/src/main/java/net/minecraft/world/food/FoodData.java
+++ b/src/main/java/net/minecraft/world/food/FoodData.java
@@ -101,7 +101,7 @@ public class FoodData {
             ++this.tickTimer;
             if (this.tickTimer >= this.starvationRate) { // CraftBukkit - add regen rate manipulation
                 if (player.getHealth() > 10.0F || enumdifficulty == Difficulty.HARD || player.getHealth() > 1.0F && enumdifficulty == Difficulty.NORMAL) {
-                    player.hurt(DamageSource.STARVE, 1.0F);
+                    player.hurt(DamageSource.STARVE, null, null, 1.0F);
                 }
 
                 this.tickTimer = 0;
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index 7d005e879fb0201b5802001380994f1f9f7c9019..22ab32ddf0c2f21e5a4eeadf87985952f873de1d 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -244,7 +244,7 @@ public final class ItemStack {
     }
 
     private void updateEmptyCacheFlag() {
-        if (this.emptyCacheFlag && this == ItemStack.EMPTY) throw new AssertionError("TRAP"); // CraftBukkit
+        //if (this.emptyCacheFlag && this == ItemStack.EMPTY) throw new AssertionError("TRAP"); // CraftBukkit
         this.emptyCacheFlag = false;
         this.emptyCacheFlag = this.isEmpty();
     }
@@ -338,7 +338,7 @@ public final class ItemStack {
             ServerLevel world = (ServerLevel) itemactioncontext.getLevel();
 
             if (!(this.getItem() instanceof BucketItem/* || this.getItem() instanceof SolidBucketItem*/)) { // if not bucket // Paper - capture block states for snow buckets
-                world.captureBlockStates = true;
+                world.captureBlockStates.set(true);
                 // special case bonemeal
                 if (this.getItem() == Items.BONE_MEAL) {
                     world.captureTreeGeneration = true;
@@ -350,7 +350,7 @@ public final class ItemStack {
             int newCount = this.getCount();
             this.setCount(oldCount);
             this.setTagClone(oldData);
-            world.captureBlockStates = false;
+            world.captureBlockStates.set(false);
             if (enuminteractionresult.consumesAction() && world.captureTreeGeneration && world.capturedBlockStates.size() > 0) {
                 world.captureTreeGeneration = false;
                 Location location = new Location(world.getWorld(), blockposition.getX(), blockposition.getY(), blockposition.getZ());
diff --git a/src/main/java/net/minecraft/world/level/Explosion.java b/src/main/java/net/minecraft/world/level/Explosion.java
index baee34b3aca7aa000cd72a83a7ea514c3ec8ac05..a8351392353bc59269d53db3359208371b95d6b8 100644
--- a/src/main/java/net/minecraft/world/level/Explosion.java
+++ b/src/main/java/net/minecraft/world/level/Explosion.java
@@ -239,7 +239,6 @@ public class Explosion {
                         double d13 = (1.0D - d7) * d12;
 
                         // CraftBukkit start
-                        CraftEventFactory.entityDamage = this.source;
                         entity.lastDamageCancelled = false;
 
                         // Special case ender dragon only give knockback if no damage is cancelled
@@ -255,14 +254,13 @@ public class Explosion {
                         if (entity instanceof EnderDragon) {
                             for (EnderDragonPart entityComplexPart : ((EnderDragon) entity).subEntities) {
                                 if (list.contains(entityComplexPart)) {
-                                    entityComplexPart.hurt(this.getDamageSource(), (float) ((int) ((d13 * d13 + d13) / 2.0D * 7.0D * (double) f2 + 1.0D)));
+                                    entityComplexPart.hurt(this.damageSource, this.source, null, (float) ((int) ((d13 * d13 + d13) / 2.0D * 7.0D * (double) f2 + 1.0D)));
                                 }
                             }
                         } else {
-                            entity.hurt(this.getDamageSource(), (float) ((int) ((d13 * d13 + d13) / 2.0D * 7.0D * (double) f2 + 1.0D)));
+                            entity.hurt(this.damageSource, this.source, null, (float) ((int) ((d13 * d13 + d13) / 2.0D * 7.0D * (double) f2 + 1.0D)));
                         }
 
-                        CraftEventFactory.entityDamage = null;
                         if (entity.lastDamageCancelled) { // SPIGOT-5339, SPIGOT-6252, SPIGOT-6777: Skip entity if damage event was cancelled
                             continue;
                         }
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 5811849ee84c25005b20f87ff214fe53ed65766d..7bdb058d94914555c4fd0a164df10fc55c5e4f91 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -8,9 +8,9 @@ import com.google.common.base.MoreObjects;
 import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
 import java.io.IOException;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
@@ -82,8 +82,6 @@ import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.scores.Scoreboard;
 
 // CraftBukkit start
-import java.util.HashMap;
-import java.util.Map;
 import net.minecraft.network.protocol.game.ClientboundSetBorderCenterPacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderLerpSizePacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderSizePacket;
@@ -152,10 +150,10 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public static final boolean DEBUG_ENTITIES = Boolean.getBoolean("debug.entities"); // Paper
 
     public boolean preventPoiUpdated = false; // CraftBukkit - SPIGOT-5710
-    public boolean captureBlockStates = false;
+    public AtomicBoolean captureBlockStates = new AtomicBoolean(false);
     public boolean captureTreeGeneration = false;
-    public Map<BlockPos, org.bukkit.craftbukkit.block.CraftBlockState> capturedBlockStates = new java.util.LinkedHashMap<>(); // Paper
-    public Map<BlockPos, BlockEntity> capturedTileEntities = new java.util.LinkedHashMap<>(); // Paper
+    public Map<BlockPos, org.bukkit.craftbukkit.block.CraftBlockState> capturedBlockStates = new ConcurrentHashMap<>(); // Paper
+    public Map<BlockPos, BlockEntity> capturedTileEntities = new ConcurrentHashMap<>(); // Paper
     public List<ItemEntity> captureDrops;
     public final it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap<SpawnCategory> ticksPerSpawnCategory = new it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap<>();
     // Paper start
@@ -541,7 +539,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
 
             // CraftBukkit start - capture blockstates
             boolean captured = false;
-            if (this.captureBlockStates && !this.capturedBlockStates.containsKey(pos)) {
+            if (this.captureBlockStates.get() && !this.capturedBlockStates.containsKey(pos)) {
                 CraftBlockState blockstate = (CraftBlockState) world.getBlockAt(pos.getX(), pos.getY(), pos.getZ()).getState(); // Paper - use CB getState to get a suitable snapshot
                 blockstate.setFlag(flags); // Paper - set flag
                 this.capturedBlockStates.put(pos.immutable(), blockstate);
@@ -554,7 +552,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
 
             if (iblockdata1 == null) {
                 // CraftBukkit start - remove blockstate if failed (or the same)
-                if (this.captureBlockStates && captured) {
+                if (this.captureBlockStates.get() && captured) {
                     this.capturedBlockStates.remove(pos);
                 }
                 // CraftBukkit end
@@ -598,7 +596,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 */
 
                 // CraftBukkit start
-                if (!this.captureBlockStates) { // Don't notify clients or update physics while capturing blockstates
+                if (!this.captureBlockStates.get()) { // Don't notify clients or update physics while capturing blockstates
                     // Modularize client and physic updates
                     // Spigot start
                     try {
@@ -961,7 +959,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         }
         // Paper end
         // CraftBukkit end
-        return this.isOutsideBuildHeight(blockposition) ? null : (!this.isClientSide && !io.papermc.paper.util.TickThread.isTickThread() ? null : this.getChunkAt(blockposition).getBlockEntity(blockposition, LevelChunk.EntityCreationType.IMMEDIATE)); // Paper - rewrite chunk system
+        return this.isOutsideBuildHeight(blockposition) ? null : (this.isClientSide ? null : this.getChunkAt(blockposition).getBlockEntity(blockposition, LevelChunk.EntityCreationType.IMMEDIATE)); // Paper - rewrite chunk system
     }
 
     public void setBlockEntity(BlockEntity blockEntity) {
@@ -969,7 +967,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
 
         if (!this.isOutsideBuildHeight(blockposition)) {
             // CraftBukkit start
-            if (this.captureBlockStates) {
+            if (this.captureBlockStates.get()) {
                 this.capturedTileEntities.put(blockposition.immutable(), blockEntity);
                 return;
             }
@@ -1415,11 +1413,13 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     // Paper start
     //protected final io.papermc.paper.world.EntitySliceManager entitySliceManager; // Paper - rewrite chunk system
 
-    public org.bukkit.entity.Entity[] getChunkEntities(int chunkX, int chunkZ) {
+    public List<org.bukkit.entity.Entity> getChunkEntities(int chunkX, int chunkZ) {
+
         io.papermc.paper.world.ChunkEntitySlices slices = ((ServerLevel)this).getEntityLookup().getChunk(chunkX, chunkZ);
         if (slices == null) {
-            return new org.bukkit.entity.Entity[0];
+            return Collections.emptyList();
         }
+
         return slices.getChunkEntities();
     }
 
diff --git a/src/main/java/net/minecraft/world/level/block/BaseFireBlock.java b/src/main/java/net/minecraft/world/level/block/BaseFireBlock.java
index c8ae9f1d59ff022abe1f3ce621ac97fa3d5f19ce..a61b4a7c2c5a2ee2d72d0265155b90510de4a2a7 100644
--- a/src/main/java/net/minecraft/world/level/block/BaseFireBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/BaseFireBlock.java
@@ -142,7 +142,7 @@ public abstract class BaseFireBlock extends Block {
             }
         }
 
-        entity.hurt(DamageSource.IN_FIRE, this.fireDamage);
+        entity.hurt(DamageSource.IN_FIRE, null, null, this.fireDamage);
         super.entityInside(state, world, pos, entity);
     }
 
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index e52328f79c5251b0c4885c8eba0f015aef8b4edf..c63f2e87ecec1758144de728ac2df1347b70d82a 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -459,7 +459,7 @@ public class Block extends BlockBehaviour implements ItemLike {
     }
 
     public void fallOn(Level world, BlockState state, BlockPos pos, Entity entity, float fallDistance) {
-        entity.causeFallDamage(fallDistance, 1.0F, DamageSource.FALL);
+        entity.causeFallDamage(fallDistance, null, null, 1.0F, DamageSource.FALL);
     }
 
     public void updateEntityAfterFallOn(BlockGetter world, Entity entity) {
diff --git a/src/main/java/net/minecraft/world/level/block/CactusBlock.java b/src/main/java/net/minecraft/world/level/block/CactusBlock.java
index 62dfb2c9e4370b97415b1bdae09195dc2e7665b1..10729c1ab1bfb541a2ed5fab6acae8595bd708aa 100644
--- a/src/main/java/net/minecraft/world/level/block/CactusBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/CactusBlock.java
@@ -22,6 +22,8 @@ import net.minecraft.world.level.pathfinder.PathComputationType;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
 import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
+import org.jetbrains.annotations.NotNull;
+
 
 public class CactusBlock extends Block {
 
@@ -118,9 +120,8 @@ public class CactusBlock extends Block {
     @Override
     public void entityInside(BlockState state, Level world, BlockPos pos, Entity entity) {
         if (!new io.papermc.paper.event.entity.EntityInsideBlockEvent(entity.getBukkitEntity(), org.bukkit.craftbukkit.block.CraftBlock.at(world, pos)).callEvent()) { return; } // Paper
-        CraftEventFactory.blockDamage = world.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ()); // CraftBukkit
-        entity.hurt(DamageSource.CACTUS, 1.0F);
-        CraftEventFactory.blockDamage = null; // CraftBukkit
+        final org.bukkit.block.Block block = world.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ()); // CraftBukkit
+        entity.hurt(DamageSource.CACTUS, null, block, 1.0F);
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/CampfireBlock.java b/src/main/java/net/minecraft/world/level/block/CampfireBlock.java
index 1543e0a2e5508e1b4d0bc9d3de716ba349d61a34..cce8e7bf0be6e1be2c8942395c42ccbc3986df0e 100644
--- a/src/main/java/net/minecraft/world/level/block/CampfireBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/CampfireBlock.java
@@ -37,7 +37,6 @@ import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.BooleanProperty;
 import net.minecraft.world.level.block.state.properties.DirectionProperty;
 import net.minecraft.world.level.gameevent.GameEvent;
-import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.level.pathfinder.PathComputationType;
@@ -95,9 +94,7 @@ public class CampfireBlock extends BaseEntityBlock implements SimpleWaterloggedB
     public void entityInside(BlockState state, Level world, BlockPos pos, Entity entity) {
         if (!new io.papermc.paper.event.entity.EntityInsideBlockEvent(entity.getBukkitEntity(), org.bukkit.craftbukkit.block.CraftBlock.at(world, pos)).callEvent()) { return; } // Paper
         if (state.getValue(CampfireBlock.LIT).booleanValue() && entity instanceof LivingEntity && !EnchantmentHelper.hasFrostWalker((LivingEntity) entity)) {
-            org.bukkit.craftbukkit.event.CraftEventFactory.blockDamage = CraftBlock.at(world, pos); // CraftBukkit
-            entity.hurt(DamageSource.IN_FIRE, (float) this.fireDamage);
-            org.bukkit.craftbukkit.event.CraftEventFactory.blockDamage = null; // CraftBukkit
+            entity.hurt(DamageSource.IN_FIRE, null, CraftBlock.at(world, pos), (float) this.fireDamage);
         }
 
         super.entityInside(state, world, pos, entity);
diff --git a/src/main/java/net/minecraft/world/level/block/HoneyBlock.java b/src/main/java/net/minecraft/world/level/block/HoneyBlock.java
index 683f24251baf8ef3bef8f32ba83dc7f0e8ed7d70..ea54a5e26a2e4a8b6dc3bb60b43f6a44f2467cf4 100644
--- a/src/main/java/net/minecraft/world/level/block/HoneyBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/HoneyBlock.java
@@ -47,7 +47,7 @@ public class HoneyBlock extends HalfTransparentBlock {
             world.broadcastEntityEvent(entity, (byte)54);
         }
 
-        if (entity.causeFallDamage(fallDistance, 0.2F, DamageSource.FALL)) {
+        if (entity.causeFallDamage(fallDistance, null, null, 0.2F, DamageSource.FALL)) {
             entity.playSound(this.soundType.getFallSound(), this.soundType.getVolume() * 0.5F, this.soundType.getPitch() * 0.75F);
         }
 
diff --git a/src/main/java/net/minecraft/world/level/block/MagmaBlock.java b/src/main/java/net/minecraft/world/level/block/MagmaBlock.java
index 091d048ab69d71316d06929147fe7d4e771c7142..33112c566f5d3b22a0fbdcf77053d008fd3b8b95 100644
--- a/src/main/java/net/minecraft/world/level/block/MagmaBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/MagmaBlock.java
@@ -11,7 +11,6 @@ import net.minecraft.util.RandomSource;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.enchantment.EnchantmentHelper;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelAccessor;
@@ -29,9 +28,7 @@ public class MagmaBlock extends Block {
     @Override
     public void stepOn(Level world, BlockPos pos, BlockState state, Entity entity) {
         if (!entity.isSteppingCarefully() && entity instanceof LivingEntity && !EnchantmentHelper.hasFrostWalker((LivingEntity) entity)) {
-            org.bukkit.craftbukkit.event.CraftEventFactory.blockDamage = world.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ()); // CraftBukkit
-            entity.hurt(DamageSource.HOT_FLOOR, 1.0F);
-            org.bukkit.craftbukkit.event.CraftEventFactory.blockDamage = null; // CraftBukkit
+            entity.hurt(DamageSource.HOT_FLOOR, null, world.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ()), 1.0F);
         }
 
         super.stepOn(world, pos, state, entity);
diff --git a/src/main/java/net/minecraft/world/level/block/PointedDripstoneBlock.java b/src/main/java/net/minecraft/world/level/block/PointedDripstoneBlock.java
index 1e0c0819f6f1936215ca2da56d42d76577ac6495..1d564869ea5b8b8759c7eb1a019bc3c036a755c4 100644
--- a/src/main/java/net/minecraft/world/level/block/PointedDripstoneBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/PointedDripstoneBlock.java
@@ -143,9 +143,7 @@ public class PointedDripstoneBlock extends Block implements Fallable, SimpleWate
     @Override
     public void fallOn(Level world, BlockState state, BlockPos pos, Entity entity, float fallDistance) {
         if (state.getValue(PointedDripstoneBlock.TIP_DIRECTION) == Direction.UP && state.getValue(PointedDripstoneBlock.THICKNESS) == DripstoneThickness.TIP) {
-            CraftEventFactory.blockDamage = CraftBlock.at(world, pos); // CraftBukkit
-            entity.causeFallDamage(fallDistance + 2.0F, 2.0F, DamageSource.STALAGMITE);
-            CraftEventFactory.blockDamage = null; // CraftBukkit
+            entity.causeFallDamage(fallDistance + 2.0F, null, CraftBlock.at(world, pos), 2.0F, DamageSource.STALAGMITE);
         } else {
             super.fallOn(world, state, pos, entity, fallDistance);
         }
diff --git a/src/main/java/net/minecraft/world/level/block/SweetBerryBushBlock.java b/src/main/java/net/minecraft/world/level/block/SweetBerryBushBlock.java
index 120acd68d0c1376b96916ee0732e5734a19c3df1..7f2a1e5b8bda96ccd450429d23fbf77407a88c4d 100644
--- a/src/main/java/net/minecraft/world/level/block/SweetBerryBushBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/SweetBerryBushBlock.java
@@ -85,9 +85,7 @@ public class SweetBerryBushBlock extends BushBlock implements BonemealableBlock
                 double d1 = Math.abs(entity.getZ() - entity.zOld);
 
                 if (d0 >= 0.003000000026077032D || d1 >= 0.003000000026077032D) {
-                    CraftEventFactory.blockDamage = CraftBlock.at(world, pos); // CraftBukkit
-                    entity.hurt(DamageSource.SWEET_BERRY_BUSH, 1.0F);
-                    CraftEventFactory.blockDamage = null; // CraftBukkit
+                    entity.hurt(DamageSource.SWEET_BERRY_BUSH, null, CraftBlock.at(world, pos), 1.0F);
                 }
             }
 
diff --git a/src/main/java/net/minecraft/world/level/block/WitherSkullBlock.java b/src/main/java/net/minecraft/world/level/block/WitherSkullBlock.java
index 79c26c0e2995ec875276d5de715cd97d7002ebec..d8ae28a531e62fd833b080c6dc6d4587e4fba0bd 100644
--- a/src/main/java/net/minecraft/world/level/block/WitherSkullBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/WitherSkullBlock.java
@@ -54,7 +54,7 @@ public class WitherSkullBlock extends SkullBlock {
     }
 
     public static void checkSpawn(Level world, BlockPos pos, SkullBlockEntity blockEntity) {
-        if (world.captureBlockStates) return; // CraftBukkit
+        if (world.captureBlockStates.get()) return; // CraftBukkit
         if (!world.isClientSide) {
             BlockState iblockdata = blockEntity.getBlockState();
             boolean flag = iblockdata.is(Blocks.WITHER_SKELETON_SKULL) || iblockdata.is(Blocks.WITHER_SKELETON_WALL_SKULL);
diff --git a/src/main/java/net/minecraft/world/level/block/entity/ConduitBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/ConduitBlockEntity.java
index 7eac6bd8ec6945679db4c3a02c0be6dab3a07030..b57daf6d4077d3782855703b9aefa1c7db939f47 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/ConduitBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/ConduitBlockEntity.java
@@ -236,11 +236,9 @@ public class ConduitBlockEntity extends BlockEntity {
 
         if (blockEntity.destroyTarget != null) {
             // CraftBukkit start
-            CraftEventFactory.blockDamage = CraftBlock.at(world, pos);
-            if (blockEntity.destroyTarget.hurt(DamageSource.MAGIC, 4.0F)) {
+            if (blockEntity.destroyTarget.hurt(DamageSource.MAGIC, null, CraftBlock.at(world, pos), 4.0F)) {
                 world.playSound(null, blockEntity.destroyTarget.getX(), blockEntity.destroyTarget.getY(), blockEntity.destroyTarget.getZ(), SoundEvents.CONDUIT_ATTACK_TARGET, SoundSource.BLOCKS, 1.0F, 1.0F);
             }
-            CraftEventFactory.blockDamage = null;
             // CraftBukkit end
         }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
index 93cd122bcb454791fffe19b9057f0cde3e27448d..c8092950e3dc1dbe58bb997d38db9dadb776a81f 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -13,6 +13,7 @@ import java.util.EnumSet;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
@@ -72,7 +73,7 @@ public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiom
     public final Map<Heightmap.Types, Heightmap> heightmaps = Maps.newEnumMap(Heightmap.Types.class);
     private final Map<Structure, StructureStart> structureStarts = Maps.newHashMap();
     private final Map<Structure, LongSet> structuresRefences = Maps.newHashMap();
-    protected final Map<BlockPos, CompoundTag> pendingBlockEntities = Maps.newHashMap();
+    protected final Map<BlockPos, CompoundTag> pendingBlockEntities = new ConcurrentHashMap<>();
     public final Map<BlockPos, BlockEntity> blockEntities = Maps.newHashMap();
     protected final LevelHeightAccessor levelHeightAccessor;
     protected final LevelChunkSection[] sections;
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 200c38809fcc2902c6ca9721a0dc6ec619af1476..63f1e0496ebf9e4e2c5cc5867569fbbaaaa5512f 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -11,6 +11,7 @@ import it.unimi.dsi.fastutil.shorts.ShortListIterator;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
@@ -84,7 +85,7 @@ public class LevelChunk extends ChunkAccess {
     private Supplier<ChunkHolder.FullChunkStatus> fullStatus;
     @Nullable
     private LevelChunk.PostLoadProcessor postLoad;
-    private final Int2ObjectMap<GameEventDispatcher> gameEventDispatcherSections;
+    private final Map<Integer, GameEventDispatcher> gameEventDispatcherSections;
     private final LevelChunkTicks<Block> blockTicks;
     private final LevelChunkTicks<Fluid> fluidTicks;
 
@@ -101,7 +102,7 @@ public class LevelChunk extends ChunkAccess {
         this.tickersInLevel = Maps.newHashMap();
         this.clientLightReady = false;
         this.level = (ServerLevel) world; // CraftBukkit - type
-        this.gameEventDispatcherSections = new Int2ObjectOpenHashMap();
+        this.gameEventDispatcherSections = new ConcurrentHashMap<>();
         Heightmap.Types[] aheightmap_type = Heightmap.Types.values();
         int j = aheightmap_type.length;
 
@@ -594,7 +595,7 @@ public class LevelChunk extends ChunkAccess {
                     return null;
                 } else {
                     // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
-                    if (!this.level.isClientSide && doPlace && (!this.level.captureBlockStates || block instanceof net.minecraft.world.level.block.BaseEntityBlock)) {
+                    if (!this.level.isClientSide && doPlace && (!this.level.captureBlockStates.get() || block instanceof net.minecraft.world.level.block.BaseEntityBlock)) {
                         iblockdata.onPlace(this.level, blockposition, iblockdata1, flag);
                     }
 
diff --git a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
index e351d52fc659700c7959a59d85576826011e2e23..c2bedbc14fc928ac672274454a742aac5b6baf11 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
@@ -1,11 +1,15 @@
 package net.minecraft.world.level.entity;
 
+/*
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Spliterator;
 import java.util.function.Consumer;
 
 import net.minecraft.world.entity.Entity;
 
 public class EntityTickList {
-    private final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<Entity> entities = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(true); // Paper - rewrite this, always keep this updated - why would we EVER tick an entity that's not ticking?
+    private final List<Entity> entities = new ArrayList<>(); // Paper - rewrite this, always keep this updated - why would we EVER tick an entity that's not ticking?
 
     private void ensureActiveIsNotIterated() {
         // Paper - replace with better logic, do not delay removals
@@ -33,7 +37,8 @@ public class EntityTickList {
         // Paper start - replace with better logic, do not delay removals/additions
         // To ensure nothing weird happens with dimension travelling, do not iterate over new entries...
         // (by dfl iterator() is configured to not iterate over new entries)
-        io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.Iterator<Entity> iterator = this.entities.iterator();
+        //io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.Iterator<Entity> iterator = this.entities.iterator();
+
         try {
             while (iterator.hasNext()) {
                 action.accept(iterator.next());
@@ -41,6 +46,8 @@ public class EntityTickList {
         } finally {
             iterator.finishedIterating();
         }
+        Spliterator
         // Paper end - replace with better logic, do not delay removals/additions
     }
 }
+*/
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/world/level/gameevent/EuclideanGameEventDispatcher.java b/src/main/java/net/minecraft/world/level/gameevent/EuclideanGameEventDispatcher.java
index 0dd708ebe81f73710de51215529c05ec61837dd3..6b23ccc83ac88c70b5665a8e9487b68a477dbee5 100644
--- a/src/main/java/net/minecraft/world/level/gameevent/EuclideanGameEventDispatcher.java
+++ b/src/main/java/net/minecraft/world/level/gameevent/EuclideanGameEventDispatcher.java
@@ -6,15 +6,18 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CopyOnWriteArraySet;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.BiConsumer;
 import net.minecraft.network.protocol.game.DebugPackets;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.phys.Vec3;
 
 public class EuclideanGameEventDispatcher implements GameEventDispatcher {
-    private final List<GameEventListener> listeners = Lists.newArrayList();
-    private final Set<GameEventListener> listenersToRemove = Sets.newHashSet();
-    private final List<GameEventListener> listenersToAdd = Lists.newArrayList();
+    private final List<GameEventListener> listeners = new CopyOnWriteArrayList<>();
+    private final Set<GameEventListener> listenersToRemove = new CopyOnWriteArraySet<>();
+    private final List<GameEventListener> listenersToAdd = new CopyOnWriteArrayList<>();
     private boolean processing;
     private final ServerLevel level;
 
@@ -54,32 +57,24 @@ public class EuclideanGameEventDispatcher implements GameEventDispatcher {
         boolean bl = false;
 
         try {
-            Iterator<GameEventListener> iterator = this.listeners.iterator();
-
-            while(iterator.hasNext()) {
-                GameEventListener gameEventListener = iterator.next();
-                if (this.listenersToRemove.remove(gameEventListener)) {
-                    iterator.remove();
-                } else {
-                    Optional<Vec3> optional = getPostableListenerPosition(this.level, pos, gameEventListener);
-                    if (optional.isPresent()) {
-                        onListenerAccept.accept(gameEventListener, optional.get());
-                        bl = true;
-                    }
+
+            listeners.removeAll(this.listenersToRemove);
+
+            for (final GameEventListener listener : this.listeners) {
+                final Optional<Vec3> optional = getPostableListenerPosition(this.level, pos, listener);
+                if (optional.isPresent()) {
+                    onListenerAccept.accept(listener, optional.get());
+                    bl = true;
                 }
             }
-        } finally {
-            this.processing = false;
-        }
 
-        if (!this.listenersToAdd.isEmpty()) {
-            this.listeners.addAll(this.listenersToAdd);
-            this.listenersToAdd.clear();
-        }
+            listeners.addAll(this.listenersToAdd);
+
+            listenersToAdd.clear();
+            listenersToRemove.clear();
 
-        if (!this.listenersToRemove.isEmpty()) {
-            this.listeners.removeAll(this.listenersToRemove);
-            this.listenersToRemove.clear();
+        } finally {
+            this.processing = false;
         }
 
         return bl;
diff --git a/src/main/java/net/minecraft/world/level/levelgen/LegacyRandomSource.java b/src/main/java/net/minecraft/world/level/levelgen/LegacyRandomSource.java
index daa03360dd7044f10b20f36023b305dc7e0bb7df..29f827c6655d46c2db59b862df72def2739b77aa 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/LegacyRandomSource.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/LegacyRandomSource.java
@@ -30,22 +30,25 @@ public class LegacyRandomSource implements BitRandomSource {
 
     @Override
     public void setSeed(long seed) {
-        if (!this.seed.compareAndSet(this.seed.get(), (seed ^ 25214903917L) & 281474976710655L)) {
-            throw ThreadingDetector.makeThreadingException("LegacyRandomSource", (Thread)null);
-        } else {
-            this.gaussianSource.reset();
-        }
+        //if (!this.seed.compareAndSet(this.seed.get(), (seed ^ 25214903917L) & 281474976710655L)) {
+            //throw ThreadingDetector.makeThreadingException("LegacyRandomSource", (Thread)null);
+        //} else {
+
+        this.seed.compareAndSet(this.seed.get(), (seed ^ 25214903917L) & 281474976710655L);
+        this.gaussianSource.reset();
+        //}
     }
 
     @Override
     public int next(int bits) {
         long l = this.seed.get();
         long m = l * 25214903917L + 11L & 281474976710655L;
-        if (!this.seed.compareAndSet(l, m)) {
-            throw ThreadingDetector.makeThreadingException("LegacyRandomSource", (Thread)null);
-        } else {
-            return (int)(m >> 48 - bits);
-        }
+       // if (!this.seed.compareAndSet(l, m)) {
+            //throw ThreadingDetector.makeThreadingException("LegacyRandomSource", (Thread)null);
+        //} else {
+        this.seed.compareAndSet(l, m);
+        return (int)(m >> 48 - bits);
+        //}
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/Path.java b/src/main/java/net/minecraft/world/level/pathfinder/Path.java
index 701c568baeaca533fbcffa7b1ace6e2fc93d796c..21092c2e167d5d33809e0a7b29a37024d1603fac 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/Path.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/Path.java
@@ -4,6 +4,8 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.atomic.AtomicInteger;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.network.FriendlyByteBuf;
@@ -17,29 +19,29 @@ public class Path {
     private Node[] closedSet = new Node[0];
     @Nullable
     private Set<Target> targetNodes;
-    private int nextNodeIndex;
+    private AtomicInteger nextNodeIndex = new AtomicInteger(0);
     private final BlockPos target;
     private final float distToTarget;
     private final boolean reached;
     public boolean hasNext() { return getNextNodeIndex() < this.nodes.size(); } // Paper
 
     public Path(List<Node> nodes, BlockPos target, boolean reachesTarget) {
-        this.nodes = nodes;
+        this.nodes = new CopyOnWriteArrayList<>(nodes);
         this.target = target;
         this.distToTarget = nodes.isEmpty() ? Float.MAX_VALUE : this.nodes.get(this.nodes.size() - 1).distanceManhattan(this.target);
         this.reached = reachesTarget;
     }
 
     public void advance() {
-        ++this.nextNodeIndex;
+        this.nextNodeIndex.incrementAndGet();
     }
 
     public boolean notStarted() {
-        return this.nextNodeIndex <= 0;
+        return this.nextNodeIndex.get() <= 0;
     }
 
     public boolean isDone() {
-        return this.nextNodeIndex >= this.nodes.size();
+        return this.nextNodeIndex.get() >= this.nodes.size();
     }
 
     @Nullable
@@ -67,11 +69,11 @@ public class Path {
     }
 
     public int getNextNodeIndex() {
-        return this.nextNodeIndex;
+        return this.nextNodeIndex.get();
     }
 
     public void setNextNodeIndex(int nodeIndex) {
-        this.nextNodeIndex = nodeIndex;
+        this.nextNodeIndex.set(nodeIndex);
     }
 
     public Vec3 getEntityPosAtNode(Entity entity, int index) {
@@ -87,20 +89,20 @@ public class Path {
     }
 
     public Vec3 getNextEntityPos(Entity entity) {
-        return this.getEntityPosAtNode(entity, this.nextNodeIndex);
+        return this.getEntityPosAtNode(entity, this.nextNodeIndex.get());
     }
 
     public BlockPos getNextNodePos() {
-        return this.nodes.get(this.nextNodeIndex).asBlockPos();
+        return this.nodes.get(this.nextNodeIndex.get()).asBlockPos();
     }
 
     public Node getNextNode() {
-        return this.nodes.get(this.nextNodeIndex);
+        return this.nodes.get(this.nextNodeIndex.get());
     }
 
     @Nullable
     public Node getPreviousNode() {
-        return this.nextNodeIndex > 0 ? this.nodes.get(this.nextNodeIndex - 1) : null;
+        return this.nextNodeIndex.get() > 0 ? this.nodes.get(this.nextNodeIndex.get() - 1) : null;
     }
 
     public boolean sameAs(@Nullable Path o) {
@@ -145,7 +147,7 @@ public class Path {
     public void writeToStream(FriendlyByteBuf buffer) {
         if (this.targetNodes != null && !this.targetNodes.isEmpty()) {
             buffer.writeBoolean(this.reached);
-            buffer.writeInt(this.nextNodeIndex);
+            buffer.writeInt(this.nextNodeIndex.get());
             buffer.writeInt(this.targetNodes.size());
             this.targetNodes.forEach((target) -> {
                 target.writeToStream(buffer);
@@ -208,7 +210,7 @@ public class Path {
         path.openSet = nodes;
         path.closedSet = nodes2;
         path.targetNodes = set;
-        path.nextNodeIndex = i;
+        path.nextNodeIndex.set(i);
         return path;
     }
 
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java b/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
index 08b5315b8328aba1b5f2ae70b5f606c3d5fdcdd5..7254b6b696d7bfa9850d17e83bcec6d4ac694de0 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
@@ -13,6 +13,7 @@ import net.minecraft.tags.FluidTags;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Mob;
 import net.minecraft.world.level.BlockGetter;
+import net.minecraft.world.level.Level;
 import net.minecraft.world.level.PathNavigationRegion;
 import net.minecraft.world.level.block.BaseRailBlock;
 import net.minecraft.world.level.block.Block;
@@ -43,7 +44,13 @@ public class WalkNodeEvaluator extends NodeEvaluator {
 
     @Override
     public void done() {
-        this.mob.setPathfindingMalus(BlockPathTypes.WATER, this.oldWaterCost);
+
+        final Mob mob = this.mob;
+        if (mob == null) {
+            return;
+        }
+
+        mob.setPathfindingMalus(BlockPathTypes.WATER, this.oldWaterCost);
         this.pathTypesByPosCache.clear();
         this.collisionCache.clear();
         super.done();
@@ -52,11 +59,19 @@ public class WalkNodeEvaluator extends NodeEvaluator {
     @Nullable
     @Override
     public @org.jetbrains.annotations.Nullable Node getStart() {
+
+        final PathNavigationRegion level = this.level;
+        final Mob mob = this.mob;
+
+        if (level == null || mob == null) {
+            return null;
+        }
+
         BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
-        int i = this.mob.getBlockY();
-        BlockState blockState = this.level.getBlockState(mutableBlockPos.set(this.mob.getX(), i, this.mob.getZ()));
-        if (!this.mob.canStandOnFluid(blockState.getFluidState())) {
-            if (this.canFloat() && this.mob.isInWater()) {
+        int i = mob.getBlockY();
+        BlockState blockState = this.level.getBlockState(mutableBlockPos.set(mob.getX(), i, mob.getZ()));
+        if (!mob.canStandOnFluid(blockState.getFluidState())) {
+            if (this.canFloat() && mob.isInWater()) {
                 while(true) {
                     if (!blockState.is(Blocks.WATER) && blockState.getFluidState() != Fluids.WATER.getSource(false)) {
                         --i;
@@ -64,30 +79,30 @@ public class WalkNodeEvaluator extends NodeEvaluator {
                     }
 
                     ++i;
-                    blockState = this.level.getBlockState(mutableBlockPos.set(this.mob.getX(), i, this.mob.getZ()));
+                    blockState = this.level.getBlockState(mutableBlockPos.set(mob.getX(), i, mob.getZ()));
                 }
-            } else if (this.mob.isOnGround()) {
-                i = Mth.floor(this.mob.getY() + 0.5D);
+            } else if (mob.isOnGround()) {
+                i = Mth.floor(mob.getY() + 0.5D);
             } else {
                 BlockPos blockPos;
-                for(blockPos = this.mob.blockPosition(); (this.level.getBlockState(blockPos).isAir() || this.level.getBlockState(blockPos).isPathfindable(this.level, blockPos, PathComputationType.LAND)) && blockPos.getY() > this.mob.level.getMinBuildHeight(); blockPos = blockPos.below()) {
+                for(blockPos = mob.blockPosition(); (level.getBlockState(blockPos).isAir() || level.getBlockState(blockPos).isPathfindable(level, blockPos, PathComputationType.LAND)) && blockPos.getY() > mob.level.getMinBuildHeight(); blockPos = blockPos.below()) {
                 }
 
                 i = blockPos.above().getY();
             }
         } else {
-            while(this.mob.canStandOnFluid(blockState.getFluidState())) {
+            while(mob.canStandOnFluid(blockState.getFluidState())) {
                 ++i;
-                blockState = this.level.getBlockState(mutableBlockPos.set(this.mob.getX(), i, this.mob.getZ()));
+                blockState = level.getBlockState(mutableBlockPos.set(mob.getX(), i, mob.getZ()));
             }
 
             --i;
         }
 
-        BlockPos blockPos2 = this.mob.blockPosition();
-        BlockPathTypes blockPathTypes = this.getCachedBlockType(this.mob, blockPos2.getX(), i, blockPos2.getZ());
-        if (this.mob.getPathfindingMalus(blockPathTypes) < 0.0F) {
-            AABB aABB = this.mob.getBoundingBox();
+        BlockPos blockPos2 = mob.blockPosition();
+        BlockPathTypes blockPathTypes = this.getCachedBlockType(mob, blockPos2.getX(), i, blockPos2.getZ());
+        if (mob.getPathfindingMalus(blockPathTypes) < 0.0F) {
+            AABB aABB = mob.getBoundingBox();
             if (this.hasPositiveMalus(mutableBlockPos.set(aABB.minX, i, aABB.minZ)) || this.hasPositiveMalus(mutableBlockPos.set(aABB.minX, i, aABB.maxZ)) || this.hasPositiveMalus(mutableBlockPos.set(aABB.maxX, i, aABB.minZ)) || this.hasPositiveMalus(mutableBlockPos.set(aABB.maxX, i, aABB.maxZ))) {
                 return this.getStartNode(mutableBlockPos);
             }
@@ -220,6 +235,11 @@ public class WalkNodeEvaluator extends NodeEvaluator {
     }
 
     public static double getFloorLevel(BlockGetter world, BlockPos pos) {
+
+        if (world == null) {
+            return 0;
+        }
+
         BlockPos blockPos = pos.below();
         VoxelShape voxelShape = world.getBlockState(blockPos).getCollisionShape(world, blockPos);
         return (double)blockPos.getY() + (voxelShape.isEmpty() ? 0.0D : voxelShape.max(Direction.Axis.Y));
@@ -237,9 +257,19 @@ public class WalkNodeEvaluator extends NodeEvaluator {
         if (d - prevFeetY > 1.125D) {
             return null;
         } else {
-            BlockPathTypes blockPathTypes = this.getCachedBlockType(this.mob, x, y, z);
-            float f = this.mob.getPathfindingMalus(blockPathTypes);
-            double e = (double)this.mob.getBbWidth() / 2.0D;
+
+            final Mob mob = this.mob;
+            if (mob == null) {
+                return null;
+            }
+
+            BlockPathTypes blockPathTypes = this.getCachedBlockType(mob, x, y, z);
+            if (blockPathTypes == null) {
+                return null;
+            }
+
+            float f = mob.getPathfindingMalus(blockPathTypes);
+            double e = (double)mob.getBbWidth() / 2.0D;
             if (f >= 0.0F) {
                 node = this.getNodeAndUpdateCostToMax(x, y, z, blockPathTypes, f);
             }
@@ -251,10 +281,10 @@ public class WalkNodeEvaluator extends NodeEvaluator {
             if (blockPathTypes != BlockPathTypes.WALKABLE && (!this.isAmphibious() || blockPathTypes != BlockPathTypes.WATER)) {
                 if ((node == null || node.costMalus < 0.0F) && maxYStep > 0 && blockPathTypes != BlockPathTypes.FENCE && blockPathTypes != BlockPathTypes.UNPASSABLE_RAIL && blockPathTypes != BlockPathTypes.TRAPDOOR && blockPathTypes != BlockPathTypes.POWDER_SNOW) {
                     node = this.findAcceptedNode(x, y + 1, z, maxYStep - 1, prevFeetY, direction, nodeType);
-                    if (node != null && (node.type == BlockPathTypes.OPEN || node.type == BlockPathTypes.WALKABLE) && this.mob.getBbWidth() < 1.0F) {
+                    if (node != null && (node.type == BlockPathTypes.OPEN || node.type == BlockPathTypes.WALKABLE) && mob.getBbWidth() < 1.0F) {
                         double g = (double)(x - direction.getStepX()) + 0.5D;
                         double h = (double)(z - direction.getStepZ()) + 0.5D;
-                        AABB aABB = new AABB(g - e, getFloorLevel(this.level, mutableBlockPos.set(g, y + 1, h)) + 0.001D, h - e, g + e, (double)this.mob.getBbHeight() + getFloorLevel(this.level, mutableBlockPos.set(node.x, node.y, (double)node.z)) - 0.002D, h + e);
+                        AABB aABB = new AABB(g - e, getFloorLevel(this.level, mutableBlockPos.set(g, y + 1, h)) + 0.001D, h - e, g + e, (double)mob.getBbHeight() + getFloorLevel(this.level, mutableBlockPos.set(node.x, node.y, (double)node.z)) - 0.002D, h + e);
                         if (this.hasCollisions(aABB)) {
                             node = null;
                         }
@@ -262,18 +292,22 @@ public class WalkNodeEvaluator extends NodeEvaluator {
                 }
 
                 if (!this.isAmphibious() && blockPathTypes == BlockPathTypes.WATER && !this.canFloat()) {
-                    if (this.getCachedBlockType(this.mob, x, y - 1, z) != BlockPathTypes.WATER) {
+                    if (this.getCachedBlockType(mob, x, y - 1, z) != BlockPathTypes.WATER) {
                         return node;
                     }
 
-                    while(y > this.mob.level.getMinBuildHeight()) {
+                    while(y > mob.level.getMinBuildHeight()) {
                         --y;
-                        blockPathTypes = this.getCachedBlockType(this.mob, x, y, z);
+                        blockPathTypes = this.getCachedBlockType(mob, x, y, z);
+                        if (blockPathTypes == null) {
+                            return null;
+                        }
                         if (blockPathTypes != BlockPathTypes.WATER) {
                             return node;
                         }
 
-                        node = this.getNodeAndUpdateCostToMax(x, y, z, blockPathTypes, this.mob.getPathfindingMalus(blockPathTypes));
+
+                        node = this.getNodeAndUpdateCostToMax(x, y, z, blockPathTypes, mob.getPathfindingMalus(blockPathTypes));
                     }
                 }
 
@@ -283,16 +317,16 @@ public class WalkNodeEvaluator extends NodeEvaluator {
 
                     while(blockPathTypes == BlockPathTypes.OPEN) {
                         --y;
-                        if (y < this.mob.level.getMinBuildHeight()) {
+                        if (y < mob.level.getMinBuildHeight()) {
                             return this.getBlockedNode(x, j, z);
                         }
 
-                        if (i++ >= this.mob.getMaxFallDistance()) {
+                        if (i++ >= mob.getMaxFallDistance()) {
                             return this.getBlockedNode(x, y, z);
                         }
 
-                        blockPathTypes = this.getCachedBlockType(this.mob, x, y, z);
-                        f = this.mob.getPathfindingMalus(blockPathTypes);
+                        blockPathTypes = this.getCachedBlockType(mob, x, y, z);
+                        f = mob.getPathfindingMalus(blockPathTypes);
                         if (blockPathTypes != BlockPathTypes.OPEN && f >= 0.0F) {
                             node = this.getNodeAndUpdateCostToMax(x, y, z, blockPathTypes, f);
                             break;
@@ -350,6 +384,11 @@ public class WalkNodeEvaluator extends NodeEvaluator {
 
     @Override
     public BlockPathTypes getBlockPathType(BlockGetter world, int x, int y, int z, Mob mob, int sizeX, int sizeY, int sizeZ, boolean canOpenDoors, boolean canEnterOpenDoors) {
+
+        if (mob == null) {
+            return BlockPathTypes.BLOCKED;
+        }
+
         EnumSet<BlockPathTypes> enumSet = EnumSet.noneOf(BlockPathTypes.class);
         BlockPathTypes blockPathTypes = BlockPathTypes.BLOCKED;
         BlockPos blockPos = mob.blockPosition();
diff --git a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
index b1c594dc6a6b8a6c737b99272acab9e7dbd0ed63..44b94402773d6f5964fcfc83646b72bfc18d7b4b 100644
--- a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
+++ b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
@@ -3,7 +3,10 @@ package net.minecraft.world.level.redstone;
 import com.mojang.logging.LogUtils;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Deque;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.CopyOnWriteArrayList;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -16,8 +19,8 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Level level;
     private final int maxChainedNeighborUpdates;
-    private final ArrayDeque<CollectingNeighborUpdater.NeighborUpdates> stack = new ArrayDeque<>();
-    private final List<CollectingNeighborUpdater.NeighborUpdates> addedThisLayer = new ArrayList<>();
+    private final Deque<NeighborUpdates> stack = new ConcurrentLinkedDeque<>();
+    private final List<CollectingNeighborUpdater.NeighborUpdates> addedThisLayer = new CopyOnWriteArrayList<>();
     private int count = 0;
 
     public CollectingNeighborUpdater(Level world, int maxChainDepth) {
@@ -45,7 +48,7 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
         this.addAndRun(pos, new CollectingNeighborUpdater.MultiNeighborUpdate(pos.immutable(), sourceBlock, except));
     }
 
-    private void addAndRun(BlockPos pos, CollectingNeighborUpdater.NeighborUpdates entry) {
+    private synchronized void addAndRun(BlockPos pos, CollectingNeighborUpdater.NeighborUpdates entry) {
         boolean bl = this.count > 0;
         boolean bl2 = this.maxChainedNeighborUpdates >= 0 && this.count >= this.maxChainedNeighborUpdates;
         ++this.count;
@@ -66,6 +69,7 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     }
 
     private void runUpdates() {
+
         try {
             while(!this.stack.isEmpty() || !this.addedThisLayer.isEmpty()) {
                 for(int i = this.addedThisLayer.size() - 1; i >= 0; --i) {
diff --git a/src/main/java/net/minecraft/world/ticks/LevelTicks.java b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
index 7f1ac2cb29eb84833c0895442d611dfa0504527e..3f01d3e493b9aaf8813766bcc23bfc2f1423fbf4 100644
--- a/src/main/java/net/minecraft/world/ticks/LevelTicks.java
+++ b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
@@ -1,24 +1,6 @@
 package net.minecraft.world.ticks;
 
-import it.unimi.dsi.fastutil.longs.Long2LongMap;
-import it.unimi.dsi.fastutil.longs.Long2LongMaps;
-import it.unimi.dsi.fastutil.longs.Long2LongOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
-import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Comparator;
-import java.util.List;
-import java.util.LongSummaryStatistics;
-import java.util.PriorityQueue;
-import java.util.Queue;
-import java.util.Set;
-import java.util.function.BiConsumer;
-import java.util.function.LongPredicate;
-import java.util.function.Predicate;
-import java.util.function.Supplier;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -27,16 +9,24 @@ import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
 
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.BiConsumer;
+import java.util.function.LongPredicate;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+
 public class LevelTicks<T> implements LevelTickAccess<T> {
     private static final Comparator<LevelChunkTicks<?>> CONTAINER_DRAIN_ORDER = (a, b) -> {
         return ScheduledTick.INTRA_TICK_DRAIN_ORDER.compare(a.peek(), b.peek());
     };
     private final LongPredicate tickCheck;
     private final Supplier<ProfilerFiller> profiler;
-    private final Long2ObjectMap<LevelChunkTicks<T>> allContainers = new Long2ObjectOpenHashMap<>();
-    private final Long2LongMap nextTickForContainer = Util.make(new Long2LongOpenHashMap(), (map) -> {
+    private final ConcurrentHashMap<Long, LevelChunkTicks<T>> allContainers = new ConcurrentHashMap<>();
+    private final Map<Long, Long> nextTickForContainer = new ConcurrentHashMap<Long, Long>();/*Util.make(new Long2LongOpenHashMap(), (map) -> {
         map.defaultReturnValue(Long.MAX_VALUE);
-    });
+    });*/
+
     private final Queue<LevelChunkTicks<T>> containersToTick = new PriorityQueue<>(CONTAINER_DRAIN_ORDER);
     private final Queue<ScheduledTick<T>> toRunThisTick = new ArrayDeque<>();
     private final List<ScheduledTick<T>> alreadyRunThisTick = new ArrayList<>();
@@ -69,7 +59,7 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
         LevelChunkTicks<T> levelChunkTicks = this.allContainers.remove(l);
         this.nextTickForContainer.remove(l);
         if (levelChunkTicks != null) {
-            levelChunkTicks.setOnTickAdded((BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>>)null);
+            levelChunkTicks.setOnTickAdded(null);
         }
 
     }
@@ -105,12 +95,13 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     }
 
     private void sortContainersToTick(long time) {
-        ObjectIterator<Long2LongMap.Entry> objectIterator = Long2LongMaps.fastIterator(this.nextTickForContainer);
+
+        final Iterator<Map.Entry<Long, Long>> objectIterator = this.nextTickForContainer.entrySet().iterator();
 
         while(objectIterator.hasNext()) {
-            Long2LongMap.Entry entry = objectIterator.next();
-            long l = entry.getLongKey();
-            long m = entry.getLongValue();
+            final Map.Entry<Long, Long> entry = objectIterator.next();
+            long l = entry.getKey();
+            long m = entry.getValue();
             if (m <= time) {
                 LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(l);
                 if (levelChunkTicks == null) {
@@ -226,10 +217,10 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     }
 
     private void forContainersInArea(BoundingBox box, LevelTicks.PosAndContainerConsumer<T> visitor) {
-        int i = SectionPos.posToSectionCoord((double)box.minX());
-        int j = SectionPos.posToSectionCoord((double)box.minZ());
-        int k = SectionPos.posToSectionCoord((double)box.maxX());
-        int l = SectionPos.posToSectionCoord((double)box.maxZ());
+        int i = SectionPos.posToSectionCoord(box.minX());
+        int j = SectionPos.posToSectionCoord(box.minZ());
+        int k = SectionPos.posToSectionCoord(box.maxX());
+        int l = SectionPos.posToSectionCoord(box.maxZ());
 
         for(int m = i; m <= k; ++m) {
             for(int n = j; n <= l; ++n) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index 7f6c1e02eed360b40d2894efc03e3b7495049f59..2ea0a99bb8792172d7ca48fc8d6b470aa1177a5b 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -119,12 +119,12 @@ public class CraftChunk implements Chunk {
     }
 
     @Override
-    public Entity @NotNull [] getEntities() {
+    public @NotNull Entity @NotNull [] getEntities() {
         if (!this.isLoaded()) {
             this.getWorld().getChunkAt(x, z); // Transient load for this tick
         }
 
-        return getCraftWorld().getHandle().getChunkEntities(this.x, this.z); // Paper - rewrite chunk system
+        return getCraftWorld().getHandle().getChunkEntities(this.x, this.z).toArray(Entity[]::new); // Paper - rewrite chunk system
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 2d0b8a94f27babe1cac8a408275542244341490b..2c15188ab282cbb9d19806c00a5aa320e25b129e 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -793,9 +793,9 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public boolean generateTree(@NotNull Location loc, TreeType type, @NotNull BlockChangeDelegate delegate) {
         world.captureTreeGeneration = true;
-        world.captureBlockStates = true;
+        world.captureBlockStates.set(true);
         boolean grownTree = this.generateTree(loc, type);
-        world.captureBlockStates = false;
+        world.captureBlockStates.set(false);
         world.captureTreeGeneration = false;
         if (grownTree) { // Copy block data to delegate
             for (BlockState blockstate : world.capturedBlockStates.values()) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
index a4300247ff77d8ad7e0bad4173b546417aa4d382..0ee16a2d168f90530e8de42da1b359b3d03586b6 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
@@ -19,7 +19,6 @@ import net.minecraft.world.entity.MobType;
 import net.minecraft.world.entity.ai.attributes.Attributes;
 import net.minecraft.world.entity.boss.wither.WitherBoss;
 import net.minecraft.world.entity.decoration.ArmorStand;
-import net.minecraft.world.entity.projectile.AbstractHurtingProjectile;
 import net.minecraft.world.entity.projectile.Arrow;
 import net.minecraft.world.entity.projectile.FireworkRocketEntity;
 import net.minecraft.world.entity.projectile.FishingHook;
@@ -359,13 +358,17 @@ public class CraftLivingEntity extends CraftEntity implements LivingEntity {
 
         DamageSource reason = DamageSource.GENERIC;
 
+        net.minecraft.world.entity.LivingEntity nmsEntity = null;
+
         if (source instanceof HumanEntity) {
-            reason = DamageSource.playerAttack(((CraftHumanEntity) source).getHandle());
+            nmsEntity = ((CraftHumanEntity) source).getHandle();
+            reason = DamageSource.playerAttack((net.minecraft.world.entity.player.Player) nmsEntity);
         } else if (source instanceof LivingEntity) {
-            reason = DamageSource.mobAttack(((CraftLivingEntity) source).getHandle());
+            nmsEntity = ((CraftLivingEntity) source).getHandle();
+            reason = DamageSource.mobAttack(nmsEntity);
         }
 
-        entity.hurt(reason, (float) amount);
+        entity.hurt(reason, nmsEntity, null, (float) amount);
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index 19e37297e32028e21fb24d51a54292b1ff2d3c9b..e970ca49434ec0a78a83d2998dde883dd4c7fda0 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -26,6 +26,7 @@ import net.minecraft.world.damagesource.EntityDamageSource;
 import net.minecraft.world.damagesource.IndirectEntityDamageSource;
 import net.minecraft.world.effect.MobEffectInstance;
 import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LightningBolt;
 import net.minecraft.world.entity.Mob;
 import net.minecraft.world.entity.animal.AbstractFish;
 import net.minecraft.world.entity.animal.AbstractGolem;
@@ -229,8 +230,8 @@ import org.jetbrains.annotations.NotNull;
 public class CraftEventFactory {
     public static final DamageSource MELTING = CraftDamageSource.copyOf(DamageSource.ON_FIRE);
     public static final DamageSource POISON = CraftDamageSource.copyOf(DamageSource.MAGIC);
-    public static org.bukkit.block.@org.jetbrains.annotations.Nullable Block blockDamage; // For use in EntityDamageByBlockEvent
-    public static @org.jetbrains.annotations.Nullable Entity entityDamage; // For use in EntityDamageByEntityEvent
+    //public static org.bukkit.block.@org.jetbrains.annotations.Nullable Block blockDamage; // For use in EntityDamageByBlockEvent
+    //public static @org.jetbrains.annotations.Nullable Entity entityDamage; // For use in EntityDamageByEntityEvent
 
     // helper methods
     private static boolean canBuild(@NotNull ServerLevel world, @NotNull Player player, int x, int z) {
@@ -962,27 +963,28 @@ public class CraftEventFactory {
         return event;
     }
 
-    private static @NotNull EntityDamageEvent handleEntityDamageEvent(@NotNull Entity entity, @NotNull DamageSource source, @NotNull Map<DamageModifier, Double> modifiers, @NotNull Map<DamageModifier, Function<? super Double, Double>> modifierFunctions) {
-        return CraftEventFactory.handleEntityDamageEvent(entity, source, modifiers, modifierFunctions, false);
+    private static @NotNull EntityDamageEvent handleEntityDamageEvent(@NotNull Entity entity, @Nullable Entity damager, @Nullable Block damagerBlock, @NotNull DamageSource source, @NotNull Map<DamageModifier, Double> modifiers, @NotNull Map<DamageModifier, Function<? super Double, Double>> modifierFunctions) {
+
+        return CraftEventFactory.handleEntityDamageEvent(entity, damager, damagerBlock, source, modifiers, modifierFunctions, false);
     }
 
-    private static @NotNull EntityDamageEvent handleEntityDamageEvent(@NotNull Entity entity, @NotNull DamageSource source, @NotNull Map<DamageModifier, Double> modifiers, @NotNull Map<DamageModifier, Function<? super Double, Double>> modifierFunctions, boolean cancelled) {
+    private static @NotNull EntityDamageEvent handleEntityDamageEvent(@NotNull Entity entity, @Nullable Entity damagerEntity, @Nullable Block damagerBlock, @NotNull DamageSource source, @NotNull Map<DamageModifier, Double> modifiers, @NotNull Map<DamageModifier, Function<? super Double, Double>> modifierFunctions, boolean cancelled) {
         if (source.isExplosion()) {
             DamageCause damageCause;
-            Entity damager = CraftEventFactory.entityDamage;
-            CraftEventFactory.entityDamage = null;
+            //Entity damager = CraftEventFactory.entityDamage;
+            //CraftEventFactory.entityDamage = null;
             EntityDamageEvent event;
-            if (damager == null) {
+            if (damagerEntity == null) {
                 event = new EntityDamageByBlockEvent(null, entity.getBukkitEntity(), DamageCause.BLOCK_EXPLOSION, modifiers, modifierFunctions);
             } else if (entity instanceof EnderDragon && /*PAIL FIXME ((EntityEnderDragon) entity).target == damager*/ false) {
                 event = new EntityDamageEvent(entity.getBukkitEntity(), DamageCause.ENTITY_EXPLOSION, modifiers, modifierFunctions);
             } else {
-                if (damager instanceof org.bukkit.entity.TNTPrimed) {
+                if (damagerEntity instanceof org.bukkit.entity.TNTPrimed) {
                     damageCause = DamageCause.BLOCK_EXPLOSION;
                 } else {
                     damageCause = DamageCause.ENTITY_EXPLOSION;
                 }
-                event = new EntityDamageByEntityEvent(damager.getBukkitEntity(), entity.getBukkitEntity(), damageCause, modifiers, modifierFunctions, source.isCritical()); // Paper - add critical damage API
+                event = new EntityDamageByEntityEvent(damagerEntity.getBukkitEntity(), entity.getBukkitEntity(), damageCause, modifiers, modifierFunctions, source.isCritical()); // Paper - add critical damage API
             }
             event.setCancelled(cancelled);
 
@@ -995,14 +997,14 @@ public class CraftEventFactory {
             }
             return event;
         } else if (source instanceof EntityDamageSource) {
-            Entity damager = source.getEntity();
+            //Entity damager = source.getEntity();
             DamageCause cause = (source.isSweep()) ? DamageCause.ENTITY_SWEEP_ATTACK : DamageCause.ENTITY_ATTACK;
 
             if (source instanceof IndirectEntityDamageSource) {
-                damager = ((IndirectEntityDamageSource) source).getProximateDamageSource();
-                if (damager.getBukkitEntity() instanceof ThrownPotion) {
+                damagerEntity = ((IndirectEntityDamageSource) source).getProximateDamageSource();
+                if (damagerEntity.getBukkitEntity() instanceof ThrownPotion) {
                     cause = DamageCause.MAGIC;
-                } else if (damager.getBukkitEntity() instanceof Projectile) {
+                } else if (damagerEntity.getBukkitEntity() instanceof Projectile) {
                     cause = DamageCause.PROJECTILE;
                 }
             } else if ("thorns".equals(source.msgId)) {
@@ -1011,7 +1013,7 @@ public class CraftEventFactory {
                 cause = DamageCause.SONIC_BOOM;
             }
 
-            return CraftEventFactory.callEntityDamageEvent(damager, entity, cause, modifiers, modifierFunctions, cancelled, source.isCritical()); // Paper - add critical damage API
+            return CraftEventFactory.callEntityDamageEvent(damagerEntity, entity, cause, modifiers, modifierFunctions, cancelled, source.isCritical()); // Paper - add critical damage API
         } else if (source == DamageSource.OUT_OF_WORLD) {
             EntityDamageEvent event = new EntityDamageByBlockEvent(null, entity.getBukkitEntity(), DamageCause.VOID, modifiers, modifierFunctions);
             event.setCancelled(cancelled);
@@ -1023,13 +1025,13 @@ public class CraftEventFactory {
             }
             return event;
         } else if (source == DamageSource.LAVA) {
-            EntityDamageEvent event = (new EntityDamageByBlockEvent(CraftEventFactory.blockDamage, entity.getBukkitEntity(), DamageCause.LAVA, modifiers, modifierFunctions));
+
+            EntityDamageEvent event = (new EntityDamageByBlockEvent(damagerBlock, entity.getBukkitEntity(), DamageCause.LAVA, modifiers, modifierFunctions));
             event.setCancelled(cancelled);
 
-            Block damager = CraftEventFactory.blockDamage;
-            CraftEventFactory.blockDamage = null; // SPIGOT-6639: Clear blockDamage to allow other entity damage during event call
+            //Block damager = CraftEventFactory.blockDamage;
             CraftEventFactory.callEvent(event);
-            CraftEventFactory.blockDamage = damager; // SPIGOT-6639: Re-set blockDamage so that other entities which are also getting damaged have the right cause
+            //CraftEventFactory.blockDamage = damager; // SPIGOT-6639: Re-set blockDamage so that other entities which are also getting damaged have the right cause
 
             if (!event.isCancelled()) {
                 event.getEntity().setLastDamageCause(event);
@@ -1037,9 +1039,9 @@ public class CraftEventFactory {
                 entity.lastDamageCancelled = true; // SPIGOT-5339, SPIGOT-6252, SPIGOT-6777: Keep track if the event was canceled
             }
             return event;
-        } else if (CraftEventFactory.blockDamage != null) {
+        } else if (damagerBlock != null) {
             DamageCause cause = null;
-            Block damager = CraftEventFactory.blockDamage;
+            //Block damager = CraftEventFactory.blockDamage;
             if (source == DamageSource.CACTUS || source == DamageSource.SWEET_BERRY_BUSH || source == DamageSource.STALAGMITE || source == DamageSource.FALLING_STALACTITE || source == DamageSource.ANVIL) {
                 cause = DamageCause.CONTACT;
             } else if (source == DamageSource.HOT_FLOOR) {
@@ -1049,14 +1051,15 @@ public class CraftEventFactory {
             } else if (source == DamageSource.IN_FIRE) {
                 cause = DamageCause.FIRE;
             } else {
-                throw new IllegalStateException(String.format("Unhandled damage of %s by %s from %s", entity, damager, source.msgId));
+                System.err.printf("Unhandled damage of %s by %s from %s%n\n", entity, damagerBlock, source.msgId);
+                return null; // Skip handling
+                //throw new IllegalStateException(String.format("Unhandled damage of %s by %s from %s", entity, damager, source.msgId));
             }
-            EntityDamageEvent event = new EntityDamageByBlockEvent(damager, entity.getBukkitEntity(), cause, modifiers, modifierFunctions);
+            EntityDamageEvent event = new EntityDamageByBlockEvent(damagerBlock, entity.getBukkitEntity(), cause, modifiers, modifierFunctions);
             event.setCancelled(cancelled);
 
-            CraftEventFactory.blockDamage = null; // SPIGOT-6639: Clear blockDamage to allow other entity damage during event call
             CraftEventFactory.callEvent(event);
-            CraftEventFactory.blockDamage = damager; // SPIGOT-6639: Re-set blockDamage so that other entities which are also getting damaged have the right cause
+            //CraftEventFactory.blockDamage = damager; // SPIGOT-6639: Re-set blockDamage so that other entities which are also getting damaged have the right cause
 
             if (!event.isCancelled()) {
                 event.getEntity().setLastDamageCause(event);
@@ -1064,13 +1067,11 @@ public class CraftEventFactory {
                 entity.lastDamageCancelled = true; // SPIGOT-5339, SPIGOT-6252, SPIGOT-6777: Keep track if the event was canceled
             }
             return event;
-        } else if (CraftEventFactory.entityDamage != null) {
+        } else if (damagerEntity != null) {
             DamageCause cause = null;
-            CraftEntity damager = CraftEventFactory.entityDamage.getBukkitEntity();
-            CraftEventFactory.entityDamage = null;
             if (source == DamageSource.ANVIL || source == DamageSource.FALLING_BLOCK || source == DamageSource.FALLING_STALACTITE) {
                 cause = DamageCause.FALLING_BLOCK;
-            } else if (damager instanceof LightningStrike) {
+            } else if (damagerEntity instanceof LightningStrike || damagerEntity instanceof LightningBolt) {
                 cause = DamageCause.LIGHTNING;
             } else if (source == DamageSource.FALL) {
                 cause = DamageCause.FALL;
@@ -1079,9 +1080,9 @@ public class CraftEventFactory {
             } else if (source == DamageSource.MAGIC) {
                 cause = DamageCause.MAGIC;
             } else {
-                throw new IllegalStateException(String.format("Unhandled damage of %s by %s from %s", entity, damager.getHandle(), source.msgId));
+                throw new IllegalStateException(String.format("Unhandled damage of %s by %s from %s", entity, damagerEntity.getBukkitEntity().getHandle(), source.msgId));
             }
-            EntityDamageEvent event = new EntityDamageByEntityEvent(damager, entity.getBukkitEntity(), cause, modifiers, modifierFunctions, source.isCritical()); // Paper - add critical damage API
+            EntityDamageEvent event = new EntityDamageByEntityEvent(damagerEntity.getBukkitEntity(), entity.getBukkitEntity(), cause, modifiers, modifierFunctions, source.isCritical()); // Paper - add critical damage API
             event.setCancelled(cancelled);
             CraftEventFactory.callEvent(event);
             if (!event.isCancelled()) {
@@ -1165,7 +1166,7 @@ public class CraftEventFactory {
 
     private static final Function<? super Double, Double> ZERO = Functions.constant(Double.valueOf(-0.0));
 
-    public static @NotNull EntityDamageEvent handleLivingEntityDamageEvent(Entity damagee, @NotNull DamageSource source, double rawDamage, double hardHatModifier, double blockingModifier, double armorModifier, double resistanceModifier, double magicModifier, double absorptionModifier, Function<Double, Double> hardHat, Function<Double, Double> blocking, Function<Double, Double> armor, Function<Double, Double> resistance, Function<Double, Double> magic, Function<Double, Double> absorption) {
+    public static @NotNull EntityDamageEvent handleLivingEntityDamageEvent(Entity damagee, @Nullable Entity damagerEntity, @Nullable Block damagerBlock, @NotNull DamageSource source, double rawDamage, double hardHatModifier, double blockingModifier, double armorModifier, double resistanceModifier, double magicModifier, double absorptionModifier, Function<Double, Double> hardHat, Function<Double, Double> blocking, Function<Double, Double> armor, Function<Double, Double> resistance, Function<Double, Double> magic, Function<Double, Double> absorption) {
         Map<DamageModifier, Double> modifiers = new EnumMap<DamageModifier, Double>(DamageModifier.class);
         Map<DamageModifier, Function<? super Double, Double>> modifierFunctions = new EnumMap<DamageModifier, Function<? super Double, Double>>(DamageModifier.class);
         modifiers.put(DamageModifier.BASE, Double.valueOf(rawDamage));
@@ -1186,26 +1187,26 @@ public class CraftEventFactory {
         modifierFunctions.put(DamageModifier.MAGIC, magic);
         modifiers.put(DamageModifier.ABSORPTION, Double.valueOf(absorptionModifier));
         modifierFunctions.put(DamageModifier.ABSORPTION, absorption);
-        return CraftEventFactory.handleEntityDamageEvent(damagee, source, modifiers, modifierFunctions);
+        return CraftEventFactory.handleEntityDamageEvent(damagee, damagerEntity, damagerBlock, source, modifiers, modifierFunctions);
     }
 
     // Non-Living Entities such as EntityEnderCrystal and EntityFireball need to call this
-    public static boolean handleNonLivingEntityDamageEvent(@NotNull Entity entity, @NotNull DamageSource source, double damage) {
-        return CraftEventFactory.handleNonLivingEntityDamageEvent(entity, source, damage, true);
+    public static boolean handleNonLivingEntityDamageEvent(@NotNull Entity entity, @Nullable Entity damagerEntity, @Nullable Block damagerBlock, @NotNull DamageSource source, double damage) {
+        return CraftEventFactory.handleNonLivingEntityDamageEvent(entity, damagerEntity, damagerBlock, source, damage, true);
     }
 
-    public static boolean handleNonLivingEntityDamageEvent(@NotNull Entity entity, @NotNull DamageSource source, double damage, boolean cancelOnZeroDamage) {
-        return CraftEventFactory.handleNonLivingEntityDamageEvent(entity, source, damage, cancelOnZeroDamage, false);
+    public static boolean handleNonLivingEntityDamageEvent(@NotNull Entity entity, @Nullable Entity damagerEntity, @Nullable Block damagerBlock, @NotNull DamageSource source, double damage, boolean cancelOnZeroDamage) {
+        return CraftEventFactory.handleNonLivingEntityDamageEvent(entity, damagerEntity, damagerBlock, source, damage, cancelOnZeroDamage, false);
     }
 
-    public static boolean handleNonLivingEntityDamageEvent(@NotNull Entity entity, @NotNull DamageSource source, double damage, boolean cancelOnZeroDamage, boolean cancelled) {
+    public static boolean handleNonLivingEntityDamageEvent(@NotNull Entity entity, @Nullable Entity damagerEntity, @Nullable Block damagerBlock, @NotNull DamageSource source, double damage, boolean cancelOnZeroDamage, boolean cancelled) {
         final EnumMap<DamageModifier, Double> modifiers = new EnumMap<DamageModifier, Double>(DamageModifier.class);
         final EnumMap<DamageModifier, Function<? super Double, Double>> functions = new EnumMap(DamageModifier.class);
 
         modifiers.put(DamageModifier.BASE, Double.valueOf(damage));
         functions.put(DamageModifier.BASE, ZERO);
 
-        final EntityDamageEvent event = CraftEventFactory.handleEntityDamageEvent(entity, source, modifiers, functions, cancelled);
+        final EntityDamageEvent event = CraftEventFactory.handleEntityDamageEvent(entity, damagerEntity, damagerBlock, source, modifiers, functions, cancelled);
 
         if (event == null) {
             return false;
diff --git a/src/main/java/org/bukkit/craftbukkit/util/BlockStateListPopulator.java b/src/main/java/org/bukkit/craftbukkit/util/BlockStateListPopulator.java
index faad2f39a62b58d46d3ef8fff352a18ad3dc1949..83ab1cfc7acbdcb4bad4eb6fc18207e865225dab 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/BlockStateListPopulator.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/BlockStateListPopulator.java
@@ -6,6 +6,7 @@ import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Predicate;
 import net.minecraft.core.BlockPos;
 import net.minecraft.server.level.ServerLevel;
@@ -24,7 +25,7 @@ import org.jetbrains.annotations.NotNull;
 public class BlockStateListPopulator extends DummyGeneratorAccess {
     private final LevelAccessor world;
     private final Map<BlockPos, net.minecraft.world.level.block.state.BlockState> dataMap = new HashMap<>();
-    private final Map<BlockPos, BlockEntity> entityMap = new HashMap<>();
+    private final Map<BlockPos, BlockEntity> entityMap = new ConcurrentHashMap<>();
     private final LinkedHashMap<BlockPos, CraftBlockState> list;
 
     public BlockStateListPopulator(LevelAccessor world) {
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index c02a04d284734b5f545b64307ed4aea337c1465f..292a54b8d7ff82256fa5a4eb70d3f03a3ae9c15b 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -1,7 +1,5 @@
 package org.spigotmc;
 
-import net.minecraft.server.MinecraftServer;
-
 public class AsyncCatcher
 {
 
@@ -10,10 +8,14 @@ public class AsyncCatcher
 
     public static void catchOp(String reason)
     {
+
+        // Cat - Who cares >:)
+        /*
         if ( !io.papermc.paper.util.TickThread.isTickThread() ) // Paper // Paper - rewrite chunk system
         {
             MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable()); // Paper
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
         }
+        */
     }
 }
