From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: camdenorrb <me@12oclock.dev>
Date: Tue, 15 Nov 2022 03:23:59 -0600
Subject: [PATCH] Fix crashes


diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
index e4fa22810530cfaec6c709a3e604c2b96a8373a2..2dd64f7944286f66289c9c5094a486355f13716d 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
@@ -269,12 +269,14 @@ public final class ChunkTaskScheduler {
     public void scheduleTickingState(final int chunkX, final int chunkZ, final ChunkHolder.@NotNull FullChunkStatus toStatus,
                                      final boolean addTicket, final PrioritisedExecutor.@NotNull Priority priority,
                                      final @Nullable Consumer<LevelChunk> onComplete) {
+
+        /*
         if (!TickThread.isTickThread()) {
             this.scheduleChunkTask(chunkX, chunkZ, () -> {
                 ChunkTaskScheduler.this.scheduleTickingState(chunkX, chunkZ, toStatus, addTicket, priority, onComplete);
             }, priority);
             return;
-        }
+        }*/
         if (this.chunkHolderManager.ticketLock.isHeldByCurrentThread()) {
             throw new IllegalStateException("Cannot schedule chunk load during ticket level update");
         }
@@ -384,12 +386,15 @@ public final class ChunkTaskScheduler {
 
     public void scheduleChunkLoad(final int chunkX, final int chunkZ, final @NotNull ChunkStatus toStatus, final boolean addTicket,
                                   final PrioritisedExecutor.@NotNull Priority priority, final @Nullable Consumer<ChunkAccess> onComplete) {
+
+        /*
         if (!TickThread.isTickThread()) {
             //this.scheduleChunkTask(chunkX, chunkZ, () -> {
             ChunkTaskScheduler.this.scheduleChunkLoad(chunkX, chunkZ, toStatus, addTicket, priority, onComplete);
             //}, priority);
             return;
         }
+        */
         if (this.chunkHolderManager.ticketLock.isHeldByCurrentThread()) {
             throw new IllegalStateException("Cannot schedule chunk load during ticket level update");
         }
diff --git a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
index 01c3bdac989df14396cfb5bd3e6f7eed6abf07d1..3fc672f0b4ab0c89836a6d20e8802646eee055b2 100644
--- a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
+++ b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
@@ -8,6 +8,7 @@ import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 import net.minecraft.Util;
@@ -19,7 +20,7 @@ import org.slf4j.Logger;
 
 public class AttributeMap {
     private static final Logger LOGGER = LogUtils.getLogger();
-    private final Map<Attribute, AttributeInstance> attributes = Maps.newHashMap();
+    private final Map<Attribute, AttributeInstance> attributes = new ConcurrentHashMap<>();
     private final Set<AttributeInstance> dirtyAttributes = Sets.newHashSet();
     private final AttributeSupplier supplier;
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/NearestLivingEntitySensor.java b/src/main/java/net/minecraft/world/entity/ai/sensing/NearestLivingEntitySensor.java
index f0b55ea87e9df9407c4f762dff05b8d69858d769..b02a1baa4804114f5cc8d79aa277758c70398dae 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/NearestLivingEntitySensor.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/NearestLivingEntitySensor.java
@@ -1,15 +1,18 @@
 package net.minecraft.world.entity.ai.sensing;
 
 import com.google.common.collect.ImmutableSet;
-import java.util.Comparator;
-import java.util.List;
-import java.util.Set;
+
+import java.util.*;
+import java.util.function.ToDoubleFunction;
+
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.ai.Brain;
 import net.minecraft.world.entity.ai.memory.MemoryModuleType;
 import net.minecraft.world.entity.ai.memory.NearestVisibleLivingEntities;
 import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
+
 
 public class NearestLivingEntitySensor<T extends LivingEntity> extends Sensor<T> {
     @Override
@@ -24,7 +27,23 @@ public class NearestLivingEntitySensor<T extends LivingEntity> extends Sensor<T>
             return e != entity && e.isAlive();
         });
 
-        list.sort(Comparator.comparingDouble(entity::distanceToSqr));
+
+        final Map<Integer, Vec3> entityVectorByID = new HashMap<>(list.size());
+
+        list.forEach((e) -> {
+            entityVectorByID.put(e.getId(), e.position());
+        });
+
+        final Vec3 entityPosition = entity.position();
+
+        list.sort(new Comparator<LivingEntity>() {
+            @Override
+            public int compare(final LivingEntity o1, final LivingEntity o2) {
+                return Double.compare(entityVectorByID.get(o1.getId()).distanceToSqr(entityPosition), entityVectorByID.get(o2.getId()).distanceToSqr(entityPosition));
+            }
+        });
+
+
         Brain<?> brain = entity.getBrain();
         brain.setMemory(MemoryModuleType.NEAREST_LIVING_ENTITIES, list);
         brain.setMemory(MemoryModuleType.NEAREST_VISIBLE_LIVING_ENTITIES, new NearestVisibleLivingEntities(entity, list));
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java b/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
index b021ab60e464206c8ead56f0a9adf929f91b06ef..8b19546da69737fe53676c988e5170aeb06648f2 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
@@ -52,11 +52,18 @@ public class WalkNodeEvaluator extends NodeEvaluator {
     @Nullable
     @Override
     public @org.jetbrains.annotations.Nullable Node getStart() {
+
+        final Mob mob = this.mob;
+
+        if (mob == null) {
+            return null;
+        }
+
         BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
-        int i = this.mob.getBlockY();
-        BlockState blockState = this.level.getBlockState(mutableBlockPos.set(this.mob.getX(), i, this.mob.getZ()));
-        if (!this.mob.canStandOnFluid(blockState.getFluidState())) {
-            if (this.canFloat() && this.mob.isInWater()) {
+        int i = mob.getBlockY();
+        BlockState blockState = this.level.getBlockState(mutableBlockPos.set(mob.getX(), i, mob.getZ()));
+        if (!mob.canStandOnFluid(blockState.getFluidState())) {
+            if (this.canFloat() && mob.isInWater()) {
                 while(true) {
                     if (!blockState.is(Blocks.WATER) && blockState.getFluidState() != Fluids.WATER.getSource(false)) {
                         --i;
@@ -64,21 +71,21 @@ public class WalkNodeEvaluator extends NodeEvaluator {
                     }
 
                     ++i;
-                    blockState = this.level.getBlockState(mutableBlockPos.set(this.mob.getX(), i, this.mob.getZ()));
+                    blockState = this.level.getBlockState(mutableBlockPos.set(mob.getX(), i, mob.getZ()));
                 }
-            } else if (this.mob.isOnGround()) {
-                i = Mth.floor(this.mob.getY() + 0.5D);
+            } else if (mob.isOnGround()) {
+                i = Mth.floor(mob.getY() + 0.5D);
             } else {
                 BlockPos blockPos;
-                for(blockPos = this.mob.blockPosition(); (this.level.getBlockState(blockPos).isAir() || this.level.getBlockState(blockPos).isPathfindable(this.level, blockPos, PathComputationType.LAND)) && blockPos.getY() > this.mob.level.getMinBuildHeight(); blockPos = blockPos.below()) {
+                for(blockPos = mob.blockPosition(); (this.level.getBlockState(blockPos).isAir() || this.level.getBlockState(blockPos).isPathfindable(this.level, blockPos, PathComputationType.LAND)) && blockPos.getY() > mob.level.getMinBuildHeight(); blockPos = blockPos.below()) {
                 }
 
                 i = blockPos.above().getY();
             }
         } else {
-            while(this.mob.canStandOnFluid(blockState.getFluidState())) {
+            while(mob.canStandOnFluid(blockState.getFluidState())) {
                 ++i;
-                blockState = this.level.getBlockState(mutableBlockPos.set(this.mob.getX(), i, this.mob.getZ()));
+                blockState = this.level.getBlockState(mutableBlockPos.set(mob.getX(), i, mob.getZ()));
             }
 
             --i;
