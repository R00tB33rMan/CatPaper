From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: camdenorrb <me@12oclock.dev>
Date: Thu, 17 Nov 2022 03:20:05 -0600
Subject: [PATCH] Fix crashes


diff --git a/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java b/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java
index bedffdcc5751e2242aebae016bcc223f43f93296..4d37f4f7a2cb6e44a2a6cfc721dbf7e3a817fc8a 100644
--- a/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java
+++ b/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java
@@ -7,7 +7,10 @@ import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 import java.util.Arrays;
+import java.util.List;
 import java.util.NoSuchElementException;
+import java.util.concurrent.CopyOnWriteArrayList;
+
 
 public final class IteratorSafeOrderedReferenceSet<E> {
 
@@ -17,7 +20,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
     protected int firstInvalidIndex = -1;
 
     /* list impl */
-    protected E[] listElements;
+    protected CopyOnWriteArrayList<E> listElements;
     protected int listSize;
 
     protected final double maxFragFactor;
@@ -43,7 +46,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         this.indexMap = new Reference2IntLinkedOpenHashMap<>(setCapacity, setLoadFactor);
         this.indexMap.defaultReturnValue(-1);
         this.maxFragFactor = maxFragFactor;
-        this.listElements = (E[])new Object[arrayCapacity];
+        this.listElements = new CopyOnWriteArrayList();
         this.threadRestricted = threadRestricted;
     }
 
@@ -109,10 +112,10 @@ public final class IteratorSafeOrderedReferenceSet<E> {
     }
 
     public int advanceRawIterator(final int index) {
-        final E[] elements = this.listElements;
+        final List<E> elements = this.listElements;
         int ret = index + 1;
         for (int len = this.listSize; ret < len; ++ret) {
-            if (elements[ret] != null) {
+            if (elements.get(ret) != null) {
                 return ret;
             }
         }
@@ -121,11 +124,12 @@ public final class IteratorSafeOrderedReferenceSet<E> {
     }
 
     public void finishRawIterator() {
+        /*
         if (this.allowSafeIteration() && --this.iteratorCount == 0) {
             if (this.getFragFactor() >= this.maxFragFactor) {
                 this.defrag();
             }
-        }
+        }*/
     }
 
     public boolean remove(final E element) {
@@ -134,13 +138,9 @@ public final class IteratorSafeOrderedReferenceSet<E> {
             if (this.firstInvalidIndex < 0 || index < this.firstInvalidIndex) {
                 this.firstInvalidIndex = index;
             }
-            if (this.listElements[index] != element) {
+            if (!this.listElements.remove(element)) {
                 throw new IllegalStateException();
             }
-            this.listElements[index] = null;
-            if (this.allowSafeIteration() && this.iteratorCount == 0 && this.getFragFactor() >= this.maxFragFactor) {
-                this.defrag();
-            }
             //this.check();
             return true;
         }
@@ -159,16 +159,14 @@ public final class IteratorSafeOrderedReferenceSet<E> {
             return false;
         }
 
-        if (listSize >= this.listElements.length) {
-            this.listElements = Arrays.copyOf(this.listElements, listSize * 2);
-        }
-        this.listElements[listSize] = element;
+        this.listElements.add(element);
         this.listSize = listSize + 1;
 
         //this.check();
         return true;
     }
 
+    /*
     protected void defrag() {
         if (this.firstInvalidIndex < 0) {
             return; // nothing to do
@@ -224,10 +222,10 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         this.listSize = lastValidIndex;
         this.firstInvalidIndex = -1;
         //this.check();
-    }
+    }*/
 
     public E rawGet(final int index) {
-        return this.listElements[index];
+        return this.listElements.get(index);
     }
 
     public int size() {
@@ -284,10 +282,10 @@ public final class IteratorSafeOrderedReferenceSet<E> {
                 return true;
             }
 
-            final E[] elements = this.set.listElements;
+            final List<E> elements = this.set.listElements;
             int index, len;
             for (index = this.nextIndex, len = Math.min(this.maxIndex, this.set.listSize); index < len; ++index) {
-                final E element = elements[index];
+                final E element = elements.get(index);
                 if (element != null) {
                     this.pendingValue = element;
                     this.nextIndex = index + 1;
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index da3b12b796e1f3ed78783d421dcee7b046fe3027..f6bda3743e562436077897441cd99b88ee562e46 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -138,7 +138,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     private final Queue<Runnable> unloadQueue;
     int viewDistance;
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobDistanceMap; // Paper
-    public final ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcasting = new ReferenceOpenHashSet<>();
+    public final CopyOnWriteArraySet<ChunkHolder> needsChangeBroadcasting = new CopyOnWriteArraySet<>();
 
     // Paper - rewrite chunk system
     // Paper start - optimise checkDespawn
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index f7d5bfe235a63337824dd50ef133e17e7e355d65..770610b6395cd02491ac5240d98347f005c6fac5 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -6,12 +6,7 @@ import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
 import java.io.File;
 import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
+import java.util.*;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
@@ -411,7 +406,7 @@ public class ServerChunkCache extends ChunkSource {
             // Paper - rewrite chunk system - there are no correct callbacks to remove items from cache in the new chunk system
 
             gameprofilerfiller.incrementCounter("getChunkCacheMiss");
-            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getChunkFutureMainThread(x, z, leastStatus, create, true); // Paper
+            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getChunkFuture(x, z, leastStatus, create); // Paper
             ServerChunkCache.MainThreadExecutor chunkproviderserver_b = this.mainThreadProcessor;
 
             Objects.requireNonNull(completablefuture);
@@ -764,7 +759,7 @@ public class ServerChunkCache extends ChunkSource {
             gameprofilerfiller.popPush("broadcast");
             this.level.timings.broadcastChunkUpdates.startTiming(); // Paper - timing
             if (!this.chunkMap.needsChangeBroadcasting.isEmpty()) {
-                ReferenceOpenHashSet<ChunkHolder> copy = this.chunkMap.needsChangeBroadcasting.clone();
+                HashSet<ChunkHolder> copy = new HashSet<>(this.chunkMap.needsChangeBroadcasting);
                 this.chunkMap.needsChangeBroadcasting.clear();
                 for (ChunkHolder holder : copy) {
                     holder.broadcastChanges(holder.getFullChunkNowUnchecked()); // LevelChunks are NEVER unloaded
diff --git a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
index 96a00dcce59d76c143a29c53a52ab0afd412a75d..63c239f39b630438aae21cb9f4f14f80537c74f3 100644
--- a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
+++ b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
@@ -133,6 +133,7 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     }
 
     public void managedBlock(BooleanSupplier stopCondition) {
+
         ++this.blockingCount;
 
         try {
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index de6fcf6cae6a7a70bcad5f6f5567f2beb16bd40b..d808d1764dd1977e24beaac44ba14986219e8140 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -12,6 +12,7 @@ import com.mojang.serialization.DataResult;
 import com.mojang.serialization.Dynamic;
 
 import java.util.*;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
 import net.minecraft.BlockUtil;
@@ -250,7 +251,7 @@ public abstract class LivingEntity extends Entity {
     // CraftBukkit start
     public int expToDrop;
     public boolean forceDrops;
-    public ArrayList<org.bukkit.inventory.ItemStack> drops = new ArrayList<org.bukkit.inventory.ItemStack>();
+    public List<org.bukkit.inventory.ItemStack> drops = new CopyOnWriteArrayList<org.bukkit.inventory.ItemStack>();
     public final org.bukkit.craftbukkit.attribute.CraftAttributeMap craftAttributes;
     public boolean collides = true;
     public Set<UUID> collidableExemptions = new HashSet<>();
diff --git a/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java b/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
index d0ea77854b0a0c250a347ba469c69e3011ad574a..e93d3bf28b1e436709c8923d8bd1f24c4dd8bf61 100644
--- a/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
+++ b/src/main/java/net/minecraft/world/entity/ai/navigation/PathNavigation.java
@@ -417,10 +417,13 @@ public abstract class PathNavigation {
     }
 
     public boolean shouldRecomputePath(BlockPos pos) {
+
+        final Path path = this.path;
+
         if (this.hasDelayedRecomputation) {
             return false;
-        } else if (this.path != null && !this.path.isDone() && this.path.getNodeCount() != 0) {
-            Node node = this.path.getEndNode();
+        } else if (path != null && !this.path.isDone() && this.path.getNodeCount() != 0) {
+            Node node = path.getEndNode();
             Vec3 vec3 = new Vec3(((double)node.x + this.mob.getX()) / 2.0D, ((double)node.y + this.mob.getY()) / 2.0D, ((double)node.z + this.mob.getZ()) / 2.0D);
             return pos.closerToCenterThan(vec3, this.path.getNodeCount() - this.path.getNextNodeIndex());
         } else {
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java b/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
index 206a986659da3249a58b54f70175114b9a15b792..e06b4955e813e5d4d42993b2950ff6dae2dd578e 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
@@ -227,6 +227,11 @@ public class WalkNodeEvaluator extends NodeEvaluator {
     }
 
     public static double getFloorLevel(BlockGetter world, BlockPos pos) {
+
+        if (world == null) {
+            return 0;
+        }
+
         BlockPos blockPos = pos.below();
         VoxelShape voxelShape = world.getBlockState(blockPos).getCollisionShape(world, blockPos);
         return (double)blockPos.getY() + (voxelShape.isEmpty() ? 0.0D : voxelShape.max(Direction.Axis.Y));
@@ -244,9 +249,15 @@ public class WalkNodeEvaluator extends NodeEvaluator {
         if (d - prevFeetY > 1.125D) {
             return null;
         } else {
-            BlockPathTypes blockPathTypes = this.getCachedBlockType(this.mob, x, y, z);
-            float f = this.mob.getPathfindingMalus(blockPathTypes);
-            double e = (double)this.mob.getBbWidth() / 2.0D;
+
+            final Mob mob = this.mob;
+            if (mob == null) {
+                return null;
+            }
+
+            BlockPathTypes blockPathTypes = this.getCachedBlockType(mob, x, y, z);
+            float f = mob.getPathfindingMalus(blockPathTypes);
+            double e = (double)mob.getBbWidth() / 2.0D;
             if (f >= 0.0F) {
                 node = this.getNodeAndUpdateCostToMax(x, y, z, blockPathTypes, f);
             }
@@ -258,10 +269,10 @@ public class WalkNodeEvaluator extends NodeEvaluator {
             if (blockPathTypes != BlockPathTypes.WALKABLE && (!this.isAmphibious() || blockPathTypes != BlockPathTypes.WATER)) {
                 if ((node == null || node.costMalus < 0.0F) && maxYStep > 0 && blockPathTypes != BlockPathTypes.FENCE && blockPathTypes != BlockPathTypes.UNPASSABLE_RAIL && blockPathTypes != BlockPathTypes.TRAPDOOR && blockPathTypes != BlockPathTypes.POWDER_SNOW) {
                     node = this.findAcceptedNode(x, y + 1, z, maxYStep - 1, prevFeetY, direction, nodeType);
-                    if (node != null && (node.type == BlockPathTypes.OPEN || node.type == BlockPathTypes.WALKABLE) && this.mob.getBbWidth() < 1.0F) {
+                    if (node != null && (node.type == BlockPathTypes.OPEN || node.type == BlockPathTypes.WALKABLE) && mob.getBbWidth() < 1.0F) {
                         double g = (double)(x - direction.getStepX()) + 0.5D;
                         double h = (double)(z - direction.getStepZ()) + 0.5D;
-                        AABB aABB = new AABB(g - e, getFloorLevel(this.level, mutableBlockPos.set(g, y + 1, h)) + 0.001D, h - e, g + e, (double)this.mob.getBbHeight() + getFloorLevel(this.level, mutableBlockPos.set(node.x, node.y, (double)node.z)) - 0.002D, h + e);
+                        AABB aABB = new AABB(g - e, getFloorLevel(this.level, mutableBlockPos.set(g, y + 1, h)) + 0.001D, h - e, g + e, (double)mob.getBbHeight() + getFloorLevel(this.level, mutableBlockPos.set(node.x, node.y, (double)node.z)) - 0.002D, h + e);
                         if (this.hasCollisions(aABB)) {
                             node = null;
                         }
@@ -269,18 +280,18 @@ public class WalkNodeEvaluator extends NodeEvaluator {
                 }
 
                 if (!this.isAmphibious() && blockPathTypes == BlockPathTypes.WATER && !this.canFloat()) {
-                    if (this.getCachedBlockType(this.mob, x, y - 1, z) != BlockPathTypes.WATER) {
+                    if (this.getCachedBlockType(mob, x, y - 1, z) != BlockPathTypes.WATER) {
                         return node;
                     }
 
-                    while(y > this.mob.level.getMinBuildHeight()) {
+                    while(y > mob.level.getMinBuildHeight()) {
                         --y;
-                        blockPathTypes = this.getCachedBlockType(this.mob, x, y, z);
+                        blockPathTypes = this.getCachedBlockType(mob, x, y, z);
                         if (blockPathTypes != BlockPathTypes.WATER) {
                             return node;
                         }
 
-                        node = this.getNodeAndUpdateCostToMax(x, y, z, blockPathTypes, this.mob.getPathfindingMalus(blockPathTypes));
+                        node = this.getNodeAndUpdateCostToMax(x, y, z, blockPathTypes, mob.getPathfindingMalus(blockPathTypes));
                     }
                 }
 
@@ -290,16 +301,16 @@ public class WalkNodeEvaluator extends NodeEvaluator {
 
                     while(blockPathTypes == BlockPathTypes.OPEN) {
                         --y;
-                        if (y < this.mob.level.getMinBuildHeight()) {
+                        if (y < mob.level.getMinBuildHeight()) {
                             return this.getBlockedNode(x, j, z);
                         }
 
-                        if (i++ >= this.mob.getMaxFallDistance()) {
+                        if (i++ >= mob.getMaxFallDistance()) {
                             return this.getBlockedNode(x, y, z);
                         }
 
-                        blockPathTypes = this.getCachedBlockType(this.mob, x, y, z);
-                        f = this.mob.getPathfindingMalus(blockPathTypes);
+                        blockPathTypes = this.getCachedBlockType(mob, x, y, z);
+                        f = mob.getPathfindingMalus(blockPathTypes);
                         if (blockPathTypes != BlockPathTypes.OPEN && f >= 0.0F) {
                             node = this.getNodeAndUpdateCostToMax(x, y, z, blockPathTypes, f);
                             break;
