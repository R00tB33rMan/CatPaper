From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: camdenorrb <me@12oclock.dev>
Date: Thu, 17 Nov 2022 02:39:19 -0600
Subject: [PATCH] Fix crashes


diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index 4b969486060788d38aefe6bbc6b3da8f9bc4ff4f..e7b63f84c5b8ab86b2ec2ed17592825720b6f77a 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -547,6 +547,12 @@ public final class PlayerChunkLoader {
             if (this.chunkSendQueue.isEmpty()) {
                 break;
             }
+
+            final PlayerLoaderData data = this.chunkSendQueue.stream().findFirst().orElse(null);
+            if (data == null) {
+                break;
+            }
+
             final int currSends = concurrentChunkSends.get();
             if (currSends >= maxSends) {
                 break;
@@ -556,9 +562,6 @@ public final class PlayerChunkLoader {
                 continue;
             }
 
-            // send chunk
-
-            final PlayerLoaderData data = this.chunkSendQueue.iterator().next();
             this.chunkSendQueue.remove(data);
 
             final ChunkPriorityHolder queuedSend = data.sendQueue.pollFirst();
@@ -796,7 +799,7 @@ public final class PlayerChunkLoader {
         protected final ConcurrentSkipListSet<Long> sentChunks = new ConcurrentSkipListSet<>();
         protected final LongOpenHashSet chunksToBeSent = new LongOpenHashSet();
 
-        protected final TreeSet<ChunkPriorityHolder> sendQueue = new TreeSet<>((final @NotNull ChunkPriorityHolder p1, final @NotNull ChunkPriorityHolder p2) -> {
+        protected final ConcurrentSkipListSet<ChunkPriorityHolder> sendQueue = new ConcurrentSkipListSet<>((final @NotNull ChunkPriorityHolder p1, final @NotNull ChunkPriorityHolder p2) -> {
             final int distanceCompare = Integer.compare(p1.manhattanDistanceToPlayer, p2.manhattanDistanceToPlayer);
             if (distanceCompare != 0) {
                 return distanceCompare;
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index fe17ff192f72781fe36f68b2f5a536a7339c784e..f7d5bfe235a63337824dd50ef133e17e7e355d65 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -13,6 +13,8 @@ import java.util.List;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
@@ -71,8 +73,8 @@ public class ServerChunkCache extends ChunkSource {
     @VisibleForDebug
     private NaturalSpawner.SpawnState lastSpawnState;
     // Paper start
-    final com.destroystokyo.paper.util.concurrent.WeakSeqLock loadedChunkMapSeqLock = new com.destroystokyo.paper.util.concurrent.WeakSeqLock();
-    final it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<LevelChunk> loadedChunkMap = new it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<>(8192, 0.5f);
+    //final com.destroystokyo.paper.util.concurrent.WeakSeqLock loadedChunkMapSeqLock = new com.destroystokyo.paper.util.concurrent.WeakSeqLock();
+    final ConcurrentMap<Long, LevelChunk> loadedChunkMap = new ConcurrentHashMap<>(8192, 0.5f);
 
     private final LevelChunk[] lastLoadedChunks = new LevelChunk[4 * 4];
 
@@ -81,12 +83,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public void addLoadedChunk(LevelChunk chunk) {
-        this.loadedChunkMapSeqLock.acquireWrite();
-        try {
-            this.loadedChunkMap.put(chunk.coordinateKey, chunk);
-        } finally {
-            this.loadedChunkMapSeqLock.releaseWrite();
-        }
+        this.loadedChunkMap.put(chunk.coordinateKey, chunk);
 
         // rewrite cache if we have to
         // we do this since we also cache null chunks
@@ -96,12 +93,8 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public void removeLoadedChunk(LevelChunk chunk) {
-        this.loadedChunkMapSeqLock.acquireWrite();
-        try {
-            this.loadedChunkMap.remove(chunk.coordinateKey);
-        } finally {
-            this.loadedChunkMapSeqLock.releaseWrite();
-        }
+
+        this.loadedChunkMap.remove(chunk.coordinateKey);
 
         // rewrite cache if we have to
         // we do this since we also cache null chunks
@@ -371,23 +364,9 @@ public class ServerChunkCache extends ChunkSource {
             return this.getChunkAtIfLoadedMainThread(x, z);
         }
 
-        LevelChunk ret = null;
-        long readlock;
-        do {
-            readlock = this.loadedChunkMapSeqLock.acquireRead();
-            try {
-                ret = this.loadedChunkMap.get(k);
-            } catch (Throwable thr) {
-                if (thr instanceof ThreadDeath) {
-                    throw (ThreadDeath)thr;
-                }
-                // re-try, this means a CME occurred...
-                continue;
-            }
-        } while (!this.loadedChunkMapSeqLock.tryReleaseRead(readlock));
-
-        return ret;
+        return this.loadedChunkMap.get(k);
     }
+
     // Paper end
     // Paper start - async chunk io
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkAtAsynchronously(int x, int z, boolean gen, boolean isUrgent) {
